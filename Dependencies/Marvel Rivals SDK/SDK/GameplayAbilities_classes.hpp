#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: GameplayAbilities

#include "Basic.hpp"

#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "GameplayAbilities_structs.hpp"
#include "GameplayTags_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "GameplayTasks_classes.hpp"
#include "MovieScene_classes.hpp"


namespace SDK
{

// Class GameplayAbilities.AbilityTask
// 0x0120 (0x0198 - 0x0078)
class UAbilityTask : public UGameplayTask
{
public:
	uint8                                         Pad_78[0x38];                                      // 0x0078(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bValidCounter;                                     // 0x00B0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B1[0x7];                                       // 0x00B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UGameplayAbility*                       Ability;                                           // 0x00B8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UAbilitySystemComponent> AbilitySystemComponent;                            // 0x00C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPredictionKey                         TaskPredictionKey;                                 // 0x00C8(0x0070)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FPredictionKey>                 WaitingKeys;                                       // 0x0138(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<class FString>                         LockingAbilityKeys;                                // 0x0148(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<class FString>                         WaitDataKeys;                                      // 0x0158(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	int32                                         WaitData;                                          // 0x0168(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_16C[0x1];                                      // 0x016C(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         WaitStateBitMask;                                  // 0x016D(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bWasSuccessfullyDestroyed : 1;                     // 0x016E(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	bool                                          bWithAbility;                                      // 0x016F(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   GATaskName;                                        // 0x0170(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17C[0x1C];                                     // 0x017C(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAbilityTask* K2_NewAbilityTask(class UClass* TaskClass, class UGameplayAbility* ThisAbility, class FName InInstanceName);

	void K2_OnActivate();
	void K2_OnDestroy();

	bool IsForRemoteClient() const;
	bool IsForRunAlone() const;
	bool IsLocallyControlled() const;
	bool IsLocallyControlledPlayer() const;
	bool IsNetAutonomousOrHasLocalNetOwner() const;
	bool IsPredictingClient() const;
	bool ShouldBroadcastAbilityTaskDelegates() const;

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("AbilityTask")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"AbilityTask")
	}
	static class UAbilityTask* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityTask>();
	}
};
DUMPER7_ASSERTS_UAbilityTask;

// Class GameplayAbilities.GameplayAbilityTargetActor
// 0x0230 (0x0910 - 0x06E0)
class AGameplayAbilityTargetActor : public AActor
{
public:
	bool                                          ShouldProduceTargetDataOnServer;                   // 0x06D8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6D9[0x7];                                      // 0x06D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayAbilityTargetingLocationInfo  StartLocation;                                     // 0x06E0(0x00B0)(BlueprintVisible, BlueprintReadOnly, Net, ContainsInstancedReference, ExposeOnSpawn, NativeAccessSpecifierPublic)
	uint8                                         Pad_790[0x30];                                     // 0x0790(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class APlayerController*                      PrimaryPC;                                         // 0x07C0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameplayAbility*                       OwningAbility;                                     // 0x07C8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDestroyOnConfirmation;                            // 0x07D0(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDestroyOnCancel;                                  // 0x07D1(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7D2[0x6];                                      // 0x07D2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 SourceActor;                                       // 0x07D8(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, RepNotify, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7E0[0x30];                                     // 0x07E0(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bDebug;                                            // 0x0810(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_811[0x7];                                      // 0x0811(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAbilitySystemComponent*                GenericDelegateBoundASC;                           // 0x0818(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_820[0xF0];                                     // 0x0820(0x00F0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CancelTargeting(int32 InputID);
	void ClientConfirmTargetingAndContinue();
	void ConfirmTargeting(int32 InputID);
	void OnRep_InitSourceActor();

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("GameplayAbilityTargetActor")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"GameplayAbilityTargetActor")
	}
	static class AGameplayAbilityTargetActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGameplayAbilityTargetActor>();
	}
};
DUMPER7_ASSERTS_AGameplayAbilityTargetActor;

// Class GameplayAbilities.GameplayAbilityTargetActor_Radius
// 0x0010 (0x0920 - 0x0910)
class AGameplayAbilityTargetActor_Radius final : public AGameplayAbilityTargetActor
{
public:
	float                                         Radius;                                            // 0x0910(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_914[0xC];                                      // 0x0914(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("GameplayAbilityTargetActor_Radius")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"GameplayAbilityTargetActor_Radius")
	}
	static class AGameplayAbilityTargetActor_Radius* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGameplayAbilityTargetActor_Radius>();
	}
};
DUMPER7_ASSERTS_AGameplayAbilityTargetActor_Radius;

// Class GameplayAbilities.AbilitySystemDebugHUD
// 0x0000 (0x07D0 - 0x07D0)
class AAbilitySystemDebugHUD final : public AHUD
{
public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("AbilitySystemDebugHUD")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"AbilitySystemDebugHUD")
	}
	static class AAbilitySystemDebugHUD* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAbilitySystemDebugHUD>();
	}
};
DUMPER7_ASSERTS_AAbilitySystemDebugHUD;

// Class GameplayAbilities.GameplayAbilityDataSet
// 0x0018 (0x0048 - 0x0030)
class UGameplayAbilityDataSet : public UObject
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Handle;                                            // 0x0038(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAbilitySystemComponent*                AbilitySystemComponent;                            // 0x0040(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("GameplayAbilityDataSet")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"GameplayAbilityDataSet")
	}
	static class UGameplayAbilityDataSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayAbilityDataSet>();
	}
};
DUMPER7_ASSERTS_UGameplayAbilityDataSet;

// Class GameplayAbilities.GameplayAbilityDataSet_Float
// 0x0008 (0x0050 - 0x0048)
class UGameplayAbilityDataSet_Float final : public UGameplayAbilityDataSet
{
public:
	float                                         Value;                                             // 0x0048(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetValue();
	void SetValue(const float& InValue);

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("GameplayAbilityDataSet_Float")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"GameplayAbilityDataSet_Float")
	}
	static class UGameplayAbilityDataSet_Float* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayAbilityDataSet_Float>();
	}
};
DUMPER7_ASSERTS_UGameplayAbilityDataSet_Float;

// Class GameplayAbilities.GameplayEffect
// 0x13E8 (0x1418 - 0x0030)
class UGameplayEffect : public UObject
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	EGameplayEffectDurationType                   DurationPolicy;                                    // 0x0038(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayEffectModifierMagnitude       DurationMagnitude;                                 // 0x0040(0x0300)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FScalableFloat                         Period;                                            // 0x0340(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bExecutePeriodicEffectOnApplication;               // 0x0378(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGameplayEffectPeriodInhibitionRemovedPolicy  PeriodicInhibitionPolicy;                          // 0x0379(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_37A[0x6];                                      // 0x037A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGameplayModifierInfo>          Modifiers;                                         // 0x0380(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         Pad_390[0x8];                                      // 0x0390(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGameplayEffectExecutionDefinition> Executions;                                    // 0x0398(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FScalableFloat                         ChanceToApplyToTarget;                             // 0x03A8(0x0038)(Deprecated, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UGameplayEffectCustomApplicationRequirement>> ApplicationRequirements;  // 0x03E0(0x0010)(ZeroConstructor, Deprecated, UObjectWrapper, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayEffectCustomStackRequirement> StackRequirements;                      // 0x03F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UGameplayEffect>>    TargetEffectClasses;                               // 0x03F8(0x0010)(ZeroConstructor, Deprecated, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<struct FConditionalGameplayEffect>     ConditionalGameplayEffects;                        // 0x0408(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UGameplayEffect>>    OverflowEffects;                                   // 0x0418(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	bool                                          bDenyOverflowApplication;                          // 0x0428(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bClearStackOnOverflow;                             // 0x0429(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42A[0x6];                                      // 0x042A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UGameplayEffect>>    PrematureExpirationEffectClasses;                  // 0x0430(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UGameplayEffect>>    RoutineExpirationEffectClasses;                    // 0x0440(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	bool                                          bModifierCleanAutoRemove;                          // 0x0450(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRequireModifierSuccessToTriggerCues;              // 0x0451(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSuppressStackingCues;                             // 0x0452(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_453[0x5];                                      // 0x0453(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGameplayEffectCue>             GameplayCues;                                      // 0x0458(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UGameplayEffectUIData*                  UIData;                                            // 0x0468(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, PersistentInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableCullDistance;                               // 0x0470(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_471[0x3];                                      // 0x0471(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         EffectPriority;                                    // 0x0474(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FInheritedTagContainer                 InheritableGameplayEffectTags;                     // 0x0478(0x0138)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FInheritedTagContainer                 InheritableOwnedTagsContainer;                     // 0x05B0(0x0138)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FInheritedTagContainer                 InheritableBlockedAbilityTagsContainer;            // 0x06E8(0x0138)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayTagRequirements               OngoingTagRequirements;                            // 0x0820(0x0118)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayTagRequirements               ApplicationTagRequirements;                        // 0x0938(0x0118)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayTagRequirements               RemovalTagRequirements;                            // 0x0A50(0x0118)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FInheritedTagContainer                 RemoveGameplayEffectsWithTags;                     // 0x0B68(0x0138)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  CancelAbilitiesWithTag;                            // 0x0CA0(0x0068)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  BlockAbilitiesWithTag;                             // 0x0D08(0x0068)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTagRequirements               GrantedApplicationImmunityTags;                    // 0x0D70(0x0118)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayEffectQuery                   GrantedApplicationImmunityQuery;                   // 0x0E88(0x0208)(BlueprintVisible, BlueprintReadOnly, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_1090[0x8];                                     // 0x1090(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayEffectQuery                   RemoveGameplayEffectQuery;                         // 0x1098(0x0208)(BlueprintVisible, BlueprintReadOnly, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_12A0[0x11];                                    // 0x12A0(0x0011)(Fixing Size After Last Property [ Dumper-7 ])
	EGameplayEffectStackingType                   StackingType;                                      // 0x12B1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Coexist;                                           // 0x12B2(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12B3[0x1];                                     // 0x12B3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         StackLimitCount;                                   // 0x12B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGameplayEffectStackingDurationPolicy         StackDurationRefreshPolicy;                        // 0x12B8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGameplayEffectStackingPeriodPolicy           StackPeriodResetPolicy;                            // 0x12B9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGameplayEffectStackingExpirationPolicy       StackExpirationPolicy;                             // 0x12BA(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12BB[0x5];                                     // 0x12BB(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGameplayAbilitySpecDef>        GrantedAbilities;                                  // 0x12C0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_12D0[0x138];                                   // 0x12D0(0x0138)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UGameplayEffectComponent*>       GEComponents;                                      // 0x1408(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("GameplayEffect")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"GameplayEffect")
	}
	static class UGameplayEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayEffect>();
	}
};
DUMPER7_ASSERTS_UGameplayEffect;

// Class GameplayAbilities.AbilityTask_Repeat
// 0x0048 (0x01E0 - 0x0198)
class UAbilityTask_Repeat final : public UAbilityTask
{
public:
	TMulticastInlineDelegate<void(int32 ActionNumber)> OnPerformAction;                              // 0x0198(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(int32 ActionNumber)> OnFinished;                                   // 0x01A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	int32                                         ActionPerformancesDesired;                         // 0x01B8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ActionCounter;                                     // 0x01BC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeBetweenActions;                                // 0x01C0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1C4[0x1C];                                     // 0x01C4(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAbilityTask_Repeat* RepeatAction(class UGameplayAbility* OwningAbility, float TimeBetweenActions_0, int32 TotalActionCount);

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("AbilityTask_Repeat")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"AbilityTask_Repeat")
	}
	static class UAbilityTask_Repeat* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityTask_Repeat>();
	}
};
DUMPER7_ASSERTS_UAbilityTask_Repeat;

// Class GameplayAbilities.MovieSceneGameplayCueTriggerSection
// 0x00F8 (0x0208 - 0x0110)
class UMovieSceneGameplayCueTriggerSection final : public UMovieSceneHookSection
{
public:
	struct FMovieSceneGameplayCueChannel          Channel;                                           // 0x0110(0x00F8)(AssetRegistrySearchable, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("MovieSceneGameplayCueTriggerSection")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"MovieSceneGameplayCueTriggerSection")
	}
	static class UMovieSceneGameplayCueTriggerSection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMovieSceneGameplayCueTriggerSection>();
	}
};
DUMPER7_ASSERTS_UMovieSceneGameplayCueTriggerSection;

// Class GameplayAbilities.GameplayEffectComponent
// 0x0000 (0x0030 - 0x0030)
class UGameplayEffectComponent : public UObject
{
public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("GameplayEffectComponent")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"GameplayEffectComponent")
	}
	static class UGameplayEffectComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayEffectComponent>();
	}
};
DUMPER7_ASSERTS_UGameplayEffectComponent;

// Class GameplayAbilities.BlockAbilityTagsGameplayEffectComponent
// 0x0138 (0x0168 - 0x0030)
class UBlockAbilityTagsGameplayEffectComponent final : public UGameplayEffectComponent
{
public:
	struct FInheritedTagContainer                 InheritableBlockedAbilityTagsContainer;            // 0x0030(0x0138)(Edit, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("BlockAbilityTagsGameplayEffectComponent")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"BlockAbilityTagsGameplayEffectComponent")
	}
	static class UBlockAbilityTagsGameplayEffectComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlockAbilityTagsGameplayEffectComponent>();
	}
};
DUMPER7_ASSERTS_UBlockAbilityTagsGameplayEffectComponent;

// Class GameplayAbilities.AbilitiesGameplayEffectComponent
// 0x0010 (0x0040 - 0x0030)
class UAbilitiesGameplayEffectComponent final : public UGameplayEffectComponent
{
public:
	TArray<struct FGameplayAbilitySpecConfig>     GrantAbilityConfigs;                               // 0x0030(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("AbilitiesGameplayEffectComponent")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"AbilitiesGameplayEffectComponent")
	}
	static class UAbilitiesGameplayEffectComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilitiesGameplayEffectComponent>();
	}
};
DUMPER7_ASSERTS_UAbilitiesGameplayEffectComponent;

// Class GameplayAbilities.AbilityReconnectRecoverInterface
// 0x0000 (0x0000 - 0x0000)
class IAbilityReconnectRecoverInterface final
{
public:
	struct FPredictionDynamicParamHandle MakeReconnectParam();
	void RecoverFromReconnectParam(const struct FPredictionDynamicParamHandle& InHandle);

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("AbilityReconnectRecoverInterface")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"AbilityReconnectRecoverInterface")
	}
	static class IAbilityReconnectRecoverInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IAbilityReconnectRecoverInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
DUMPER7_ASSERTS_IAbilityReconnectRecoverInterface;

// Class GameplayAbilities.AbilityTask_WaitAbilityActivate
// 0x0198 (0x0330 - 0x0198)
class UAbilityTask_WaitAbilityActivate final : public UAbilityTask
{
public:
	TMulticastInlineDelegate<void(class UGameplayAbility* ActivatedAbility)> OnActivate;             // 0x0198(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FGameplayTag                           WithTag;                                           // 0x01A8(0x000C)(Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           WithoutTag;                                        // 0x01B4(0x000C)(Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IncludeTriggeredAbilities;                         // 0x01C0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          TriggerOnce;                                       // 0x01C1(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C2[0x6];                                      // 0x01C2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagRequirements               TagRequirements;                                   // 0x01C8(0x0118)(Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E0[0x50];                                     // 0x02E0(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAbilityTask_WaitAbilityActivate* WaitForAbilityActivate(class UGameplayAbility* OwningAbility, const struct FGameplayTag& WithTag_0, const struct FGameplayTag& WithoutTag_0, bool IncludeTriggeredAbilities_0, bool TriggerOnce_0);
	static class UAbilityTask_WaitAbilityActivate* WaitForAbilityActivate_Query(class UGameplayAbility* OwningAbility, const struct FGameplayTagQuery& Query, bool IncludeTriggeredAbilities_0, bool TriggerOnce_0);
	static class UAbilityTask_WaitAbilityActivate* WaitForAbilityActivateWithTagRequirements(class UGameplayAbility* OwningAbility, const struct FGameplayTagRequirements& TagRequirements_0, bool IncludeTriggeredAbilities_0, bool TriggerOnce_0);

	void OnAbilityActivate(class UGameplayAbility* ActivatedAbility);

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("AbilityTask_WaitAbilityActivate")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"AbilityTask_WaitAbilityActivate")
	}
	static class UAbilityTask_WaitAbilityActivate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityTask_WaitAbilityActivate>();
	}
};
DUMPER7_ASSERTS_UAbilityTask_WaitAbilityActivate;

// Class GameplayAbilities.AbilityTask_MoveLogicSync
// 0x00B8 (0x0250 - 0x0198)
class UAbilityTask_MoveLogicSync final : public UAbilityTask
{
public:
	uint8                                         Pad_198[0x8];                                      // 0x0198(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPredictionKey                         SyncKey;                                           // 0x01A0(0x0070)(Transient, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_210[0x8];                                      // 0x0210(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UCharacterMovementComponent*            OwnerMovement;                                     // 0x0218(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_220[0x30];                                     // 0x0220(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAbilityTask_MoveLogicSync* RegisterSyncTask(class UGameplayAbility* OwningAbility, const struct FPredictionKey& InSyncKey, bool bInSoftPrediction, bool bInInstant, bool bServerInitiated);

	void BindOnReject(class UObject* InObject, const class FName& InFunctionName);
	void BindOnReplay(class UObject* InObject, const class FName& InFunctionName);
	void BindOnSuccess(class UObject* InObject, const class FName& InFunctionName);

	int32 GetDebugIndex() const;
	class FString GetKeyDebugString() const;
	class FString GetKeyFlagsString() const;
	int64 GetRealRegisterTimeStamp() const;
	float GetRegisterTimeStamp() const;

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("AbilityTask_MoveLogicSync")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"AbilityTask_MoveLogicSync")
	}
	static class UAbilityTask_MoveLogicSync* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityTask_MoveLogicSync>();
	}
};
DUMPER7_ASSERTS_UAbilityTask_MoveLogicSync;

// Class GameplayAbilities.GameplayAbilityDataSet_Bool
// 0x0008 (0x0050 - 0x0048)
class UGameplayAbilityDataSet_Bool final : public UGameplayAbilityDataSet
{
public:
	bool                                          Value;                                             // 0x0048(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool GetValue();
	void SetValue(const bool& InValue);

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("GameplayAbilityDataSet_Bool")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"GameplayAbilityDataSet_Bool")
	}
	static class UGameplayAbilityDataSet_Bool* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayAbilityDataSet_Bool>();
	}
};
DUMPER7_ASSERTS_UGameplayAbilityDataSet_Bool;

// Class GameplayAbilities.AbilityTimelineComponent
// 0x00F0 (0x0320 - 0x0230)
class UAbilityTimelineComponent : public UAnimTimelineComponent
{
public:
	uint8                                         Pad_230[0xF0];                                     // 0x0230(0x00F0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void SetEnablePreCreateKey(bool bEnable);

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("AbilityTimelineComponent")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"AbilityTimelineComponent")
	}
	static class UAbilityTimelineComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityTimelineComponent>();
	}
};
DUMPER7_ASSERTS_UAbilityTimelineComponent;

// Class GameplayAbilities.AbilityTask_NetworkSyncPoint
// 0x0048 (0x01E0 - 0x0198)
class UAbilityTask_NetworkSyncPoint : public UAbilityTask
{
public:
	TMulticastInlineDelegate<void()>              OnHanging;                                         // 0x0198(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnAdvanced;                                        // 0x01A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnSync;                                            // 0x01B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FGameplayAbilityTargetDataHandle& Data)> OnSyncWithData; // 0x01C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	EAbilityTaskNetSyncType                       SyncType;                                          // 0x01D8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bWithData;                                         // 0x01D9(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1DA[0x6];                                      // 0x01DA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAbilityTask_NetworkSyncPoint* WaitNetSync(class UGameplayAbility* OwningAbility, EAbilityTaskNetSyncType SyncType_0);

	void OnSignalCallback();
	void OnSignalCallbackWithData(const struct FGameplayAbilityTargetDataHandle& Data);

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("AbilityTask_NetworkSyncPoint")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"AbilityTask_NetworkSyncPoint")
	}
	static class UAbilityTask_NetworkSyncPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityTask_NetworkSyncPoint>();
	}
};
DUMPER7_ASSERTS_UAbilityTask_NetworkSyncPoint;

// Class GameplayAbilities.GameplayModMagnitudeDiffusion
// 0x0000 (0x0030 - 0x0030)
class UGameplayModMagnitudeDiffusion : public UObject
{
public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("GameplayModMagnitudeDiffusion")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"GameplayModMagnitudeDiffusion")
	}
	static class UGameplayModMagnitudeDiffusion* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayModMagnitudeDiffusion>();
	}
};
DUMPER7_ASSERTS_UGameplayModMagnitudeDiffusion;

// Class GameplayAbilities.AdditionalEffectsGameplayEffectComponent
// 0x0048 (0x0078 - 0x0030)
class UAdditionalEffectsGameplayEffectComponent final : public UGameplayEffectComponent
{
public:
	bool                                          bOnApplicationCopyDataFromOriginalSpec;            // 0x0030(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FConditionalGameplayEffect>     OnApplicationGameplayEffects;                      // 0x0038(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UGameplayEffect>>    OnCompleteAlways;                                  // 0x0048(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UGameplayEffect>>    OnCompleteNormal;                                  // 0x0058(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UGameplayEffect>>    OnCompletePrematurely;                             // 0x0068(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("AdditionalEffectsGameplayEffectComponent")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"AdditionalEffectsGameplayEffectComponent")
	}
	static class UAdditionalEffectsGameplayEffectComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAdditionalEffectsGameplayEffectComponent>();
	}
};
DUMPER7_ASSERTS_UAdditionalEffectsGameplayEffectComponent;

// Class GameplayAbilities.AssetTagsGameplayEffectComponent
// 0x0138 (0x0168 - 0x0030)
class UAssetTagsGameplayEffectComponent final : public UGameplayEffectComponent
{
public:
	struct FInheritedTagContainer                 InheritableAssetTags;                              // 0x0030(0x0138)(Edit, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("AssetTagsGameplayEffectComponent")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"AssetTagsGameplayEffectComponent")
	}
	static class UAssetTagsGameplayEffectComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAssetTagsGameplayEffectComponent>();
	}
};
DUMPER7_ASSERTS_UAssetTagsGameplayEffectComponent;

// Class GameplayAbilities.ChanceToApplyGameplayEffectComponent
// 0x0038 (0x0068 - 0x0030)
class UChanceToApplyGameplayEffectComponent : public UGameplayEffectComponent
{
public:
	struct FScalableFloat                         ChanceToApplyToTarget;                             // 0x0030(0x0038)(Edit, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("ChanceToApplyGameplayEffectComponent")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"ChanceToApplyGameplayEffectComponent")
	}
	static class UChanceToApplyGameplayEffectComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChanceToApplyGameplayEffectComponent>();
	}
};
DUMPER7_ASSERTS_UChanceToApplyGameplayEffectComponent;

// Class GameplayAbilities.CustomCanApplyGameplayEffectComponent
// 0x0010 (0x0040 - 0x0030)
class UCustomCanApplyGameplayEffectComponent final : public UGameplayEffectComponent
{
public:
	TArray<TSubclassOf<class UGameplayEffectCustomApplicationRequirement>> ApplicationRequirements;  // 0x0030(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("CustomCanApplyGameplayEffectComponent")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"CustomCanApplyGameplayEffectComponent")
	}
	static class UCustomCanApplyGameplayEffectComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomCanApplyGameplayEffectComponent>();
	}
};
DUMPER7_ASSERTS_UCustomCanApplyGameplayEffectComponent;

// Class GameplayAbilities.GameplayAbilityDataSet_Int
// 0x0008 (0x0050 - 0x0048)
class UGameplayAbilityDataSet_Int final : public UGameplayAbilityDataSet
{
public:
	int32                                         Value;                                             // 0x0048(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 GetValue();
	void SetValue(const int32& InValue);

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("GameplayAbilityDataSet_Int")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"GameplayAbilityDataSet_Int")
	}
	static class UGameplayAbilityDataSet_Int* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayAbilityDataSet_Int>();
	}
};
DUMPER7_ASSERTS_UGameplayAbilityDataSet_Int;

// Class GameplayAbilities.GameplayAbilityDataSet_Vector
// 0x0018 (0x0060 - 0x0048)
class UGameplayAbilityDataSet_Vector final : public UGameplayAbilityDataSet
{
public:
	struct FVector                                Value;                                             // 0x0048(0x0018)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	struct FVector GetValue();
	void SetValue(const struct FVector& InValue);

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("GameplayAbilityDataSet_Vector")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"GameplayAbilityDataSet_Vector")
	}
	static class UGameplayAbilityDataSet_Vector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayAbilityDataSet_Vector>();
	}
};
DUMPER7_ASSERTS_UGameplayAbilityDataSet_Vector;

// Class GameplayAbilities.GameplayAbilityDataSet_String
// 0x0010 (0x0058 - 0x0048)
class UGameplayAbilityDataSet_String final : public UGameplayAbilityDataSet
{
public:
	class FString                                 Value;                                             // 0x0048(0x0010)(Net, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	class FString GetValue();
	void SetValue(const class FString& InValue);

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("GameplayAbilityDataSet_String")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"GameplayAbilityDataSet_String")
	}
	static class UGameplayAbilityDataSet_String* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayAbilityDataSet_String>();
	}
};
DUMPER7_ASSERTS_UGameplayAbilityDataSet_String;

// Class GameplayAbilities.GameplayAbilityDataSet_Map
// 0x0010 (0x0058 - 0x0048)
class UGameplayAbilityDataSet_Map final : public UGameplayAbilityDataSet
{
public:
	TArray<struct FAbilityDataSetDataPair>        DataPairs;                                         // 0x0048(0x0010)(Net, ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	bool Contains(const class FName& KeyName);
	bool GetBoolValue(const class FName& KeyName, bool DefaultValue);
	float GetFloatValue(const class FName& KeyName, float DefaultValue);
	int32 GetIntValue(const class FName& KeyName, int32 DefaultValue);
	class FString GetStringValue(const class FName& KeyName, const class FString& DefaultValue);
	struct FVector GetVectorValue(const class FName& KeyName, const struct FVector& DefaultValue);
	void SetBoolValue(const class FName& KeyName, bool Value);
	void SetFloatValue(const class FName& KeyName, float Value);
	void SetIntValue(const class FName& KeyName, int32 Value);
	void SetStringValue(const class FName& KeyName, const class FString& Value);
	void SetVectorValue(const class FName& KeyName, const struct FVector& Value);

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("GameplayAbilityDataSet_Map")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"GameplayAbilityDataSet_Map")
	}
	static class UGameplayAbilityDataSet_Map* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayAbilityDataSet_Map>();
	}
};
DUMPER7_ASSERTS_UGameplayAbilityDataSet_Map;

// Class GameplayAbilities.GameplayAttributeGlobals
// 0x0038 (0x0068 - 0x0030)
class UGameplayAttributeGlobals : public UObject
{
public:
	struct FSoftClassPath                         GameplayAttributeGlobalsClassName;                 // 0x0030(0x0028)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_58[0x10];                                      // 0x0058(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("GameplayAttributeGlobals")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"GameplayAttributeGlobals")
	}
	static class UGameplayAttributeGlobals* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayAttributeGlobals>();
	}
};
DUMPER7_ASSERTS_UGameplayAttributeGlobals;

// Class GameplayAbilities.GameplayEffectCustomStackRequirement
// 0x0000 (0x0030 - 0x0030)
class UGameplayEffectCustomStackRequirement final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("GameplayEffectCustomStackRequirement")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"GameplayEffectCustomStackRequirement")
	}
	static class UGameplayEffectCustomStackRequirement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayEffectCustomStackRequirement>();
	}
};
DUMPER7_ASSERTS_UGameplayEffectCustomStackRequirement;

// Class GameplayAbilities.GameplayEffectUIData
// 0x0000 (0x0030 - 0x0030)
class UGameplayEffectUIData : public UGameplayEffectComponent
{
public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("GameplayEffectUIData")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"GameplayEffectUIData")
	}
	static class UGameplayEffectUIData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayEffectUIData>();
	}
};
DUMPER7_ASSERTS_UGameplayEffectUIData;

// Class GameplayAbilities.GameplayEffectUIData_TextOnly
// 0x0018 (0x0048 - 0x0030)
class UGameplayEffectUIData_TextOnly final : public UGameplayEffectUIData
{
public:
	class FText                                   Description;                                       // 0x0030(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("GameplayEffectUIData_TextOnly")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"GameplayEffectUIData_TextOnly")
	}
	static class UGameplayEffectUIData_TextOnly* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayEffectUIData_TextOnly>();
	}
};
DUMPER7_ASSERTS_UGameplayEffectUIData_TextOnly;

// Class GameplayAbilities.ImmunityGameplayEffectComponent
// 0x0010 (0x0040 - 0x0030)
class UImmunityGameplayEffectComponent final : public UGameplayEffectComponent
{
public:
	TArray<struct FGameplayEffectQuery>           ImmunityQueries;                                   // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("ImmunityGameplayEffectComponent")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"ImmunityGameplayEffectComponent")
	}
	static class UImmunityGameplayEffectComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UImmunityGameplayEffectComponent>();
	}
};
DUMPER7_ASSERTS_UImmunityGameplayEffectComponent;

// Class GameplayAbilities.PoolFunctionLibrary
// 0x0000 (0x0030 - 0x0030)
class UPoolFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("PoolFunctionLibrary")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"PoolFunctionLibrary")
	}
	static class UPoolFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPoolFunctionLibrary>();
	}
};
DUMPER7_ASSERTS_UPoolFunctionLibrary;

// Class GameplayAbilities.PredictionFuncLibrary
// 0x0000 (0x0030 - 0x0030)
class UPredictionFuncLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool GetReplicatedData_ArrayHit(const struct FPredictionDynamicParamHandle& InHandle, TArray<struct FHitResult>* OutData);
	static bool GetReplicatedData_ArrayInt(const struct FPredictionDynamicParamHandle& InHandle, TArray<int32>* OutData);
	static bool GetReplicatedData_ArrayObject(const struct FPredictionDynamicParamHandle& InHandle, TArray<class UObject*>* OutData);
	static bool GetReplicatedData_Empty(const struct FPredictionDynamicParamHandle& InHandle, class UObject** OutData);
	static bool GetReplicatedData_Float(const struct FPredictionDynamicParamHandle& InHandle, float* OutData);
	static bool GetReplicatedData_Hit(const struct FPredictionDynamicParamHandle& InHandle, struct FHitResult* OutData);
	static bool GetReplicatedData_Int(const struct FPredictionDynamicParamHandle& InHandle, int32* OutData);
	static bool GetReplicatedData_PredictionKey(const struct FPredictionDynamicParamHandle& InHandle, struct FPredictionKey* OutData);
	static bool GetReplicatedData_Vector(const struct FPredictionDynamicParamHandle& InHandle, struct FVector* OutData);
	static struct FPredictionDynamicParamHandle MakeReplicatedData_ArrayHit(const TArray<struct FHitResult>& InParam);
	static struct FPredictionDynamicParamHandle MakeReplicatedData_ArrayInt(const TArray<int32>& InParam);
	static struct FPredictionDynamicParamHandle MakeReplicatedData_ArrayObject(const TArray<class UObject*>& InParam);
	static struct FPredictionDynamicParamHandle MakeReplicatedData_Empty(class UObject* InParam);
	static struct FPredictionDynamicParamHandle MakeReplicatedData_Float(float InParam);
	static struct FPredictionDynamicParamHandle MakeReplicatedData_Hit(const struct FHitResult& InParam);
	static struct FPredictionDynamicParamHandle MakeReplicatedData_Int(int32 InParam);
	static struct FPredictionDynamicParamHandle MakeReplicatedData_PredictionKey(const struct FPredictionKey& InParam);
	static struct FPredictionDynamicParamHandle MakeReplicatedData_Vector(const struct FVector& InParam);

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("PredictionFuncLibrary")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"PredictionFuncLibrary")
	}
	static class UPredictionFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPredictionFuncLibrary>();
	}
};
DUMPER7_ASSERTS_UPredictionFuncLibrary;

// Class GameplayAbilities.RemoveOtherGameplayEffectComponent
// 0x0010 (0x0040 - 0x0030)
class URemoveOtherGameplayEffectComponent final : public UGameplayEffectComponent
{
public:
	TArray<struct FGameplayEffectQuery>           RemoveGameplayEffectQueries;                       // 0x0030(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("RemoveOtherGameplayEffectComponent")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"RemoveOtherGameplayEffectComponent")
	}
	static class URemoveOtherGameplayEffectComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URemoveOtherGameplayEffectComponent>();
	}
};
DUMPER7_ASSERTS_URemoveOtherGameplayEffectComponent;

// Class GameplayAbilities.TargetTagRequirementsGameplayEffectComponent
// 0x0348 (0x0378 - 0x0030)
class UTargetTagRequirementsGameplayEffectComponent final : public UGameplayEffectComponent
{
public:
	struct FGameplayTagRequirements               ApplicationTagRequirements;                        // 0x0030(0x0118)(Edit, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTagRequirements               OngoingTagRequirements;                            // 0x0148(0x0118)(Edit, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTagRequirements               RemovalTagRequirements;                            // 0x0260(0x0118)(Edit, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("TargetTagRequirementsGameplayEffectComponent")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"TargetTagRequirementsGameplayEffectComponent")
	}
	static class UTargetTagRequirementsGameplayEffectComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTargetTagRequirementsGameplayEffectComponent>();
	}
};
DUMPER7_ASSERTS_UTargetTagRequirementsGameplayEffectComponent;

// Class GameplayAbilities.TargetTagsGameplayEffectComponent
// 0x0138 (0x0168 - 0x0030)
class UTargetTagsGameplayEffectComponent final : public UGameplayEffectComponent
{
public:
	struct FInheritedTagContainer                 InheritableGrantedTagsContainer;                   // 0x0030(0x0138)(Edit, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("TargetTagsGameplayEffectComponent")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"TargetTagsGameplayEffectComponent")
	}
	static class UTargetTagsGameplayEffectComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTargetTagsGameplayEffectComponent>();
	}
};
DUMPER7_ASSERTS_UTargetTagsGameplayEffectComponent;

// Class GameplayAbilities.AbilityAsync
// 0x0008 (0x0040 - 0x0038)
class UAbilityAsync : public UCancellableAsyncAction
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EndAction();

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("AbilityAsync")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"AbilityAsync")
	}
	static class UAbilityAsync* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityAsync>();
	}
};
DUMPER7_ASSERTS_UAbilityAsync;

// Class GameplayAbilities.AbilityAsync_WaitAttributeChanged
// 0x0060 (0x00A0 - 0x0040)
class UAbilityAsync_WaitAttributeChanged final : public UAbilityAsync
{
public:
	TMulticastInlineDelegate<void(const struct FGameplayAttribute& Attribute, float NewValue, float OldValue)> Changed; // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x50];                                      // 0x0050(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAbilityAsync_WaitAttributeChanged* WaitForAttributeChanged(class AActor* TargetActor, const struct FGameplayAttribute& Attribute, bool OnlyTriggerOnce);

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("AbilityAsync_WaitAttributeChanged")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"AbilityAsync_WaitAttributeChanged")
	}
	static class UAbilityAsync_WaitAttributeChanged* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityAsync_WaitAttributeChanged>();
	}
};
DUMPER7_ASSERTS_UAbilityAsync_WaitAttributeChanged;

// Class GameplayAbilities.AbilityAsync_WaitGameplayEffectApplied
// 0x0270 (0x02B0 - 0x0040)
class UAbilityAsync_WaitGameplayEffectApplied final : public UAbilityAsync
{
public:
	TMulticastInlineDelegate<void(class AActor* Source, const struct FGameplayEffectSpecHandle& SpecHandle, const struct FActiveGameplayEffectHandle& ActiveHandle)> OnApplied; // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x260];                                     // 0x0050(0x0260)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAbilityAsync_WaitGameplayEffectApplied* WaitGameplayEffectAppliedToActor(class AActor* TargetActor, const struct FGameplayTargetDataFilterHandle& SourceFilter, const struct FGameplayTagRequirements& SourceTagRequirements, const struct FGameplayTagRequirements& TargetTagRequirements, bool TriggerOnce, bool ListenForPeriodicEffect);

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("AbilityAsync_WaitGameplayEffectApplied")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"AbilityAsync_WaitGameplayEffectApplied")
	}
	static class UAbilityAsync_WaitGameplayEffectApplied* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityAsync_WaitGameplayEffectApplied>();
	}
};
DUMPER7_ASSERTS_UAbilityAsync_WaitGameplayEffectApplied;

// Class GameplayAbilities.AbilityAsync_WaitGameplayEvent
// 0x0028 (0x0068 - 0x0040)
class UAbilityAsync_WaitGameplayEvent final : public UAbilityAsync
{
public:
	TMulticastInlineDelegate<void(const struct FGameplayEventData& Payload)> EventReceived;          // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x18];                                      // 0x0050(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAbilityAsync_WaitGameplayEvent* WaitGameplayEventToActor(class AActor* TargetActor, const struct FGameplayTag& EventTag, bool OnlyTriggerOnce, bool OnlyMatchExact);

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("AbilityAsync_WaitGameplayEvent")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"AbilityAsync_WaitGameplayEvent")
	}
	static class UAbilityAsync_WaitGameplayEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityAsync_WaitGameplayEvent>();
	}
};
DUMPER7_ASSERTS_UAbilityAsync_WaitGameplayEvent;

// Class GameplayAbilities.AbilityAsync_WaitGameplayTag
// 0x0020 (0x0060 - 0x0040)
class UAbilityAsync_WaitGameplayTag : public UAbilityAsync
{
public:
	uint8                                         Pad_40[0x20];                                      // 0x0040(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("AbilityAsync_WaitGameplayTag")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"AbilityAsync_WaitGameplayTag")
	}
	static class UAbilityAsync_WaitGameplayTag* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityAsync_WaitGameplayTag>();
	}
};
DUMPER7_ASSERTS_UAbilityAsync_WaitGameplayTag;

// Class GameplayAbilities.AbilityAsync_WaitGameplayTagAdded
// 0x0010 (0x0070 - 0x0060)
class UAbilityAsync_WaitGameplayTagAdded final : public UAbilityAsync_WaitGameplayTag
{
public:
	TMulticastInlineDelegate<void()>              Added;                                             // 0x0060(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UAbilityAsync_WaitGameplayTagAdded* WaitGameplayTagAddToActor(class AActor* TargetActor, const struct FGameplayTag& Tag, bool OnlyTriggerOnce);

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("AbilityAsync_WaitGameplayTagAdded")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"AbilityAsync_WaitGameplayTagAdded")
	}
	static class UAbilityAsync_WaitGameplayTagAdded* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityAsync_WaitGameplayTagAdded>();
	}
};
DUMPER7_ASSERTS_UAbilityAsync_WaitGameplayTagAdded;

// Class GameplayAbilities.AbilityAsync_WaitGameplayTagRemoved
// 0x0010 (0x0070 - 0x0060)
class UAbilityAsync_WaitGameplayTagRemoved final : public UAbilityAsync_WaitGameplayTag
{
public:
	TMulticastInlineDelegate<void()>              Removed;                                           // 0x0060(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UAbilityAsync_WaitGameplayTagRemoved* WaitGameplayTagRemoveFromActor(class AActor* TargetActor, const struct FGameplayTag& Tag, bool OnlyTriggerOnce);

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("AbilityAsync_WaitGameplayTagRemoved")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"AbilityAsync_WaitGameplayTagRemoved")
	}
	static class UAbilityAsync_WaitGameplayTagRemoved* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityAsync_WaitGameplayTagRemoved>();
	}
};
DUMPER7_ASSERTS_UAbilityAsync_WaitGameplayTagRemoved;

// Class GameplayAbilities.AbilityAsync_WaitGameplayTagQuery
// 0x0118 (0x0158 - 0x0040)
class UAbilityAsync_WaitGameplayTagQuery final : public UAbilityAsync
{
public:
	uint8                                         Pad_40[0x108];                                     // 0x0040(0x0108)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              Triggered;                                         // 0x0148(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)

public:
	static class UAbilityAsync_WaitGameplayTagQuery* WaitGameplayTagQueryOnActor(class AActor* TargetActor, const struct FGameplayTagQuery& TagQuery, const EWaitGameplayTagQueryTriggerCondition TriggerCondition, const bool bOnlyTriggerOnce);

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("AbilityAsync_WaitGameplayTagQuery")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"AbilityAsync_WaitGameplayTagQuery")
	}
	static class UAbilityAsync_WaitGameplayTagQuery* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityAsync_WaitGameplayTagQuery>();
	}
};
DUMPER7_ASSERTS_UAbilityAsync_WaitGameplayTagQuery;

// Class GameplayAbilities.GameplayAbility
// 0x0EE0 (0x0F10 - 0x0030)
class UGameplayAbility : public UObject
{
public:
	uint8                                         Pad_30[0x240];                                     // 0x0030(0x0240)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  AbilityTags;                                       // 0x0270(0x0068)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  AbilityLabels;                                     // 0x02D8(0x0068)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bReplicateInputDirectly;                           // 0x0340(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RemoteInstanceEnded;                               // 0x0341(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_342[0x6];                                      // 0x0342(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, class AActor*>                    RemoteActorMap;                                    // 0x0348(0x0050)(NativeAccessSpecifierPublic)
	uint8                                         Pad_398[0x4];                                      // 0x0398(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	EGameplayAbilityReplicationPolicy             ReplicationPolicy;                                 // 0x039C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EGameplayAbilityInstancingPolicy              InstancingPolicy;                                  // 0x039D(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bServerRespectsRemoteAbilityCancellation;          // 0x039E(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRetriggerInstancedAbility;                        // 0x039F(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxForceEndByRemoteTime_Server;                    // 0x03A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinForceEndByRemoteTime_Server;                    // 0x03A4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayAbilityActivationInfo         CurrentActivationInfo;                             // 0x03A8(0x01D8)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FGameplayEventData                     CurrentEventData;                                  // 0x0580(0x0290)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	EGameplayAbilityNetExecutionPolicy            NetExecutionPolicy;                                // 0x0810(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableActivationBuffer;                           // 0x0811(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bKeepKeyExpiredImmediatelyWhenEndAbility;          // 0x0812(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EGameplayAbilityNetSecurityPolicy             NetSecurityPolicy;                                 // 0x0813(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CancelAllowedPolicy;                               // 0x0814(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UGameplayEffect>            CostGameplayEffectClass;                           // 0x0818(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FAbilityTriggerData>            AbilityTriggers;                                   // 0x0820(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UGameplayEffect>            CooldownGameplayEffectClass;                       // 0x0830(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  CancelAbilitiesWithTag;                            // 0x0838(0x0068)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  BlockAbilitiesWithTag;                             // 0x08A0(0x0068)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  ActivationOwnedTags;                               // 0x0908(0x0068)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  ActivationRequiredTags;                            // 0x0970(0x0068)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  ActivationBlockedTags;                             // 0x09D8(0x0068)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  ActivationRequiredAnyTags;                         // 0x0A40(0x0068)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  SourceRequiredTags;                                // 0x0AA8(0x0068)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  SourceBlockedTags;                                 // 0x0B10(0x0068)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  TargetRequiredTags;                                // 0x0B78(0x0068)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  TargetBlockedTags;                                 // 0x0BE0(0x0068)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_C48[0x20];                                     // 0x0C48(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UGameplayTask*>                  ActiveTasks;                                       // 0x0C68(0x0010)(ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_C78[0x10];                                     // 0x0C78(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           CurrentMontage;                                    // 0x0C88(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C90[0x60];                                     // 0x0C90(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsActive;                                         // 0x0CF0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsAbilityEnding;                                  // 0x0CF1(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsCancelable;                                     // 0x0CF2(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsAbilityCancelling;                              // 0x0CF3(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsBlockingOtherAbilities;                         // 0x0CF4(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_CF5[0x13];                                     // 0x0CF5(0x0013)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bMarkPendingKillOnAbilityEnd;                      // 0x0D08(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D09[0x77];                                     // 0x0D09(0x0077)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagQuery                      SlackActivationRequiredTags;                       // 0x0D80(0x0048)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         SlackTagTime;                                      // 0x0DC8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DCC[0x64];                                     // 0x0DCC(0x0064)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          IsImportantLog;                                    // 0x0E30(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsCallingActive;                                  // 0x0E31(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseAdvanceReconnectMode;                          // 0x0E32(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAbilityReconnectMode                         ReconnectMode;                                     // 0x0E33(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAbilityReconnectMode                         ReconnectMode_AfterReadyCommit;                    // 0x0E34(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoRecoverAbility;                               // 0x0E35(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReconnectModeOnlyPause;                           // 0x0E36(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsReconnectKeepActivating;                        // 0x0E37(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E38[0xD8];                                     // 0x0E38(0x00D8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void SetGlobalEnableReconnectMode(bool bEnable);

	void AddAbilityOperationTag(const struct FGameplayTag& InTag);
	void AddDynamicDataForActive(const struct FPredictionDynamicParamHandle& InDataHandle);
	void AddDynamicDataForEnd(const struct FPredictionDynamicParamHandle& InDataHandle);
	void AddReconnectParam(const class FName& InName, const struct FPredictionDynamicParamHandle& InDataHandle);
	void BothTimelineAndMontageJumpToSection(class FName SectionName);
	struct FActiveGameplayEffectHandle BP_ApplyGameplayEffectToOwner(TSubclassOf<class UGameplayEffect> GameplayEffectClass, int32 GameplayEffectLevel, int32 Stacks);
	TArray<struct FActiveGameplayEffectHandle> BP_ApplyGameplayEffectToTarget(const struct FGameplayAbilityTargetDataHandle& TargetData, TSubclassOf<class UGameplayEffect> GameplayEffectClass, int32 GameplayEffectLevel, int32 Stacks);
	void BP_RemoveGameplayEffectFromOwnerWithAssetTags(const struct FGameplayTagContainer& WithAssetTags, int32 StacksToRemove);
	void BP_RemoveGameplayEffectFromOwnerWithGrantedTags(const struct FGameplayTagContainer& WithGrantedTags, int32 StacksToRemove);
	void BP_RemoveGameplayEffectFromOwnerWithHandle(const struct FActiveGameplayEffectHandle& Handle, int32 StacksToRemove);
	void CancelTaskByInstanceName(class FName InstanceName);
	bool CanKeepInActivateBuffer(const class FString& ActivateKey, const struct FGameplayTagContainer& FailureTags);
	void ConfirmTaskByInstanceName(class FName InstanceName, bool bEndTask);
	void CurrentTimelineJumpToSection(class FName SectionName);
	void EndAbilityState(class FName OptionalStateNameToEnd);
	void EndTaskByInstanceName(class FName InstanceName);
	TArray<class FString> GetCustomActivationDependentKeys();
	struct FPredictionDynamicParamHandle GetDynamicDataForActive(int32 Index_0);
	struct FPredictionDynamicParamHandle GetDynamicDataForEnd(int32 Index_0);
	bool GetReconnectParam(const class FName& InName, struct FPredictionDynamicParamHandle* OutDataHandle);
	class UGameplayAbility* GetSourceAbility();
	void K2_ActivateAbility();
	void K2_ActivateAbilityFromEvent(const struct FGameplayEventData& EventData);
	void K2_AddGameplayCue(const struct FGameplayTag& GameplayCueTag, const struct FGameplayEffectContextHandle& Context, bool bRemoveOnAbilityEnd);
	void K2_AddGameplayCueWithParams(const struct FGameplayTag& GameplayCueTag, const struct FGameplayCueParameters& GameplayCueParameter, bool bRemoveOnAbilityEnd);
	struct FActiveGameplayEffectHandle K2_ApplyGameplayEffectSpecToOwner(const struct FGameplayEffectSpecHandle& EffectSpecHandle);
	TArray<struct FActiveGameplayEffectHandle> K2_ApplyGameplayEffectSpecToTarget(const struct FGameplayEffectSpecHandle& EffectSpecHandle, const struct FGameplayAbilityTargetDataHandle& TargetData);
	void K2_CancelAbility(EAbilityEndReason EndReason);
	bool K2_CheckAbilityCooldown();
	bool K2_CheckAbilityCost();
	bool K2_CommitAbility();
	bool K2_CommitAbilityCooldown(bool BroadcastCommitEvent, bool ForceCooldown);
	bool K2_CommitAbilityCost(bool BroadcastCommitEvent);
	void K2_CommitExecute();
	void K2_EndAbility(EAbilityEndReason EndReason);
	void K2_EndAbilityLocally(EAbilityEndReason EndReason);
	void K2_ExecuteGameplayCue(const struct FGameplayTag& GameplayCueTag, const struct FGameplayEffectContextHandle& Context);
	void K2_ExecuteGameplayCueWithParams(const struct FGameplayTag& GameplayCueTag, const struct FGameplayCueParameters& GameplayCueParameters);
	void K2_OnClientActivateAbilityRejected(bool bIsCurrentActivation);
	void K2_OnEndAbility(bool bWasCancelled);
	void K2_RemoveGameplayCue(const struct FGameplayTag& GameplayCueTag);
	struct FGameplayAbilityTargetingLocationInfo MakeTargetLocationInfoFromOwnerActor();
	struct FGameplayAbilityTargetingLocationInfo MakeTargetLocationInfoFromOwnerSkeletalMeshComponent(class FName SocketName);
	void MontageJumpToSection_ThreadSafe(class FName SectionName);
	void MontageSetNextSectionName(class FName FromSectionName, class FName ToSectionName);
	void MontageStop(float OverrideBlendOutTime);
	void OnKeepActiveAbility();
	void OnServerActivateAbilityRejected(const struct FGameplayTagContainer& FailureTags);
	void OnSetKeepActiveParams();
	void OnSlackLogicMissing(class FName Identifier, float SlackTime);
	void OnSlackLogicSatisfy(class FName Identifier);
	void OnSlackTagUpdate(const struct FGameplayTag& Tag, bool bExist);
	void PreCallRemoteActivateAbility();
	void PreCallRemoteEndAbility(bool bWasCancelled, EAbilityEndReason EndReason);
	void RemoveGrantedByEffect();
	void SendGameplayEvent(const struct FGameplayTag& EventTag, const struct FGameplayEventData& Payload);
	void SetCanBeCanceled(bool bCanBeCanceled);
	void SetCancelAllowedPolicy(int32 InPolicy);
	void SetCancelAllowedPolicyDirect(EGACancelType InPolicy);
	void SetShouldBlockOtherAbilities(bool bShouldBlockAbilities);
	void TimelineJumpToSection(class UAnimTimeline* InTimeline, class FName SectionName);
	bool TryMakeTriggerContext(struct FGameplayEventData& EventData);
	void TrySetRemoteEndImmediately(bool bEndQuickly);

	bool AbilityHasTagExact(const struct FGameplayTag& InTag) const;
	class UGameplayAbilityDataSet* GetAbilityDataSet() const;
	EAbilityEndReason GetAbilityEndReason() const;
	int32 GetAbilityLevel() const;
	int32 GetAbilityLevel_BP(const struct FGameplayAbilitySpecHandle& Handle, const struct FGameplayAbilityActorInfo& ActorInfo) const;
	struct FGameplayTagContainer GetAbilityOperationTags() const;
	class UAbilitySystemComponent* GetAbilitySystemComponentFromActorInfo() const;
	struct FGameplayAbilityActorInfo GetActorInfo() const;
	struct FGameplayTagContainer GetAllAbilityTags() const;
	class AActor* GetAvatarActorFromActorInfo() const;
	int32 GetCancelAllowedPolicy() const;
	struct FGameplayEffectContextHandle GetContextFromOwner(const struct FGameplayAbilityTargetDataHandle& OptionalTargetData) const;
	float GetCooldownTimeRemaining() const;
	struct FGameplayEventData GetCurrentEventData() const;
	class UAnimMontage* GetCurrentMontage() const;
	class UObject* GetCurrentSourceObject() const;
	struct FGameplayEffectContextHandle GetGrantedByEffectContext() const;
	class AActor* GetOwningActorFromActorInfo() const;
	class USkeletalMeshComponent* GetOwningComponentFromActorInfo() const;
	EAbilityReconnectMode GetReconnectMode() const;
	class UObject* GetSourceObject_BP(const struct FGameplayAbilitySpecHandle& Handle, const struct FGameplayAbilityActorInfo& ActorInfo) const;
	bool HasAbilityOperationTag(const struct FGameplayTag& InTag) const;
	bool HasRemoteEndContext() const;
	void InvalidateClientPredictionKey() const;
	bool IsEndByRemote() const;
	bool IsForceEndByRemote() const;
	bool IsForRemoteClient() const;
	bool IsForRunAlone() const;
	bool IsLocallyControlled() const;
	bool IsNetAutonomousOrHasLocalNetOwner() const;
	bool IsPredictingAbility() const;
	bool IsPredictingClient() const;
	bool IsSlackLogicSatisfy(class FName Identifier) const;
	bool K2_CanActivateAbility(const struct FGameplayAbilityActorInfo& ActorInfo, const struct FGameplayAbilitySpecHandle& Handle, struct FGameplayTagContainer* RelevantTags) const;
	bool K2_HasAuthority() const;
	bool K2_ShouldAbilityRespondToEvent(const struct FGameplayAbilityActorInfo& ActorInfo, const struct FGameplayEventData& Payload) const;
	struct FGameplayEffectSpecHandle MakeOutgoingGameplayEffectSpec(TSubclassOf<class UGameplayEffect> GameplayEffectClass, float Level) const;
	bool RemoteHasAbilityOperationTag(const struct FGameplayTag& InTag) const;
	bool ServerInitCanEndByRemote() const;

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("GameplayAbility")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"GameplayAbility")
	}
	static class UGameplayAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayAbility>();
	}
};
DUMPER7_ASSERTS_UGameplayAbility;

// Class GameplayAbilities.GameplayAbilitySet
// 0x0010 (0x0048 - 0x0038)
class UGameplayAbilitySet final : public UDataAsset
{
public:
	TArray<struct FGameplayAbilityBindInfo>       Abilities;                                         // 0x0038(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("GameplayAbilitySet")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"GameplayAbilitySet")
	}
	static class UGameplayAbilitySet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayAbilitySet>();
	}
};
DUMPER7_ASSERTS_UGameplayAbilitySet;

// Class GameplayAbilities.GameplayAbilityTargetActor_Trace
// 0x0020 (0x0930 - 0x0910)
class AGameplayAbilityTargetActor_Trace : public AGameplayAbilityTargetActor
{
public:
	float                                         MaxRange;                                          // 0x0910(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCollisionProfileName                  TraceProfile;                                      // 0x0914(0x000C)(Edit, BlueprintVisible, Config, NoDestructor, ExposeOnSpawn, NativeAccessSpecifierPublic)
	bool                                          bTraceAffectsAimPitch;                             // 0x0920(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_921[0xF];                                      // 0x0921(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("GameplayAbilityTargetActor_Trace")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"GameplayAbilityTargetActor_Trace")
	}
	static class AGameplayAbilityTargetActor_Trace* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGameplayAbilityTargetActor_Trace>();
	}
};
DUMPER7_ASSERTS_AGameplayAbilityTargetActor_Trace;

// Class GameplayAbilities.GameplayAbilityTargetActor_GroundTrace
// 0x0020 (0x0950 - 0x0930)
class AGameplayAbilityTargetActor_GroundTrace : public AGameplayAbilityTargetActor_Trace
{
public:
	float                                         CollisionRadius;                                   // 0x0930(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CollisionHeight;                                   // 0x0934(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_938[0x18];                                     // 0x0938(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("GameplayAbilityTargetActor_GroundTrace")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"GameplayAbilityTargetActor_GroundTrace")
	}
	static class AGameplayAbilityTargetActor_GroundTrace* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGameplayAbilityTargetActor_GroundTrace>();
	}
};
DUMPER7_ASSERTS_AGameplayAbilityTargetActor_GroundTrace;

// Class GameplayAbilities.GameplayAbilityTargetActor_ActorPlacement
// 0x0020 (0x0970 - 0x0950)
class AGameplayAbilityTargetActor_ActorPlacement final : public AGameplayAbilityTargetActor_GroundTrace
{
public:
	TSubclassOf<class UObject>                    PlacedActorClass;                                  // 0x0950(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, ExposeOnSpawn, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     PlacedActorMaterial;                               // 0x0958(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, ExposeOnSpawn, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_960[0x10];                                     // 0x0960(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("GameplayAbilityTargetActor_ActorPlacement")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"GameplayAbilityTargetActor_ActorPlacement")
	}
	static class AGameplayAbilityTargetActor_ActorPlacement* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGameplayAbilityTargetActor_ActorPlacement>();
	}
};
DUMPER7_ASSERTS_AGameplayAbilityTargetActor_ActorPlacement;

// Class GameplayAbilities.GameplayAbilityTargetActor_SingleLineTrace
// 0x0000 (0x0930 - 0x0930)
class AGameplayAbilityTargetActor_SingleLineTrace final : public AGameplayAbilityTargetActor_Trace
{
public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("GameplayAbilityTargetActor_SingleLineTrace")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"GameplayAbilityTargetActor_SingleLineTrace")
	}
	static class AGameplayAbilityTargetActor_SingleLineTrace* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGameplayAbilityTargetActor_SingleLineTrace>();
	}
};
DUMPER7_ASSERTS_AGameplayAbilityTargetActor_SingleLineTrace;

// Class GameplayAbilities.GameplayAbilityWorldReticle
// 0x0030 (0x0710 - 0x06E0)
#pragma pack(push, 0x1)
class alignas(0x10) AGameplayAbilityWorldReticle : public AActor
{
public:
	struct FWorldReticleParameters                Parameters;                                        // 0x06D8(0x0018)(Edit, BlueprintVisible, DisableEditOnTemplate, NoDestructor, ExposeOnSpawn, NativeAccessSpecifierPublic)
	bool                                          bFaceOwnerFlat;                                    // 0x06F0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSnapToTargetedActor;                              // 0x06F1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsTargetValid;                                    // 0x06F2(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsTargetAnActor;                                  // 0x06F3(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6F4[0x4];                                      // 0x06F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class APlayerController*                      PrimaryPC;                                         // 0x06F8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AGameplayAbilityTargetActor*            TargetingActor;                                    // 0x0700(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void FaceTowardSource(bool bFaceIn2D);
	void OnParametersInitialized();
	void OnTargetingAnActor(bool bNewValue);
	void OnValidTargetChanged(bool bNewValue);
	void SetReticleMaterialParamFloat(class FName ParamName, float value);
	void SetReticleMaterialParamVector(class FName ParamName, const struct FVector& value);

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("GameplayAbilityWorldReticle")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"GameplayAbilityWorldReticle")
	}
	static class AGameplayAbilityWorldReticle* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGameplayAbilityWorldReticle>();
	}
};
#pragma pack(pop)
DUMPER7_ASSERTS_AGameplayAbilityWorldReticle;

// Class GameplayAbilities.GameplayAbilityWorldReticle_ActorVisualization
// 0x0010 (0x0720 - 0x0710)
class AGameplayAbilityWorldReticle_ActorVisualization final : public AGameplayAbilityWorldReticle
{
public:
	class UCapsuleComponent*                      CollisionComponent;                                // 0x0708(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UActorComponent*>                VisualizationComponents;                           // 0x0710(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("GameplayAbilityWorldReticle_ActorVisualization")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"GameplayAbilityWorldReticle_ActorVisualization")
	}
	static class AGameplayAbilityWorldReticle_ActorVisualization* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGameplayAbilityWorldReticle_ActorVisualization>();
	}
};
DUMPER7_ASSERTS_AGameplayAbilityWorldReticle_ActorVisualization;

// Class GameplayAbilities.GameplayAbility_CharacterJump
// 0x0000 (0x0F10 - 0x0F10)
class UGameplayAbility_CharacterJump final : public UGameplayAbility
{
public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("GameplayAbility_CharacterJump")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"GameplayAbility_CharacterJump")
	}
	static class UGameplayAbility_CharacterJump* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayAbility_CharacterJump>();
	}
};
DUMPER7_ASSERTS_UGameplayAbility_CharacterJump;

// Class GameplayAbilities.GameplayAbility_Montage
// 0x0038 (0x0F48 - 0x0F10)
class UGameplayAbility_Montage final : public UGameplayAbility
{
public:
	class UAnimMontage*                           MontageToPlay;                                     // 0x0F10(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayRate;                                          // 0x0F18(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SectionName;                                       // 0x0F1C(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UGameplayEffect>>    GameplayEffectClassesWhileAnimating;               // 0x0F28(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class UGameplayEffect*>                GameplayEffectsWhileAnimating;                     // 0x0F38(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, EditConst, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("GameplayAbility_Montage")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"GameplayAbility_Montage")
	}
	static class UGameplayAbility_Montage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayAbility_Montage>();
	}
};
DUMPER7_ASSERTS_UGameplayAbility_Montage;

// Class GameplayAbilities.AbilityTask_ApplyRootMotion_Base
// 0x0070 (0x0208 - 0x0198)
class UAbilityTask_ApplyRootMotion_Base : public UAbilityTask
{
public:
	uint8                                         Pad_198[0x8];                                      // 0x0198(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ForceName;                                         // 0x01A0(0x000C)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ERootMotionFinishVelocityMode                 FinishVelocityMode;                                // 0x01AC(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1AD[0x3];                                      // 0x01AD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                FinishSetVelocity;                                 // 0x01B0(0x0018)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FinishClampVelocity;                               // 0x01C8(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1CC[0x4];                                      // 0x01CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCharacterMovementComponent*            MovementComponent;                                 // 0x01D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint16                                        RootMotionSourceID;                                // 0x01D8(0x0002)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsFinished;                                       // 0x01DA(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1DB[0x1];                                      // 0x01DB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StartTime;                                         // 0x01DC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EndTime;                                           // 0x01E0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1E4[0x4];                                      // 0x01E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 PredictionID;                                      // 0x01E8(0x0010)(ZeroConstructor, Transient, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ACharacter*                             CharacterOwner;                                    // 0x01F8(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsForRemoteClient;                                // 0x0200(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsBoundToMovementDelegate;                        // 0x0201(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_202[0x6];                                      // 0x0202(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CheckRootMotionValidAfterMoveUpdated(float DeltaSeconds, const struct FVector& OldLocation, const struct FVector& OldVelocity);
	void CheckRootMotionValidBeforeMove(float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("AbilityTask_ApplyRootMotion_Base")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"AbilityTask_ApplyRootMotion_Base")
	}
	static class UAbilityTask_ApplyRootMotion_Base* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityTask_ApplyRootMotion_Base>();
	}
};
DUMPER7_ASSERTS_UAbilityTask_ApplyRootMotion_Base;

// Class GameplayAbilities.AbilityTask_ApplyRootMotionConstantForce
// 0x0048 (0x0250 - 0x0208)
class UAbilityTask_ApplyRootMotionConstantForce final : public UAbilityTask_ApplyRootMotion_Base
{
public:
	TMulticastInlineDelegate<void(ERootMotionTaskEndReason RootMotionEndReason)> OnFinish;           // 0x0208(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FVector                                WorldDirection;                                    // 0x0218(0x0018)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Strength;                                          // 0x0230(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Duration;                                          // 0x0234(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsAdditive;                                       // 0x0238(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_239[0x7];                                      // 0x0239(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            StrengthOverTime;                                  // 0x0240(0x0008)(Net, ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableGravity;                                    // 0x0248(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_249[0x7];                                      // 0x0249(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAbilityTask_ApplyRootMotionConstantForce* ApplyRootMotionConstantForce(class UGameplayAbility* OwningAbility, class FName TaskInstanceName, const struct FVector& WorldDirection_0, float Strength_0, float Duration_0, bool bIsAdditive_0, class UCurveFloat* StrengthOverTime_0, ERootMotionFinishVelocityMode VelocityOnFinishMode, const struct FVector& SetVelocityOnFinish, float ClampVelocityOnFinish, bool bEnableGravity_0);

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("AbilityTask_ApplyRootMotionConstantForce")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"AbilityTask_ApplyRootMotionConstantForce")
	}
	static class UAbilityTask_ApplyRootMotionConstantForce* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityTask_ApplyRootMotionConstantForce>();
	}
};
DUMPER7_ASSERTS_UAbilityTask_ApplyRootMotionConstantForce;

// Class GameplayAbilities.AbilityTask_ApplyRootMotionJumpForce
// 0x0068 (0x0270 - 0x0208)
class UAbilityTask_ApplyRootMotionJumpForce final : public UAbilityTask_ApplyRootMotion_Base
{
public:
	TMulticastInlineDelegate<void()>              OnFinish;                                          // 0x0208(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnLanded;                                          // 0x0218(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0228(0x0018)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         Distance;                                          // 0x0240(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Height;                                            // 0x0244(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Duration;                                          // 0x0248(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinimumLandedTriggerTime;                          // 0x024C(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bFinishOnLanded;                                   // 0x0250(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_251[0x7];                                      // 0x0251(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveVector*                           PathOffsetCurve;                                   // 0x0258(0x0008)(Net, ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            TimeMappingCurve;                                  // 0x0260(0x0008)(Net, ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHasLanded;                                        // 0x0268(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_269[0x7];                                      // 0x0269(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAbilityTask_ApplyRootMotionJumpForce* ApplyRootMotionJumpForce(class UGameplayAbility* OwningAbility, class FName TaskInstanceName, const struct FRotator& Rotation_0, float Distance_0, float Height_0, float Duration_0, float MinimumLandedTriggerTime_0, bool bFinishOnLanded_0, ERootMotionFinishVelocityMode VelocityOnFinishMode, const struct FVector& SetVelocityOnFinish, float ClampVelocityOnFinish, class UCurveVector* PathOffsetCurve_0, class UCurveFloat* TimeMappingCurve_0);

	void Finish();
	void OnLandedCallback(const struct FHitResult& Hit);

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("AbilityTask_ApplyRootMotionJumpForce")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"AbilityTask_ApplyRootMotionJumpForce")
	}
	static class UAbilityTask_ApplyRootMotionJumpForce* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityTask_ApplyRootMotionJumpForce>();
	}
};
DUMPER7_ASSERTS_UAbilityTask_ApplyRootMotionJumpForce;

// Class GameplayAbilities.AbilityTask_ApplyRootMotionMoveToActorForce
// 0x00B0 (0x02B8 - 0x0208)
class UAbilityTask_ApplyRootMotionMoveToActorForce final : public UAbilityTask_ApplyRootMotion_Base
{
public:
	TMulticastInlineDelegate<void(bool DestinationReached, bool TimedOut, const struct FVector& FinalTargetLocation)> OnFinished; // 0x0208(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(ERootMotionTaskEndReason RootMotionTaskEndReason)> OnFinish;       // 0x0218(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_228[0x8];                                      // 0x0228(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                StartLocation;                                     // 0x0230(0x0018)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                TargetLocation;                                    // 0x0248(0x0018)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 TargetActor;                                       // 0x0260(0x0008)(Net, ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                TargetLocationOffset;                              // 0x0268(0x0018)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ERootMotionMoveToActorTargetOffsetType        OffsetAlignment;                                   // 0x0280(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_281[0x3];                                      // 0x0281(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Duration;                                          // 0x0284(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDisableDestinationReachedInterrupt;               // 0x0288(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSetNewMovementMode;                               // 0x0289(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EMovementMode                                 NewMovementMode;                                   // 0x028A(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRestrictSpeedToExpected;                          // 0x028B(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_28C[0x4];                                      // 0x028C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveVector*                           PathOffsetCurve;                                   // 0x0290(0x0008)(Net, ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            TimeMappingCurve;                                  // 0x0298(0x0008)(Net, ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            TargetLerpSpeedHorizontalCurve;                    // 0x02A0(0x0008)(Net, ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            TargetLerpSpeedVerticalCurve;                      // 0x02A8(0x0008)(Net, ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B0[0x8];                                      // 0x02B0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAbilityTask_ApplyRootMotionMoveToActorForce* ApplyRootMotionMoveToActorForce(class UGameplayAbility* OwningAbility, class FName TaskInstanceName, class AActor* TargetActor_0, const struct FVector& TargetLocationOffset_0, ERootMotionMoveToActorTargetOffsetType OffsetAlignment_0, float Duration_0, class UCurveFloat* TargetLerpSpeedHorizontal, class UCurveFloat* TargetLerpSpeedVertical, bool bSetNewMovementMode_0, EMovementMode MovementMode, bool bRestrictSpeedToExpected_0, class UCurveVector* PathOffsetCurve_0, class UCurveFloat* TimeMappingCurve_0, ERootMotionFinishVelocityMode VelocityOnFinishMode, const struct FVector& SetVelocityOnFinish, float ClampVelocityOnFinish, bool bDisableDestinationReachedInterrupt_0);
	static class UAbilityTask_ApplyRootMotionMoveToActorForce* ApplyRootMotionMoveToTargetDataActorForce(class UGameplayAbility* OwningAbility, class FName TaskInstanceName, const struct FGameplayAbilityTargetDataHandle& TargetDataHandle, int32 TargetDataIndex, int32 TargetActorIndex, const struct FVector& TargetLocationOffset_0, ERootMotionMoveToActorTargetOffsetType OffsetAlignment_0, float Duration_0, class UCurveFloat* TargetLerpSpeedHorizontal, class UCurveFloat* TargetLerpSpeedVertical, bool bSetNewMovementMode_0, EMovementMode MovementMode, bool bRestrictSpeedToExpected_0, class UCurveVector* PathOffsetCurve_0, class UCurveFloat* TimeMappingCurve_0, ERootMotionFinishVelocityMode VelocityOnFinishMode, const struct FVector& SetVelocityOnFinish, float ClampVelocityOnFinish, bool bDisableDestinationReachedInterrupt_0);

	void OnRep_TargetLocation();
	void OnTargetActorSwapped(class AActor* OriginalTarget, class AActor* NewTarget);

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("AbilityTask_ApplyRootMotionMoveToActorForce")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"AbilityTask_ApplyRootMotionMoveToActorForce")
	}
	static class UAbilityTask_ApplyRootMotionMoveToActorForce* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityTask_ApplyRootMotionMoveToActorForce>();
	}
};
DUMPER7_ASSERTS_UAbilityTask_ApplyRootMotionMoveToActorForce;

// Class GameplayAbilities.AbilityTask_ApplyRootMotionMoveToForce
// 0x0078 (0x0280 - 0x0208)
class UAbilityTask_ApplyRootMotionMoveToForce final : public UAbilityTask_ApplyRootMotion_Base
{
public:
	TMulticastInlineDelegate<void()>              OnTimedOut;                                        // 0x0208(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnTimedOutAndDestinationReached;                   // 0x0218(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(ERootMotionTaskEndReason RootMotionEndReason)> OnFinish;           // 0x0228(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FVector                                StartLocation;                                     // 0x0238(0x0018)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                TargetLocation;                                    // 0x0250(0x0018)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Duration;                                          // 0x0268(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSetNewMovementMode;                               // 0x026C(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EMovementMode                                 NewMovementMode;                                   // 0x026D(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRestrictSpeedToExpected;                          // 0x026E(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_26F[0x1];                                      // 0x026F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveVector*                           PathOffsetCurve;                                   // 0x0270(0x0008)(Net, ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_278[0x8];                                      // 0x0278(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAbilityTask_ApplyRootMotionMoveToForce* ApplyRootMotionMoveToForce(class UGameplayAbility* OwningAbility, class FName TaskInstanceName, const struct FVector& TargetLocation_0, float Duration_0, bool bSetNewMovementMode_0, EMovementMode MovementMode, bool bRestrictSpeedToExpected_0, class UCurveVector* PathOffsetCurve_0, ERootMotionFinishVelocityMode VelocityOnFinishMode, const struct FVector& SetVelocityOnFinish, float ClampVelocityOnFinish);

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("AbilityTask_ApplyRootMotionMoveToForce")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"AbilityTask_ApplyRootMotionMoveToForce")
	}
	static class UAbilityTask_ApplyRootMotionMoveToForce* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityTask_ApplyRootMotionMoveToForce>();
	}
};
DUMPER7_ASSERTS_UAbilityTask_ApplyRootMotionMoveToForce;

// Class GameplayAbilities.AbilityTask_ApplyRootMotionRadialForce
// 0x0070 (0x0278 - 0x0208)
class UAbilityTask_ApplyRootMotionRadialForce final : public UAbilityTask_ApplyRootMotion_Base
{
public:
	TMulticastInlineDelegate<void(ERootMotionTaskEndReason TaskEndReason)> OnFinish;                 // 0x0208(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0218(0x0018)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 LocationActor;                                     // 0x0230(0x0008)(Net, ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Strength;                                          // 0x0238(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Duration;                                          // 0x023C(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Radius;                                            // 0x0240(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsPush;                                           // 0x0244(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsAdditive;                                       // 0x0245(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bNoZForce;                                         // 0x0246(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_247[0x1];                                      // 0x0247(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            StrengthDistanceFalloff;                           // 0x0248(0x0008)(Net, ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            StrengthOverTime;                                  // 0x0250(0x0008)(Net, ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseFixedWorldDirection;                           // 0x0258(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_259[0x7];                                      // 0x0259(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               FixedWorldDirection;                               // 0x0260(0x0018)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UAbilityTask_ApplyRootMotionRadialForce* ApplyRootMotionRadialForce(class UGameplayAbility* OwningAbility, class FName TaskInstanceName, const struct FVector& Location_0, class AActor* LocationActor_0, float Strength_0, float Duration_0, float Radius_0, bool bIsPush_0, bool bIsAdditive_0, bool bNoZForce_0, class UCurveFloat* StrengthDistanceFalloff_0, class UCurveFloat* StrengthOverTime_0, bool bUseFixedWorldDirection_0, const struct FRotator& FixedWorldDirection_0, ERootMotionFinishVelocityMode VelocityOnFinishMode, const struct FVector& SetVelocityOnFinish, float ClampVelocityOnFinish);

	void UpdateTargetAndLocation(class AActor* NewActor, const struct FVector& NewLocation);

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("AbilityTask_ApplyRootMotionRadialForce")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"AbilityTask_ApplyRootMotionRadialForce")
	}
	static class UAbilityTask_ApplyRootMotionRadialForce* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityTask_ApplyRootMotionRadialForce>();
	}
};
DUMPER7_ASSERTS_UAbilityTask_ApplyRootMotionRadialForce;

// Class GameplayAbilities.AbilityTask_MoveToLocation
// 0x0070 (0x0208 - 0x0198)
class UAbilityTask_MoveToLocation final : public UAbilityTask
{
public:
	uint8                                         Pad_198[0x8];                                      // 0x0198(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnTargetLocationReached;                           // 0x01A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bIsFinished;                                       // 0x01B0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1B1[0x7];                                      // 0x01B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                StartLocation;                                     // 0x01B8(0x0018)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                TargetLocation;                                    // 0x01D0(0x0018)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DurationOfMovement;                                // 0x01E8(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeMoveStarted;                                   // 0x01EC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeMoveWillEnd;                                   // 0x01F0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1F4[0x4];                                      // 0x01F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            LerpCurve;                                         // 0x01F8(0x0008)(Net, ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveVector*                           LerpCurveVector;                                   // 0x0200(0x0008)(Net, ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UAbilityTask_MoveToLocation* MoveToLocation(class UGameplayAbility* OwningAbility, class FName TaskInstanceName, const struct FVector& Location, float Duration, class UCurveFloat* OptionalInterpolationCurve, class UCurveVector* OptionalVectorInterpolationCurve);

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("AbilityTask_MoveToLocation")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"AbilityTask_MoveToLocation")
	}
	static class UAbilityTask_MoveToLocation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityTask_MoveToLocation>();
	}
};
DUMPER7_ASSERTS_UAbilityTask_MoveToLocation;

// Class GameplayAbilities.AbilityTask_PlayMontageAndWait
// 0x0090 (0x0228 - 0x0198)
class UAbilityTask_PlayMontageAndWait final : public UAbilityTask
{
public:
	TMulticastInlineDelegate<void()>              OnCompleted;                                       // 0x0198(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnBlendOut;                                        // 0x01A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnInterrupted;                                     // 0x01B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnCancelled;                                       // 0x01C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D8[0x28];                                     // 0x01D8(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           MontageToPlay;                                     // 0x0200(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Rate;                                              // 0x0208(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   StartSection;                                      // 0x020C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AnimRootMotionTranslationScale;                    // 0x0218(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StartTimeSeconds;                                  // 0x021C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bStopWhenAbilityEnds;                              // 0x0220(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAllowInterruptAfterBlendOut;                      // 0x0221(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_222[0x6];                                      // 0x0222(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAbilityTask_PlayMontageAndWait* CreatePlayMontageAndWaitProxy(class UGameplayAbility* OwningAbility, class FName TaskInstanceName, class UAnimMontage* MontageToPlay_0, float Rate_0, class FName StartSection_0, bool bStopWhenAbilityEnds_0, float AnimRootMotionTranslationScale_0, float StartTimeSeconds_0, bool bAllowInterruptAfterBlendOut_0);

	void OnGameplayAbilityCancelled();
	void OnMontageBlendingOut(class UAnimMontage* Montage, bool bInterrupted);
	void OnMontageEnded(class UAnimMontage* Montage, bool bInterrupted);
	void OnMontageInterrupted();

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("AbilityTask_PlayMontageAndWait")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"AbilityTask_PlayMontageAndWait")
	}
	static class UAbilityTask_PlayMontageAndWait* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityTask_PlayMontageAndWait>();
	}
};
DUMPER7_ASSERTS_UAbilityTask_PlayMontageAndWait;

// Class GameplayAbilities.AbilityTask_SpawnActor
// 0x0188 (0x0320 - 0x0198)
class UAbilityTask_SpawnActor : public UAbilityTask
{
public:
	TMulticastInlineDelegate<void(class AActor* SpawnedActor)> Success;                              // 0x0198(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AActor* SpawnedActor)> DidNotSpawn;                          // 0x01A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B8[0x168];                                    // 0x01B8(0x0168)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAbilityTask_SpawnActor* SpawnActor(class UGameplayAbility* OwningAbility, const struct FGameplayAbilityTargetDataHandle& TargetData, TSubclassOf<class AActor> Class_0);

	bool BeginSpawningActor(class UGameplayAbility* OwningAbility, const struct FGameplayAbilityTargetDataHandle& TargetData, TSubclassOf<class AActor> Class_0, class AActor** SpawnedActor);
	void FinishSpawningActor(class UGameplayAbility* OwningAbility, const struct FGameplayAbilityTargetDataHandle& TargetData, class AActor* SpawnedActor);

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("AbilityTask_SpawnActor")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"AbilityTask_SpawnActor")
	}
	static class UAbilityTask_SpawnActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityTask_SpawnActor>();
	}
};
DUMPER7_ASSERTS_UAbilityTask_SpawnActor;

// Class GameplayAbilities.AbilityTask_StartAbilityState
// 0x0038 (0x01D0 - 0x0198)
class UAbilityTask_StartAbilityState final : public UAbilityTask
{
public:
	TMulticastInlineDelegate<void()>              OnStateEnded;                                      // 0x0198(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnStateInterrupted;                                // 0x01A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B8[0x10];                                     // 0x01B8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bWasEnded;                                         // 0x01C8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bWasInterrupted;                                   // 0x01C9(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bEndCurrentState;                                  // 0x01CA(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1CB[0x5];                                      // 0x01CB(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAbilityTask_StartAbilityState* StartAbilityState(class UGameplayAbility* OwningAbility, class FName StateName, bool bEndCurrentState_0);

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("AbilityTask_StartAbilityState")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"AbilityTask_StartAbilityState")
	}
	static class UAbilityTask_StartAbilityState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityTask_StartAbilityState>();
	}
};
DUMPER7_ASSERTS_UAbilityTask_StartAbilityState;

// Class GameplayAbilities.AbilityTask_VisualizeTargeting
// 0x0038 (0x01D0 - 0x0198)
class UAbilityTask_VisualizeTargeting final : public UAbilityTask
{
public:
	TMulticastInlineDelegate<void()>              TimeElapsed;                                       // 0x0198(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A8[0x28];                                     // 0x01A8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAbilityTask_VisualizeTargeting* VisualizeTargeting(class UGameplayAbility* OwningAbility, TSubclassOf<class AGameplayAbilityTargetActor> Class_0, class FName TaskInstanceName, float Duration);
	static class UAbilityTask_VisualizeTargeting* VisualizeTargetingUsingActor(class UGameplayAbility* OwningAbility, class AGameplayAbilityTargetActor* TargetActor, class FName TaskInstanceName, float Duration);

	bool BeginSpawningActor(class UGameplayAbility* OwningAbility, TSubclassOf<class AGameplayAbilityTargetActor> Class_0, class AGameplayAbilityTargetActor** SpawnedActor);
	void FinishSpawningActor(class UGameplayAbility* OwningAbility, class AGameplayAbilityTargetActor* SpawnedActor);

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("AbilityTask_VisualizeTargeting")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"AbilityTask_VisualizeTargeting")
	}
	static class UAbilityTask_VisualizeTargeting* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityTask_VisualizeTargeting>();
	}
};
DUMPER7_ASSERTS_UAbilityTask_VisualizeTargeting;

// Class GameplayAbilities.AbilityTask_WaitAbilityCommit
// 0x0080 (0x0218 - 0x0198)
class UAbilityTask_WaitAbilityCommit final : public UAbilityTask
{
public:
	TMulticastInlineDelegate<void(class UGameplayAbility* ActivatedAbility)> OnCommit;               // 0x0198(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FGameplayTag                           WithTag;                                           // 0x01A8(0x000C)(Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           WithoutTag;                                        // 0x01B4(0x000C)(Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          TriggerOnce;                                       // 0x01C0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C1[0x7];                                      // 0x01C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagQuery                      Query;                                             // 0x01C8(0x0048)(Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_210[0x8];                                      // 0x0210(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAbilityTask_WaitAbilityCommit* WaitForAbilityCommit(class UGameplayAbility* OwningAbility, const struct FGameplayTag& WithTag_0, const struct FGameplayTag& WithoutTage, bool TriggerOnce_0);
	static class UAbilityTask_WaitAbilityCommit* WaitForAbilityCommit_Query(class UGameplayAbility* OwningAbility, const struct FGameplayTagQuery& Query_0, bool TriggerOnce_0);

	void OnAbilityCommit(class UGameplayAbility* ActivatedAbility);

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("AbilityTask_WaitAbilityCommit")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"AbilityTask_WaitAbilityCommit")
	}
	static class UAbilityTask_WaitAbilityCommit* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityTask_WaitAbilityCommit>();
	}
};
DUMPER7_ASSERTS_UAbilityTask_WaitAbilityCommit;

// Class GameplayAbilities.AbilityTask_WaitAttributeChange
// 0x0088 (0x0220 - 0x0198)
class UAbilityTask_WaitAttributeChange final : public UAbilityTask
{
public:
	TMulticastInlineDelegate<void()>              OnChange;                                          // 0x0198(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FGameplayTag                           WithTag;                                           // 0x01A8(0x000C)(Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           WithoutTag;                                        // 0x01B4(0x000C)(Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAttribute                     Attribute;                                         // 0x01C0(0x0040)(Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWaitAttributeChangeComparison                ComparisonType;                                    // 0x0200(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_201[0x3];                                      // 0x0201(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ComparisonValue;                                   // 0x0204(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTriggerOnce;                                      // 0x0208(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_209[0xF];                                      // 0x0209(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	class UAbilitySystemComponent*                ExternalOwner;                                     // 0x0218(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UAbilityTask_WaitAttributeChange* WaitForAttributeChange(class UGameplayAbility* OwningAbility, const struct FGameplayAttribute& Attribute_0, const struct FGameplayTag& WithSrcTag, const struct FGameplayTag& WithoutSrcTag, bool TriggerOnce, class AActor* OptionalExternalOwner);
	static class UAbilityTask_WaitAttributeChange* WaitForAttributeChangeWithComparison(class UGameplayAbility* OwningAbility, const struct FGameplayAttribute& InAttribute, const struct FGameplayTag& InWithTag, const struct FGameplayTag& InWithoutTag, EWaitAttributeChangeComparison InComparisonType, float InComparisonValue, bool TriggerOnce, class AActor* OptionalExternalOwner);

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("AbilityTask_WaitAttributeChange")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"AbilityTask_WaitAttributeChange")
	}
	static class UAbilityTask_WaitAttributeChange* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityTask_WaitAttributeChange>();
	}
};
DUMPER7_ASSERTS_UAbilityTask_WaitAttributeChange;

// Class GameplayAbilities.AbilityTask_WaitAttributeChangeRatioThreshold
// 0x00E0 (0x0278 - 0x0198)
class UAbilityTask_WaitAttributeChangeRatioThreshold final : public UAbilityTask
{
public:
	TMulticastInlineDelegate<void(bool bMatchesComparison, float CurrentRatio)> OnChange;            // 0x0198(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FGameplayAttribute                     AttributeNumerator;                                // 0x01A8(0x0040)(Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAttribute                     AttributeDenominator;                              // 0x01E8(0x0040)(Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWaitAttributeChangeComparison                ComparisonType;                                    // 0x0228(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWaitAttributeChangeComparison                OtherComparisonType;                               // 0x0229(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22A[0x2];                                      // 0x022A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ComparisonValue;                                   // 0x022C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OtherComparisonValue;                              // 0x0230(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTriggerOnce;                                      // 0x0234(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_235[0x13];                                     // 0x0235(0x0013)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LastAttributeNumeratorValue;                       // 0x0248(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LastAttributeDenominatorValue;                     // 0x024C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bMatchedComparisonLastAttributeChange;             // 0x0250(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_251[0x1F];                                     // 0x0251(0x001F)(Fixing Size After Last Property [ Dumper-7 ])
	class UAbilitySystemComponent*                ExternalOwner;                                     // 0x0270(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UAbilityTask_WaitAttributeChangeRatioThreshold* WaitForAttributeChangeRatioThreshold(class UGameplayAbility* OwningAbility, const struct FGameplayAttribute& AttributeNumerator_0, const struct FGameplayAttribute& AttributeDenominator_0, EWaitAttributeChangeComparison ComparisonType_0, float ComparisonValue_0, bool bTriggerOnce_0, class AActor* OptionalExternalOwner);
	static class UAbilityTask_WaitAttributeChangeRatioThreshold* WaitForAttributeChangeRatioThresholds(class UGameplayAbility* OwningAbility, const struct FGameplayAttribute& AttributeNumerator_0, const struct FGameplayAttribute& AttributeDenominator_0, EWaitAttributeChangeComparison ComparisonType_0, EWaitAttributeChangeComparison OtherComparisonType_0, float ComparisonValue_0, float OtherComparisonValue_0, bool bTriggerOnce_0, class AActor* OptionalExternalOwner);

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("AbilityTask_WaitAttributeChangeRatioThreshold")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"AbilityTask_WaitAttributeChangeRatioThreshold")
	}
	static class UAbilityTask_WaitAttributeChangeRatioThreshold* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityTask_WaitAttributeChangeRatioThreshold>();
	}
};
DUMPER7_ASSERTS_UAbilityTask_WaitAttributeChangeRatioThreshold;

// Class GameplayAbilities.AbilityTask_WaitAttributeChangeThreshold
// 0x0078 (0x0210 - 0x0198)
class UAbilityTask_WaitAttributeChangeThreshold final : public UAbilityTask
{
public:
	TMulticastInlineDelegate<void(bool bMatchesComparison, float CurrentValue)> OnChange;            // 0x0198(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FGameplayAttribute                     Attribute;                                         // 0x01A8(0x0040)(Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWaitAttributeChangeComparison                ComparisonType;                                    // 0x01E8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E9[0x3];                                      // 0x01E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ComparisonValue;                                   // 0x01EC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTriggerOnce;                                      // 0x01F0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F1[0xF];                                      // 0x01F1(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bMatchedComparisonLastAttributeChange;             // 0x0200(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_201[0x7];                                      // 0x0201(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAbilitySystemComponent*                ExternalOwner;                                     // 0x0208(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UAbilityTask_WaitAttributeChangeThreshold* WaitForAttributeChangeThreshold(class UGameplayAbility* OwningAbility, const struct FGameplayAttribute& Attribute_0, EWaitAttributeChangeComparison ComparisonType_0, float ComparisonValue_0, bool bTriggerOnce_0, class AActor* OptionalExternalOwner);

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("AbilityTask_WaitAttributeChangeThreshold")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"AbilityTask_WaitAttributeChangeThreshold")
	}
	static class UAbilityTask_WaitAttributeChangeThreshold* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityTask_WaitAttributeChangeThreshold>();
	}
};
DUMPER7_ASSERTS_UAbilityTask_WaitAttributeChangeThreshold;

// Class GameplayAbilities.AbilityTask_WaitCancel
// 0x0090 (0x0228 - 0x0198)
class UAbilityTask_WaitCancel final : public UAbilityTask
{
public:
	TMulticastInlineDelegate<void()>              OnCancel;                                          // 0x0198(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	int32                                         CancelInputID;                                     // 0x01A8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          RegisteredCallbacks;                               // 0x01AC(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1AD[0x3];                                      // 0x01AD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPredictionKey                         CancelKey;                                         // 0x01B0(0x0070)(Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StartTime;                                         // 0x0220(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_224[0x4];                                      // 0x0224(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAbilityTask_WaitCancel* WaitCancel(class UGameplayAbility* OwningAbility);

	void OnCancelCallback();
	void OnLocalCancelCallback(int32 InputID);

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("AbilityTask_WaitCancel")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"AbilityTask_WaitCancel")
	}
	static class UAbilityTask_WaitCancel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityTask_WaitCancel>();
	}
};
DUMPER7_ASSERTS_UAbilityTask_WaitCancel;

// Class GameplayAbilities.AbilityTask_WaitConfirm
// 0x0028 (0x01C0 - 0x0198)
class UAbilityTask_WaitConfirm final : public UAbilityTask
{
public:
	TMulticastInlineDelegate<void()>              OnConfirm;                                         // 0x0198(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          RegisteredCallback;                                // 0x01A8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1A9[0xF];                                      // 0x01A9(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StartTime;                                         // 0x01B8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1BC[0x4];                                      // 0x01BC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAbilityTask_WaitConfirm* WaitConfirm(class UGameplayAbility* OwningAbility);

	void OnConfirmCallback(class UGameplayAbility* InAbility);

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("AbilityTask_WaitConfirm")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"AbilityTask_WaitConfirm")
	}
	static class UAbilityTask_WaitConfirm* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityTask_WaitConfirm>();
	}
};
DUMPER7_ASSERTS_UAbilityTask_WaitConfirm;

// Class GameplayAbilities.AbilityTask_WaitConfirmCancel
// 0x0128 (0x02C0 - 0x0198)
class UAbilityTask_WaitConfirmCancel final : public UAbilityTask
{
public:
	TDelegate<void()>                             IsConfirmAllowed;                                  // 0x0198(0x0014)(ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1AC[0x4];                                      // 0x01AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnConfirm;                                         // 0x01B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnCancel;                                          // 0x01C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          RegisteredCallbacks;                               // 0x01D0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1D1[0x3];                                      // 0x01D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CancelInputID;                                     // 0x01D4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ConfirmInputID;                                    // 0x01D8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1DC[0x4];                                      // 0x01DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPredictionKey                         CancelKey;                                         // 0x01E0(0x0070)(Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FPredictionKey                         ConfirmKey;                                        // 0x0250(0x0070)(Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UAbilityTask_WaitConfirmCancel* WaitConfirmCancel(class UGameplayAbility* OwningAbility);

	void OnCancelCallback();
	void OnConfirmCallback();
	void OnLocalCancelCallback(int32 InputID);
	void OnLocalConfirmCallback(int32 InputID);

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("AbilityTask_WaitConfirmCancel")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"AbilityTask_WaitConfirmCancel")
	}
	static class UAbilityTask_WaitConfirmCancel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityTask_WaitConfirmCancel>();
	}
};
DUMPER7_ASSERTS_UAbilityTask_WaitConfirmCancel;

// Class GameplayAbilities.AbilityTask_WaitDelay
// 0x0030 (0x01C8 - 0x0198)
class UAbilityTask_WaitDelay final : public UAbilityTask
{
public:
	TMulticastInlineDelegate<void()>              OnFinish;                                          // 0x0198(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         Time;                                              // 0x01A8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         TimeStarted;                                       // 0x01AC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1B0[0x18];                                     // 0x01B0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAbilityTask_WaitDelay* WaitDelay(class UGameplayAbility* OwningAbility, float Time_0);

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("AbilityTask_WaitDelay")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"AbilityTask_WaitDelay")
	}
	static class UAbilityTask_WaitDelay* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityTask_WaitDelay>();
	}
};
DUMPER7_ASSERTS_UAbilityTask_WaitDelay;

// Class GameplayAbilities.AbilityTask_WaitGameplayEffectApplied
// 0x02E8 (0x0480 - 0x0198)
class UAbilityTask_WaitGameplayEffectApplied : public UAbilityTask
{
public:
	uint8                                         Pad_198[0x10];                                     // 0x0198(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagRequirements               SourceTagRequirements;                             // 0x01A8(0x0118)(Transient, NativeAccessSpecifierPublic)
	struct FGameplayTagRequirements               TargetTagRequirements;                             // 0x02C0(0x0118)(Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D8[0x90];                                     // 0x03D8(0x0090)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          TriggerOnce;                                       // 0x0468(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ListenForPeriodicEffects;                          // 0x0469(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RegisteredCallback;                                // 0x046A(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          UseExternalOwner;                                  // 0x046B(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_46C[0x4];                                      // 0x046C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAbilitySystemComponent*                ExternalOwner;                                     // 0x0470(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          Locked;                                            // 0x0478(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_479[0x7];                                      // 0x0479(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnApplyGameplayEffectCallback(class UAbilitySystemComponent* Target, const struct FGameplayEffectSpecStackHandle& SpecHandleApplied, const struct FActiveGameplayEffectHandle& ActiveHandle);

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("AbilityTask_WaitGameplayEffectApplied")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"AbilityTask_WaitGameplayEffectApplied")
	}
	static class UAbilityTask_WaitGameplayEffectApplied* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityTask_WaitGameplayEffectApplied>();
	}
};
DUMPER7_ASSERTS_UAbilityTask_WaitGameplayEffectApplied;

// Class GameplayAbilities.AbilityTask_WaitGameplayEffectApplied_Self
// 0x0020 (0x04A0 - 0x0480)
class UAbilityTask_WaitGameplayEffectApplied_Self final : public UAbilityTask_WaitGameplayEffectApplied
{
public:
	TMulticastInlineDelegate<void(class AActor* Source, const struct FGameplayEffectSpecHandle& SpecHandle, const struct FActiveGameplayEffectHandle& ActiveHandle)> OnApplied; // 0x0480(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_490[0x10];                                     // 0x0490(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAbilityTask_WaitGameplayEffectApplied_Self* WaitGameplayEffectAppliedToSelf(class UGameplayAbility* InOwningAbility, const struct FGameplayTargetDataFilterHandle& InSourceFilter, const struct FGameplayTagRequirements& InSourceTagRequirements, const struct FGameplayTagRequirements& InTargetTagRequirements, bool InTriggerOnce, class AActor* OptionalExternalOwner, bool InListenForPeriodicEffect);
	static class UAbilityTask_WaitGameplayEffectApplied_Self* WaitGameplayEffectAppliedToSelf_Query(class UGameplayAbility* InOwningAbility, const struct FGameplayTargetDataFilterHandle& InSourceFilter, const struct FGameplayTagQuery& InSourceTagQuery, const struct FGameplayTagQuery& InTargetTagQuery, bool InTriggerOnce, class AActor* OptionalExternalOwner, bool InListenForPeriodicEffect);

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("AbilityTask_WaitGameplayEffectApplied_Self")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"AbilityTask_WaitGameplayEffectApplied_Self")
	}
	static class UAbilityTask_WaitGameplayEffectApplied_Self* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityTask_WaitGameplayEffectApplied_Self>();
	}
};
DUMPER7_ASSERTS_UAbilityTask_WaitGameplayEffectApplied_Self;

// Class GameplayAbilities.AbilityTask_WaitGameplayEffectApplied_Target
// 0x0020 (0x04A0 - 0x0480)
class UAbilityTask_WaitGameplayEffectApplied_Target final : public UAbilityTask_WaitGameplayEffectApplied
{
public:
	TMulticastInlineDelegate<void(class AActor* Target, const struct FGameplayEffectSpecHandle& SpecHandle, const struct FActiveGameplayEffectHandle& ActiveHandle)> OnApplied; // 0x0480(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_490[0x10];                                     // 0x0490(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAbilityTask_WaitGameplayEffectApplied_Target* WaitGameplayEffectAppliedToTarget(class UGameplayAbility* InOwningAbility, const struct FGameplayTargetDataFilterHandle& InTargetFilter, const struct FGameplayTagRequirements& InSourceTagRequirements, const struct FGameplayTagRequirements& InTargetTagRequirements, bool InTriggerOnce, class AActor* OptionalExternalOwner, bool InListenForPeriodicEffects);
	static class UAbilityTask_WaitGameplayEffectApplied_Target* WaitGameplayEffectAppliedToTarget_Query(class UGameplayAbility* InOwningAbility, const struct FGameplayTargetDataFilterHandle& InSourceFilter, const struct FGameplayTagQuery& InSourceTagQuery, const struct FGameplayTagQuery& InTargetTagQuery, bool InTriggerOnce, class AActor* OptionalExternalOwner, bool InListenForPeriodicEffect);

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("AbilityTask_WaitGameplayEffectApplied_Target")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"AbilityTask_WaitGameplayEffectApplied_Target")
	}
	static class UAbilityTask_WaitGameplayEffectApplied_Target* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityTask_WaitGameplayEffectApplied_Target>();
	}
};
DUMPER7_ASSERTS_UAbilityTask_WaitGameplayEffectApplied_Target;

// Class GameplayAbilities.AbilityTask_WaitGameplayEffectBlockedImmunity
// 0x0258 (0x03F0 - 0x0198)
class UAbilityTask_WaitGameplayEffectBlockedImmunity final : public UAbilityTask
{
public:
	TMulticastInlineDelegate<void(const struct FGameplayEffectSpecHandle& BlockedSpec, const struct FActiveGameplayEffectHandle& ImmunityGameplayEffectHandle)> Blocked; // 0x0198(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FGameplayTagRequirements               SourceTagRequirements;                             // 0x01A8(0x0118)(Transient, NativeAccessSpecifierPublic)
	struct FGameplayTagRequirements               TargetTagRequirements;                             // 0x02C0(0x0118)(Transient, NativeAccessSpecifierPublic)
	bool                                          TriggerOnce;                                       // 0x03D8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ListenForPeriodicEffects;                          // 0x03D9(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RegisteredCallback;                                // 0x03DA(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          UseExternalOwner;                                  // 0x03DB(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3DC[0x4];                                      // 0x03DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAbilitySystemComponent*                ExternalOwner;                                     // 0x03E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3E8[0x8];                                      // 0x03E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAbilityTask_WaitGameplayEffectBlockedImmunity* WaitGameplayEffectBlockedByImmunity(class UGameplayAbility* OwningAbility, const struct FGameplayTagRequirements& SourceTagRequirements_0, const struct FGameplayTagRequirements& TargetTagRequirements_0, class AActor* OptionalExternalTarget, bool OnlyTriggerOnce);

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("AbilityTask_WaitGameplayEffectBlockedImmunity")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"AbilityTask_WaitGameplayEffectBlockedImmunity")
	}
	static class UAbilityTask_WaitGameplayEffectBlockedImmunity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityTask_WaitGameplayEffectBlockedImmunity>();
	}
};
DUMPER7_ASSERTS_UAbilityTask_WaitGameplayEffectBlockedImmunity;

// Class GameplayAbilities.AbilityTask_WaitGameplayEffectRemoved
// 0x00B0 (0x0248 - 0x0198)
class UAbilityTask_WaitGameplayEffectRemoved final : public UAbilityTask
{
public:
	TMulticastInlineDelegate<void(const struct FGameplayEffectRemovalInfo& GameplayEffectRemovalInfo)> OnRemoved; // 0x0198(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FGameplayEffectRemovalInfo& GameplayEffectRemovalInfo)> InvalidHandle; // 0x01A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B8[0x8];                                      // 0x01B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          Registered;                                        // 0x01C0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1C1[0x17];                                     // 0x01C1(0x0017)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPredictionKey                         RemoveKey;                                         // 0x01D8(0x0070)(Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UAbilityTask_WaitGameplayEffectRemoved* WaitForGameplayEffectRemoved(class UGameplayAbility* OwningAbility, const struct FActiveGameplayEffectHandle& Handle);

	void OnGameplayEffectRemoved(const struct FGameplayEffectRemovalInfo& InGameplayEffectRemovalInfo);

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("AbilityTask_WaitGameplayEffectRemoved")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"AbilityTask_WaitGameplayEffectRemoved")
	}
	static class UAbilityTask_WaitGameplayEffectRemoved* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityTask_WaitGameplayEffectRemoved>();
	}
};
DUMPER7_ASSERTS_UAbilityTask_WaitGameplayEffectRemoved;

// Class GameplayAbilities.AbilityTask_WaitGameplayEffectStackChange
// 0x0038 (0x01D0 - 0x0198)
class UAbilityTask_WaitGameplayEffectStackChange final : public UAbilityTask
{
public:
	TMulticastInlineDelegate<void(const struct FActiveGameplayEffectHandle& Handle, int32 NewCount, int32 OldCount)> OnChange; // 0x0198(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FActiveGameplayEffectHandle& Handle, int32 NewCount, int32 OldCount)> InvalidHandle; // 0x01A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B8[0x8];                                      // 0x01B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          Registered;                                        // 0x01C0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1C1[0xF];                                      // 0x01C1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAbilityTask_WaitGameplayEffectStackChange* WaitForGameplayEffectStackChange(class UGameplayAbility* OwningAbility, const struct FActiveGameplayEffectHandle& Handle);

	void OnGameplayEffectStackChange(const struct FActiveGameplayEffectHandle& Handle, int32 NewCount, int32 OldCount);

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("AbilityTask_WaitGameplayEffectStackChange")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"AbilityTask_WaitGameplayEffectStackChange")
	}
	static class UAbilityTask_WaitGameplayEffectStackChange* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityTask_WaitGameplayEffectStackChange>();
	}
};
DUMPER7_ASSERTS_UAbilityTask_WaitGameplayEffectStackChange;

// Class GameplayAbilities.AbilityTask_WaitGameplayEvent
// 0x0038 (0x01D0 - 0x0198)
class UAbilityTask_WaitGameplayEvent final : public UAbilityTask
{
public:
	TMulticastInlineDelegate<void(const struct FGameplayEventData& Payload)> EventReceived;          // 0x0198(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FGameplayTag                           Tag;                                               // 0x01A8(0x000C)(Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B4[0x4];                                      // 0x01B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAbilitySystemComponent*                OptionalExternalTarget;                            // 0x01B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseExternalTarget;                                 // 0x01C0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          OnlyTriggerOnce;                                   // 0x01C1(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          OnlyMatchExact;                                    // 0x01C2(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C3[0xD];                                      // 0x01C3(0x000D)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAbilityTask_WaitGameplayEvent* WaitGameplayEvent(class UGameplayAbility* OwningAbility, const struct FGameplayTag& EventTag, class AActor* OptionalExternalTarget_0, bool OnlyTriggerOnce_0, bool OnlyMatchExact_0);

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("AbilityTask_WaitGameplayEvent")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"AbilityTask_WaitGameplayEvent")
	}
	static class UAbilityTask_WaitGameplayEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityTask_WaitGameplayEvent>();
	}
};
DUMPER7_ASSERTS_UAbilityTask_WaitGameplayEvent;

// Class GameplayAbilities.AbilityTask_WaitGameplayTag
// 0x0028 (0x01C0 - 0x0198)
class UAbilityTask_WaitGameplayTag : public UAbilityTask
{
public:
	struct FGameplayTag                           Tag;                                               // 0x0198(0x000C)(Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RegisteredCallback;                                // 0x01A4(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1A5[0x3];                                      // 0x01A5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UAbilitySystemComponent*                OptionalExternalTarget;                            // 0x01A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          UseExternalTarget;                                 // 0x01B0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          OnlyTriggerOnce;                                   // 0x01B1(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1B2[0xE];                                      // 0x01B2(0x000E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GameplayTagCallback(const struct FGameplayTag& Tag_0, int32 NewCount);

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("AbilityTask_WaitGameplayTag")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"AbilityTask_WaitGameplayTag")
	}
	static class UAbilityTask_WaitGameplayTag* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityTask_WaitGameplayTag>();
	}
};
DUMPER7_ASSERTS_UAbilityTask_WaitGameplayTag;

// Class GameplayAbilities.AbilityTask_WaitGameplayTagAdded
// 0x0010 (0x01D0 - 0x01C0)
class UAbilityTask_WaitGameplayTagAdded final : public UAbilityTask_WaitGameplayTag
{
public:
	TMulticastInlineDelegate<void()>              Added;                                             // 0x01C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UAbilityTask_WaitGameplayTagAdded* WaitGameplayTagAdd(class UGameplayAbility* OwningAbility, const struct FGameplayTag& InTag, class AActor* InOptionalExternalTarget, bool InOnlyTriggerOnce);

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("AbilityTask_WaitGameplayTagAdded")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"AbilityTask_WaitGameplayTagAdded")
	}
	static class UAbilityTask_WaitGameplayTagAdded* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityTask_WaitGameplayTagAdded>();
	}
};
DUMPER7_ASSERTS_UAbilityTask_WaitGameplayTagAdded;

// Class GameplayAbilities.AbilityTask_WaitGameplayTagRemoved
// 0x0010 (0x01D0 - 0x01C0)
class UAbilityTask_WaitGameplayTagRemoved final : public UAbilityTask_WaitGameplayTag
{
public:
	TMulticastInlineDelegate<void()>              Removed;                                           // 0x01C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UAbilityTask_WaitGameplayTagRemoved* WaitGameplayTagRemove(class UGameplayAbility* OwningAbility, const struct FGameplayTag& InTag, class AActor* InOptionalExternalTarget, bool InOnlyTriggerOnce);

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("AbilityTask_WaitGameplayTagRemoved")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"AbilityTask_WaitGameplayTagRemoved")
	}
	static class UAbilityTask_WaitGameplayTagRemoved* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityTask_WaitGameplayTagRemoved>();
	}
};
DUMPER7_ASSERTS_UAbilityTask_WaitGameplayTagRemoved;

// Class GameplayAbilities.AbilityTask_WaitGameplayTagQuery
// 0x0128 (0x02C0 - 0x0198)
class UAbilityTask_WaitGameplayTagQuery final : public UAbilityTask
{
public:
	uint8                                         Pad_198[0x108];                                    // 0x0198(0x0108)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              Triggered;                                         // 0x02A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	class UAbilitySystemComponent*                OptionalExternalTarget;                            // 0x02B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B8[0x8];                                      // 0x02B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAbilityTask_WaitGameplayTagQuery* WaitGameplayTagQuery(class UGameplayAbility* OwningAbility, const struct FGameplayTagQuery& TagQuery, const class AActor* InOptionalExternalTarget, const EWaitGameplayTagQueryTriggerCondition TriggerCondition, const bool bOnlyTriggerOnce);

	void UpdateTargetTags(const struct FGameplayTag& Tag, int32 NewCount);

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("AbilityTask_WaitGameplayTagQuery")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"AbilityTask_WaitGameplayTagQuery")
	}
	static class UAbilityTask_WaitGameplayTagQuery* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityTask_WaitGameplayTagQuery>();
	}
};
DUMPER7_ASSERTS_UAbilityTask_WaitGameplayTagQuery;

// Class GameplayAbilities.AbilityTask_WaitInputPress
// 0x0088 (0x0220 - 0x0198)
class UAbilityTask_WaitInputPress final : public UAbilityTask
{
public:
	TMulticastInlineDelegate<void(float TimeWaited)> OnPress;                                        // 0x0198(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         StartTime;                                         // 0x01A8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bTestInitialState;                                 // 0x01AC(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1AD[0x3];                                      // 0x01AD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPredictionKey                         PressKey;                                          // 0x01B0(0x0070)(Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UAbilityTask_WaitInputPress* WaitInputPress(class UGameplayAbility* OwningAbility, bool bTestAlreadyPressed);

	void OnLocalPressCallback();
	void OnPressCallback(float Duration);
	void OnReplicatePressCallback(const struct FGameplayAbilityTargetDataHandle& Data);

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("AbilityTask_WaitInputPress")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"AbilityTask_WaitInputPress")
	}
	static class UAbilityTask_WaitInputPress* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityTask_WaitInputPress>();
	}
};
DUMPER7_ASSERTS_UAbilityTask_WaitInputPress;

// Class GameplayAbilities.AbilityTask_WaitInputRelease
// 0x0090 (0x0228 - 0x0198)
class UAbilityTask_WaitInputRelease final : public UAbilityTask
{
public:
	TMulticastInlineDelegate<void(float TimeHeld)> OnRelease;                                        // 0x0198(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         StartTime;                                         // 0x01A8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bTestInitialState;                                 // 0x01AC(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1AD[0x3];                                      // 0x01AD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPredictionKey                         ReleaseKey;                                        // 0x01B0(0x0070)(Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_220[0x8];                                      // 0x0220(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAbilityTask_WaitInputRelease* WaitInputRelease(class UGameplayAbility* OwningAbility, bool bTestAlreadyReleased);

	void OnLocalReleaseCallback();
	void OnReleaseCallback(float Duration);
	void OnReplicateReleaseCallback(const struct FGameplayAbilityTargetDataHandle& Data);

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("AbilityTask_WaitInputRelease")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"AbilityTask_WaitInputRelease")
	}
	static class UAbilityTask_WaitInputRelease* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityTask_WaitInputRelease>();
	}
};
DUMPER7_ASSERTS_UAbilityTask_WaitInputRelease;

// Class GameplayAbilities.AbilityTask_WaitMovementModeChange
// 0x0020 (0x01B8 - 0x0198)
class UAbilityTask_WaitMovementModeChange final : public UAbilityTask
{
public:
	TMulticastInlineDelegate<void(EMovementMode NewMovementMode)> OnChange;                          // 0x0198(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A8[0x10];                                     // 0x01A8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAbilityTask_WaitMovementModeChange* CreateWaitMovementModeChange(class UGameplayAbility* OwningAbility, EMovementMode NewMode);

	void OnMovementModeChange(class ACharacter* Character, EMovementMode PrevMovementMode, uint8 PreviousCustomMode);

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("AbilityTask_WaitMovementModeChange")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"AbilityTask_WaitMovementModeChange")
	}
	static class UAbilityTask_WaitMovementModeChange* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityTask_WaitMovementModeChange>();
	}
};
DUMPER7_ASSERTS_UAbilityTask_WaitMovementModeChange;

// Class GameplayAbilities.AbilityTask_WaitOverlap
// 0x0010 (0x01A8 - 0x0198)
class UAbilityTask_WaitOverlap final : public UAbilityTask
{
public:
	TMulticastInlineDelegate<void(const struct FGameplayAbilityTargetDataHandle& TargetData)> OnOverlap; // 0x0198(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UAbilityTask_WaitOverlap* WaitForOverlap(class UGameplayAbility* OwningAbility);

	void OnHitCallback(class UPrimitiveComponent* HitComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit);

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("AbilityTask_WaitOverlap")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"AbilityTask_WaitOverlap")
	}
	static class UAbilityTask_WaitOverlap* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityTask_WaitOverlap>();
	}
};
DUMPER7_ASSERTS_UAbilityTask_WaitOverlap;

// Class GameplayAbilities.AbilityTask_WaitTargetData
// 0x0040 (0x01D8 - 0x0198)
class UAbilityTask_WaitTargetData final : public UAbilityTask
{
public:
	TMulticastInlineDelegate<void(const struct FGameplayAbilityTargetDataHandle& Data)> ValidData;   // 0x0198(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FGameplayAbilityTargetDataHandle& Data)> Cancelled;   // 0x01A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TSubclassOf<class AGameplayAbilityTargetActor> TargetClass;                                      // 0x01B8(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AGameplayAbilityTargetActor*            TargetActor;                                       // 0x01C0(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EGameplayTargetingConfirmation                ConfirmationType;                                  // 0x01C8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1C9[0xF];                                      // 0x01C9(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAbilityTask_WaitTargetData* WaitTargetData(class UGameplayAbility* OwningAbility, class FName TaskInstanceName, EGameplayTargetingConfirmation ConfirmationType_0, TSubclassOf<class AGameplayAbilityTargetActor> Class_0);
	static class UAbilityTask_WaitTargetData* WaitTargetDataUsingActor(class UGameplayAbility* OwningAbility, class FName TaskInstanceName, EGameplayTargetingConfirmation ConfirmationType_0, class AGameplayAbilityTargetActor* TargetActor_0);

	bool BeginSpawningActor(class UGameplayAbility* OwningAbility, TSubclassOf<class AGameplayAbilityTargetActor> Class_0, class AGameplayAbilityTargetActor** SpawnedActor);
	void FinishSpawningActor(class UGameplayAbility* OwningAbility, class AGameplayAbilityTargetActor* SpawnedActor);
	void OnTargetDataCancelledCallback(const struct FGameplayAbilityTargetDataHandle& Data);
	void OnTargetDataReadyCallback(const struct FGameplayAbilityTargetDataHandle& Data);
	void OnTargetDataReplicatedCallback(const struct FGameplayAbilityTargetDataHandle& Data, const struct FGameplayTag& ActivationTag);
	void OnTargetDataReplicatedCancelledCallback();

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("AbilityTask_WaitTargetData")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"AbilityTask_WaitTargetData")
	}
	static class UAbilityTask_WaitTargetData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityTask_WaitTargetData>();
	}
};
DUMPER7_ASSERTS_UAbilityTask_WaitTargetData;

// Class GameplayAbilities.AbilityTask_WaitVelocityChange
// 0x0038 (0x01D0 - 0x0198)
class UAbilityTask_WaitVelocityChange final : public UAbilityTask
{
public:
	TMulticastInlineDelegate<void()>              OnVelocityChage;                                   // 0x0198(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UMovementComponent*                     CachedMovementComponent;                           // 0x01A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinimumMagnitude;                                  // 0x01B0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1B4[0x4];                                      // 0x01B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Direction;                                         // 0x01B8(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UAbilityTask_WaitVelocityChange* CreateWaitVelocityChange(class UGameplayAbility* OwningAbility, const struct FVector& Direction_0, float MinimumMagnitude_0);

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("AbilityTask_WaitVelocityChange")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"AbilityTask_WaitVelocityChange")
	}
	static class UAbilityTask_WaitVelocityChange* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityTask_WaitVelocityChange>();
	}
};
DUMPER7_ASSERTS_UAbilityTask_WaitVelocityChange;

// Class GameplayAbilities.AbilitySystemBlueprintLibrary
// 0x0000 (0x0030 - 0x0030)
class UAbilitySystemBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static struct FGameplayAbilityTargetDataHandle AbilityTargetDataFromActor(class AActor* Actor);
	static struct FGameplayAbilityTargetDataHandle AbilityTargetDataFromActorArray(const TArray<class AActor*>& ActorArray, bool OneTargetPerHandle);
	static struct FGameplayAbilityTargetDataHandle AbilityTargetDataFromFloat(float InValue);
	static struct FGameplayAbilityTargetDataHandle AbilityTargetDataFromHitResult(const struct FHitResult& HitResult);
	static struct FGameplayAbilityTargetDataHandle AbilityTargetDataFromLocations(const struct FGameplayAbilityTargetingLocationInfo& SourceLocation, const struct FGameplayAbilityTargetingLocationInfo& TargetLocation);
	static struct FGameplayEffectSpecHandle AddAssetTag(const struct FGameplayEffectSpecHandle& SpecHandle, const struct FGameplayTag& NewGameplayTag);
	static struct FGameplayEffectSpecHandle AddAssetTags(const struct FGameplayEffectSpecHandle& SpecHandle, const struct FGameplayTagContainer& NewGameplayTags);
	static struct FGameplayEffectSpecHandle AddGrantedTag(const struct FGameplayEffectSpecHandle& SpecHandle, const struct FGameplayTag& NewGameplayTag);
	static struct FGameplayEffectSpecHandle AddGrantedTags(const struct FGameplayEffectSpecHandle& SpecHandle, const struct FGameplayTagContainer& NewGameplayTags);
	static struct FGameplayEffectSpecHandle AddLinkedGameplayEffect(const struct FGameplayEffectSpecHandle& SpecHandle, TSubclassOf<class UGameplayEffect> LinkedGameplayEffect);
	static struct FGameplayEffectSpecHandle AddLinkedGameplayEffectSpec(const struct FGameplayEffectSpecHandle& SpecHandle, const struct FGameplayEffectSpecHandle& LinkedGameplayEffectSpec);
	static bool AddLooseGameplayTags(class AActor* Actor, const struct FGameplayTagContainer& GameplayTags, bool bShouldReplicate);
	static struct FGameplayAbilityTargetDataHandle AppendTargetDataHandle(const struct FGameplayAbilityTargetDataHandle& TargetHandle, const struct FGameplayAbilityTargetDataHandle& HandleToAdd);
	static struct FGameplayEffectSpecHandle AssignSetByCallerMagnitude(const struct FGameplayEffectSpecHandle& SpecHandle, class FName DataName, float Magnitude);
	static struct FGameplayEffectSpecHandle AssignTagSetByCallerMagnitude(const struct FGameplayEffectSpecHandle& SpecHandle, const struct FGameplayTag& DataTag, float Magnitude);
	static void BreakGameplayCueParameters(const struct FGameplayCueParameters& Parameters, float* NormalizedMagnitude, float* RawMagnitude, EGameplayEffectDurationType* DurationPolicy, float* Duration, float* Period, struct FGameplayEffectContextHandle* EffectContext, struct FGameplayTag* MatchedTagName, struct FGameplayTag* OriginalTag, struct FGameplayTagContainer* AggregatedSourceTags, struct FGameplayTagContainer* AggregatedTargetTags, struct FVector* Location, struct FVector* Normal, class AActor** Instigator, class AActor** EffectCauser, class UObject** SourceObject, class UPhysicalMaterial** PhysicalMaterial, int32* GameplayEffectLevel, int32* AbilityLevel, class USceneComponent** TargetAttachComponent, bool* bReplicateLocationWhenUsingMinimalRepProxy, int32* SkinID, TArray<int64>* SkinFXSlots, int32* UID);
	static struct FGameplayEffectSpecHandle CloneSpecHandle(class AActor* InNewInstigator, class AActor* InEffectCauser, const struct FGameplayEffectSpecHandle& GameplayEffectSpecHandle_Clone);
	static bool DoesActorMeetTagRequirements(class AActor* Actor, const struct FGameplayTagRequirements& TagRequirements);
	static bool DoesGameplayCueMeetTagRequirements(const struct FGameplayCueParameters& Parameters, const struct FGameplayTagRequirements& SourceTagReqs, const struct FGameplayTagRequirements& TargetTagReqs);
	static bool DoesTargetDataContainActor(const struct FGameplayAbilityTargetDataHandle& TargetData, int32 Index_0, class AActor* Actor);
	static void EffectContextAddHitResult(const struct FGameplayEffectContextHandle& EffectContext, const struct FHitResult& HitResult, bool bReset);
	static class AActor* EffectContextGetEffectCauser(const struct FGameplayEffectContextHandle& EffectContext);
	static struct FHitResult EffectContextGetHitResult(const struct FGameplayEffectContextHandle& EffectContext);
	static TArray<struct FHitResult> EffectContextGetHitResults(const struct FGameplayEffectContextHandle& EffectContext);
	static class AActor* EffectContextGetInstigatorActor(const struct FGameplayEffectContextHandle& EffectContext);
	static int32 EffectContextGetNumHitResults(const struct FGameplayEffectContextHandle& EffectContext);
	static struct FVector EffectContextGetOrigin(const struct FGameplayEffectContextHandle& EffectContext);
	static class AActor* EffectContextGetOriginalInstigatorActor(const struct FGameplayEffectContextHandle& EffectContext);
	static class UObject* EffectContextGetSourceObject(const struct FGameplayEffectContextHandle& EffectContext);
	static bool EffectContextHasHitResult(const struct FGameplayEffectContextHandle& EffectContext);
	static bool EffectContextIsInstigatorLocallyControlled(const struct FGameplayEffectContextHandle& EffectContext);
	static bool EffectContextIsValid(const struct FGameplayEffectContextHandle& EffectContext);
	static void EffectContextSetOrigin(const struct FGameplayEffectContextHandle& EffectContext, const struct FVector& Origin);
	static bool EqualEqual_ActiveGameplayEffectHandle(const struct FActiveGameplayEffectHandle& A, const struct FActiveGameplayEffectHandle& B);
	static bool EqualEqual_GameplayAbilitySpecHandle(const struct FGameplayAbilitySpecHandle& A, const struct FGameplayAbilitySpecHandle& B);
	static bool EqualEqual_GameplayAttributeGameplayAttribute(const struct FGameplayAttribute& AttributeA, const struct FGameplayAttribute& AttributeB);
	static float EvaluateAttributeValueWithTags(class UAbilitySystemComponent* AbilitySystem, const struct FGameplayAttribute& Attribute, const struct FGameplayTagContainer& SourceTags, const struct FGameplayTagContainer& TargetTags, bool* bSuccess);
	static float EvaluateAttributeValueWithTagsAndBase(class UAbilitySystemComponent* AbilitySystem, const struct FGameplayAttribute& Attribute, const struct FGameplayTagContainer& SourceTags, const struct FGameplayTagContainer& TargetTags, float BaseValue, bool* bSuccess);
	static struct FGameplayAbilityTargetDataHandle FilterTargetData(const struct FGameplayAbilityTargetDataHandle& TargetDataHandle, const struct FGameplayTargetDataFilterHandle& ActorFilterClass);
	static void ForwardGameplayCueToTarget(TScriptInterface<class IGameplayCueInterface> TargetCueInterface, EGameplayCueEvent EventType, const struct FGameplayCueParameters& Parameters);
	static const class UGameplayAbility* GetAbility(const struct FGameplayCueParameters& Parameters);
	static class UAbilitySystemComponent* GetAbilitySystemComponent(class AActor* Actor);
	static class FString GetActiveGameplayEffectDebugString(const struct FActiveGameplayEffectHandle& ActiveHandle);
	static float GetActiveGameplayEffectExpectedEndTime(const struct FActiveGameplayEffectHandle& ActiveHandle);
	static float GetActiveGameplayEffectRemainingDuration(class UObject* WorldContextObject, const struct FActiveGameplayEffectHandle& ActiveHandle);
	static int32 GetActiveGameplayEffectStackCount(const struct FActiveGameplayEffectHandle& ActiveHandle);
	static int32 GetActiveGameplayEffectStackLimitCount(const struct FActiveGameplayEffectHandle& ActiveHandle);
	static float GetActiveGameplayEffectStartTime(const struct FActiveGameplayEffectHandle& ActiveHandle);
	static float GetActiveGameplayEffectTotalDuration(const struct FActiveGameplayEffectHandle& ActiveHandle);
	static class AActor* GetActorByIndex(const struct FGameplayCueParameters& Parameters, int32 Index_0);
	static int32 GetActorCount(const struct FGameplayCueParameters& Parameters);
	static TArray<class AActor*> GetActorsFromTargetData(const struct FGameplayAbilityTargetDataHandle& TargetData, int32 Index_0);
	static TArray<class AActor*> GetAllActorsFromTargetData(const struct FGameplayAbilityTargetDataHandle& TargetData);
	static TArray<struct FGameplayEffectSpecHandle> GetAllLinkedGameplayEffectSpecHandles(const struct FGameplayEffectSpecHandle& SpecHandle);
	static int32 GetDataCountFromTargetData(const struct FGameplayAbilityTargetDataHandle& TargetData);
	static class FString GetDebugStringFromGameplayAttribute(const struct FGameplayAttribute& Attribute);
	static struct FGameplayEffectContextHandle GetEffectContext(const struct FGameplayEffectSpecHandle& SpecHandle);
	static float GetFloatAttribute(const class AActor* Actor, const struct FGameplayAttribute& Attribute, bool* bSuccessfullyFoundAttribute);
	static float GetFloatAttributeBase(const class AActor* Actor, const struct FGameplayAttribute& Attribute, bool* bSuccessfullyFoundAttribute);
	static float GetFloatAttributeBaseFromAbilitySystemComponent(const class UAbilitySystemComponent* AbilitySystemComponent, const struct FGameplayAttribute& Attribute, bool* bSuccessfullyFoundAttribute);
	static float GetFloatAttributeFromAbilitySystemComponent(const class UAbilitySystemComponent* AbilitySystem, const struct FGameplayAttribute& Attribute, bool* bSuccessfullyFoundAttribute);
	static const class UGameplayAbility* GetGameplayAbilityFromSpecHandle(class UAbilitySystemComponent* AbilitySystem, const struct FGameplayAbilitySpecHandle& AbilitySpecHandle, bool* bIsInstance);
	static bool GetGameplayCueDirection(class AActor* TargetActor, const struct FGameplayCueParameters& Parameters, struct FVector* Direction);
	static bool GetGameplayCueEndLocationAndNormal(class AActor* TargetActor, const struct FGameplayCueParameters& Parameters, struct FVector* Location, struct FVector* Normal);
	static const class UGameplayEffect* GetGameplayEffectFromActiveEffectHandle(const struct FActiveGameplayEffectHandle& ActiveHandle);
	static const class UGameplayEffectUIData* GetGameplayEffectUIData(TSubclassOf<class UGameplayEffect> EffectClass, TSubclassOf<class UGameplayEffectUIData> DataType);
	static struct FHitResult GetHitResult(const struct FGameplayCueParameters& Parameters);
	static struct FHitResult GetHitResultFromTargetData(const struct FGameplayAbilityTargetDataHandle& HitResult, int32 Index_0);
	static class AActor* GetInstigatorActor(const struct FGameplayCueParameters& Parameters);
	static struct FTransform GetInstigatorTransform(const struct FGameplayCueParameters& Parameters);
	static float GetModifiedAttributeMagnitude(const struct FGameplayEffectSpecHandle& SpecHandle, const struct FGameplayAttribute& Attribute);
	static struct FVector GetOrigin(const struct FGameplayCueParameters& Parameters);
	static struct FVector GetTargetDataDirection(const struct FGameplayAbilityTargetDataHandle& TargetData, int32 Index_0);
	static struct FVector GetTargetDataEndPoint(const struct FGameplayAbilityTargetDataHandle& TargetData, int32 Index_0);
	static struct FTransform GetTargetDataEndPointTransform(const struct FGameplayAbilityTargetDataHandle& TargetData, int32 Index_0);
	static float GetTargetDataFloat(const struct FGameplayAbilityTargetDataHandle& TargetData, int32 Index_0);
	static struct FTransform GetTargetDataOrigin(const struct FGameplayAbilityTargetDataHandle& TargetData, int32 Index_0);
	static bool HasHitResult(const struct FGameplayCueParameters& Parameters);
	static bool IsInstigatorLocallyControlled(const struct FGameplayCueParameters& Parameters);
	static bool IsInstigatorLocallyControlledPlayer(const struct FGameplayCueParameters& Parameters);
	static bool IsValid(const struct FGameplayAttribute& Attribute);
	static struct FGameplayTargetDataFilterHandle MakeFilterHandle(const struct FGameplayTargetDataFilter& Filter, class AActor* FilterActor);
	static struct FGameplayCueParameters MakeGameplayCueParameters(float NormalizedMagnitude, float RawMagnitude, EGameplayEffectDurationType DurationPolicy, float Duration, float Period, const struct FGameplayEffectContextHandle& EffectContext, const struct FGameplayTag& MatchedTagName, const struct FGameplayTag& OriginalTag, const struct FGameplayTagContainer& AggregatedSourceTags, const struct FGameplayTagContainer& AggregatedTargetTags, const struct FVector& Location, const struct FVector& Normal, class AActor* Instigator, class AActor* EffectCauser, class UObject* SourceObject, class UPhysicalMaterial* PhysicalMaterial, int32 GameplayEffectLevel, int32 AbilityLevel, class USceneComponent* TargetAttachComponent, bool bReplicateLocationWhenUsingMinimalRepProxy);
	static struct FGameplayEffectSpecHandle MakeSpecHandle(class UGameplayEffect* InGameplayEffect, class AActor* InInstigator, class AActor* InEffectCauser, float InLevel);
	static bool NotEqual_ActiveGameplayEffectHandle(const struct FActiveGameplayEffectHandle& A, const struct FActiveGameplayEffectHandle& B);
	static bool NotEqual_GameplayAbilitySpecHandle(const struct FGameplayAbilitySpecHandle& A, const struct FGameplayAbilitySpecHandle& B);
	static bool NotEqual_GameplayAttributeGameplayAttribute(const struct FGameplayAttribute& AttributeA, const struct FGameplayAttribute& AttributeB);
	static bool RemoveLooseGameplayTags(class AActor* Actor, const struct FGameplayTagContainer& GameplayTags, bool bShouldReplicate);
	static void SendGameplayEventToActor(class AActor* Actor, const struct FGameplayTag& EventTag, const struct FGameplayEventData& Payload);
	static struct FGameplayEffectSpecHandle SetDuration(const struct FGameplayEffectSpecHandle& SpecHandle, float Duration);
	static struct FGameplayEffectSpecHandle SetStackCount(const struct FGameplayEffectSpecHandle& SpecHandle, int32 StackCount);
	static struct FGameplayEffectSpecHandle SetStackCountToMax(const struct FGameplayEffectSpecHandle& SpecHandle);
	static bool TargetDataHasActor(const struct FGameplayAbilityTargetDataHandle& TargetData, int32 Index_0);
	static bool TargetDataHasEndPoint(const struct FGameplayAbilityTargetDataHandle& TargetData, int32 Index_0);
	static bool TargetDataHasHitResult(const struct FGameplayAbilityTargetDataHandle& HitResult, int32 Index_0);
	static bool TargetDataHasOrigin(const struct FGameplayAbilityTargetDataHandle& TargetData, int32 Index_0);

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("AbilitySystemBlueprintLibrary")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"AbilitySystemBlueprintLibrary")
	}
	static class UAbilitySystemBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilitySystemBlueprintLibrary>();
	}
};
DUMPER7_ASSERTS_UAbilitySystemBlueprintLibrary;

// Class GameplayAbilities.AbilitySystemComponent
// 0x3D10 (0x3EA0 - 0x0190)
class UAbilitySystemComponent : public UGameplayTasksComponent
{
public:
	uint8                                         Pad_190[0x10];                                     // 0x0190(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAttributeDefaults>             DefaultStartingData;                               // 0x01A0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   AffectedAnimInstanceTag;                           // 0x01B0(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1BC[0x224];                                    // 0x01BC(0x0224)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OutgoingDuration;                                  // 0x03E0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IncomingDuration;                                  // 0x03E4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E8[0x68];                                     // 0x03E8(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         ClientDebugStrings;                                // 0x0450(0x0010)(Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPublic)
	TArray<class FString>                         ServerDebugStrings;                                // 0x0460(0x0010)(Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPublic)
	bool                                          UserAbilityActivationInhibited;                    // 0x0470(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReplicationProxyEnabled;                           // 0x0471(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSuppressGrantAbility;                             // 0x0472(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSuppressGameplayCues;                             // 0x0473(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_474[0x4];                                      // 0x0474(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AGameplayAbilityTargetActor*>    SpawnedTargetActors;                               // 0x0478(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_488[0x48];                                     // 0x0488(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(const class UAnimTimeline* AnimTimeline)> OnTimelineStartPlaying;  // 0x04D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const class UAnimTimeline* AnimTimeline)> OnTimelineStopPlaying;   // 0x04E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_4F0[0x8];                                      // 0x04F0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 OwnerActor;                                        // 0x04F8(0x0008)(Net, ZeroConstructor, RepNotify, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                 AvatarActor;                                       // 0x0500(0x0008)(Net, ZeroConstructor, RepNotify, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_508[0x130];                                    // 0x0508(0x0130)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPredictionKey                         ScopedPredictionKey;                               // 0x0638(0x0070)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6A8[0x4A0];                                    // 0x06A8(0x04A0)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayAbilitySpecContainer          ActivatableAbilities;                              // 0x0B48(0x0128)(BlueprintVisible, BlueprintReadOnly, Net, Transient, RepNotify, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_C70[0x20];                                     // 0x0C70(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, class AActor*>            AbilityTargetActorMap;                             // 0x0C90(0x0050)(Protected, NativeAccessSpecifierProtected)
	TMap<class FString, class AActor*>            AbilityReplicatedTargetActorMap;                   // 0x0CE0(0x0050)(Protected, NativeAccessSpecifierProtected)
	TArray<class FString>                         AbilityReplicatedTargetActorSpawnKey;              // 0x0D30(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_D40[0x10];                                     // 0x0D40(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UGameplayAbility*>               AllReplicatedInstancedAbilities;                   // 0x0D50(0x0010)(ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_D60[0x7D0];                                    // 0x0D60(0x07D0)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayAbilityRepAnimMontage         RepAnimMontageInfo;                                // 0x1530(0x0128)(Net, RepNotify, Protected, NativeAccessSpecifierProtected)
	struct FGameplayAbilityMultiRepAnimTimeline   RepMultiAnimTimelineInfo;                          // 0x1658(0x0120)(Net, RepNotify, Protected, NativeAccessSpecifierProtected)
	bool                                          bCachedIsNetSimulated;                             // 0x1778(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPendingMontageRep;                                // 0x1779(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_177A[0x6];                                     // 0x177A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayAbilityLocalAnimMontage       LocalAnimMontageInfo;                              // 0x1780(0x0028)(Protected, NativeAccessSpecifierProtected)
	struct FGameplayAbilityMultiLocalAnimTimeline LocalMultiAnimTimelineInfo;                        // 0x17A8(0x0010)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_17B8[0xA0];                                    // 0x17B8(0x00A0)(Fixing Size After Last Property [ Dumper-7 ])
	struct FActiveGameplayEffectsContainer        ActiveGameplayEffects;                             // 0x1858(0x1898)(Net, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_30F0[0x8];                                     // 0x30F0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FActiveGameplayCueContainer            ActiveGameplayCues;                                // 0x30F8(0x0140)(Net, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FActiveGameplayCueContainer            MinimalReplicationGameplayCues;                    // 0x3238(0x0140)(Net, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_3378[0x218];                                   // 0x3378(0x0218)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMinimalReplicationTagCountMap         MinimalBlockedAbilityTags;                         // 0x3590(0x00B8)(Net, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<uint8>                                 BlockedAbilityBindings;                            // 0x3648(0x0010)(Net, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_3658[0x220];                                   // 0x3658(0x0220)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMinimalReplicationTagCountMap         MinimalReplicationTags;                            // 0x3878(0x00B8)(Net, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UAttributeSet*>                  SpawnedAttributes;                                 // 0x3930(0x0010)(ExportObject, Net, ZeroConstructor, Transient, RepNotify, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3940[0x20];                                    // 0x3940(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMinimalReplicationTagCountMap         ReplicatedLooseTags;                               // 0x3960(0x00B8)(Net, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FMinimalReplicationTagCountMap         ReplicatedLooseTags_SkipOwner;                     // 0x3A18(0x00B8)(Net, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class FString>                         PredictGameplayTagKeys;                            // 0x3AD0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3AE0[0x8];                                     // 0x3AE0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FReplicatedPredictionKeyMap            ReplicatedPredictionKeyMap;                        // 0x3AE8(0x0128)(Net, Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C10[0x30];                                    // 0x3C10(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAbilityActivationExtraInfo            PendingActivationExtraInfo;                        // 0x3C40(0x0038)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C78[0xD0];                                    // 0x3C78(0x00D0)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMinimalReplicationTagOperationContainer TagOperationContainer;                           // 0x3D48(0x0128)(Net, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	bool                                          IsImportantLog;                                    // 0x3E70(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E71[0x7];                                     // 0x3E71(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UGameplayAbilityDataSet*>        AllReplicatedDataSets;                             // 0x3E78(0x0010)(ZeroConstructor, Transient, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<class UGameplayAbilityDataSet*>        NonReplicatedDataSets;                             // 0x3E88(0x0010)(ZeroConstructor, Transient, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	bool                                          bShouldRepGameplayEffects;                         // 0x3E98(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldRepPredictionKeyMap;                        // 0x3E99(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E9A[0x6];                                     // 0x3E9A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddGameplayTag_Predict(const struct FGameplayTag& GameplayTag, const int32 Count);
	void AddGameplayTags_Predict(const struct FGameplayTagContainer& GameplayTags);
	struct FActiveGameplayEffectHandle BP_ApplyGameplayEffectSpecToSelf(const struct FGameplayEffectSpecHandle& SpecHandle);
	struct FActiveGameplayEffectHandle BP_ApplyGameplayEffectSpecToTarget(const struct FGameplayEffectSpecHandle& SpecHandle, class UAbilitySystemComponent* Target);
	struct FActiveGameplayEffectHandle BP_ApplyGameplayEffectToSelf(TSubclassOf<class UGameplayEffect> GameplayEffectClass, float Level, const struct FGameplayEffectContextHandle& EffectContext);
	struct FActiveGameplayEffectHandle BP_ApplyGameplayEffectToTarget(TSubclassOf<class UGameplayEffect> GameplayEffectClass, class UAbilitySystemComponent* Target, float Level, const struct FGameplayEffectContextHandle& Context);
	bool CheckScopedPredicitionKeyReject(bool bCallReject);
	void ClearAbility(const struct FGameplayAbilitySpecHandle& Handle);
	void ClearAllAbilities();
	void ClearAllAbilitiesWithInputID(int32 InputID);
	void ClientActivateAbilityFailed(const struct FGameplayAbilitySpecHandle& AbilityToActivate, const class FString& PredictionKey, const struct FGameplayTagContainer& FailureTags);
	void ClientActivateAbilitySucceed(const struct FGameplayAbilitySpecHandle& AbilityToActivate, const struct FPredictionKey& PredictionKey);
	void ClientActivateAbilitySucceedWithEventData(const struct FGameplayAbilitySpecHandle& AbilityToActivate, const struct FPredictionKey& PredictionKey, const struct FGameplayEventData& TriggerEventData);
	void ClientCancelAbility(const struct FGameplayAbilitySpecHandle& AbilityToCancel, const struct FGameplayAbilityActivationInfo& ActivationInfo, const struct FAbilityEndContext& EndContext);
	void ClientCatchUpPredictionKey(const class FString& PredictionKey);
	void ClientEndAbility(const struct FGameplayAbilitySpecHandle& AbilityToEnd, const struct FGameplayAbilityActivationInfo& ActivationInfo, const struct FAbilityEndContext& EndContext);
	void ClientInternalReboot_Dynamic(const struct FPredictionKey& PredictionKey, const struct FPredictionDynamicParamHandle& Handle);
	void ClientInternalRebootChannel_Dynamic(const struct FPredictionKey& PredictionKey, const struct FPredictionDynamicParamHandle& Handle);
	void ClientPrintDebug_Response(const TArray<class FString>& Strings, int32 GameFlags);
	void ClientReceivePredictionKey(const struct FPredictionKey& Key);
	void ClientRejectPredictionKey(const class FString& PredictionKey);
	void ClientTestReplicateData(const struct FPredictionKey& Key);
	void ClientTryActivateAbility(const struct FGameplayAbilitySpecHandle& AbilityToActivate);
	void ExecuteGameplayCue(const struct FGameplayTag& GameplayCueTag, const struct FGameplayCueParameters& GameplayCueParameters);
	class UGameplayAbilityDataSet* GetAbilityDataSetForAbility(const class UGameplayAbility* Ability);
	class UGameplayAbilityDataSet* GetAbilityDataSetForAbilityID(int32 AbilityID);
	class UGameplayAbilityDataSet* GetAbilityDataSetForClass(const TSubclassOf<class UGameplayAbilityDataSet>& InClass);
	class UGameplayAbilityDataSet* GetAbilityDataSetForSpecHandle(const struct FGameplayAbilitySpecHandle& Handle);
	void GetAllAttributes(TArray<struct FGameplayAttribute>* OutAttributes);
	void HandleGameplayCue(const struct FGameplayTag& GameplayCueTag, EGameplayCueEvent EventType, const struct FGameplayCueParameters& Parameters);
	void InputCancel(int32 InputID);
	void InputConfirm(int32 InputID);
	bool IsImmunityEffect_EffectTags(const struct FGameplayTagContainer& EffectTags);
	struct FGameplayAbilitySpecHandle K2_GiveAbility(TSubclassOf<class UGameplayAbility> AbilityClass, int32 Level, int32 InputID);
	struct FGameplayAbilitySpecHandle K2_GiveAbilityAndActivateOnce(TSubclassOf<class UGameplayAbility> AbilityClass, int32 Level, int32 InputID);
	void K2_InitStats(TSubclassOf<class UAttributeSet> Attributes, const class UDataTable* DataTable);
	void KeepAbilityRootKeyAsExpiredPredictionKey(class UGameplayAbility* Ability, bool bWasCancelled);
	void KeepExpiredPredictionKey(const class FString& Key);
	void KeepExpiredRootPredictionKey(const class FString& Key);
	void MulticastInvokeSimpleCueAddEvent(const struct FSimpleApplyEffectParam& SimpleAGE);
	void MulticastInvokeSimpleCueRemoveEvent(const struct FSimpleApplyEffectParam& SimpleAGE);
	void MulticastOnAddGameplayEffect_InitOnly(const struct FActiveGameplayEffect& NewActiveGE);
	void MulticastOnAddGameplayEffect_SimpleApply(const struct FSimpleApplyEffectParam& SimpleAGE);
	void MulticastOnChangeGameplayEffect_InitOnly(const struct FActiveGameplayEffect& ChangedActiveGE);
	void MulticastOnChangeGameplayEffect_SimpleApply(const struct FSimpleApplyEffectParam& SimpleAGE);
	void MulticastOnRemoveGameplayEffect_InitOnly(const struct FActiveGameplayEffectHandle& RepHandle);
	void MulticastOnRemoveGameplayEffect_SimpleApply(const struct FActiveGameplayEffectHandle& RepHandle);
	void NetMulticast_InvokeGameplayCueAdded(const struct FGameplayTag& GameplayCueTag, const struct FPredictionKey& PredictionKey, const struct FGameplayEffectContextHandle& EffectContext);
	void NetMulticast_InvokeGameplayCueAdded_WithParams(const struct FGameplayTag& GameplayCueTag, const struct FPredictionKey& PredictionKey, const struct FGameplayCueParameters& Parameters);
	void NetMulticast_InvokeGameplayCueAddedAndWhileActive_FromSpec(const struct FGameplayEffectSpecForRPC& Spec, const struct FPredictionKey& PredictionKey);
	void NetMulticast_InvokeGameplayCueAddedAndWhileActive_WithParams(const struct FGameplayTag& GameplayCueTag, const struct FPredictionKey& PredictionKey, const struct FGameplayCueParameters& GameplayCueParameters);
	void NetMulticast_InvokeGameplayCueExecuted(const struct FGameplayTag& GameplayCueTag, const struct FPredictionKey& PredictionKey, const struct FGameplayEffectContextHandle& EffectContext);
	void NetMulticast_InvokeGameplayCueExecuted_FromSpec(const struct FGameplayEffectSpecForRPC& Spec, const struct FPredictionKey& PredictionKey);
	void NetMulticast_InvokeGameplayCueExecuted_WithParams(const struct FGameplayTag& GameplayCueTag, const struct FPredictionKey& PredictionKey, const struct FGameplayCueParameters& GameplayCueParameters);
	void NetMulticast_InvokeGameplayCuesAddedAndWhileActive_WithParams(const struct FGameplayTagContainer& GameplayCueTags, const struct FPredictionKey& PredictionKey, const struct FGameplayCueParameters& GameplayCueParameters);
	void NetMulticast_InvokeGameplayCuesExecuted(const struct FGameplayTagContainer& GameplayCueTags, const struct FPredictionKey& PredictionKey, const struct FGameplayEffectContextHandle& EffectContext);
	void NetMulticast_InvokeGameplayCuesExecuted_WithParams(const struct FGameplayTagContainer& GameplayCueTags, const struct FPredictionKey& PredictionKey, const struct FGameplayCueParameters& GameplayCueParameters);
	void NetMulticast_ReplicationActivatableAbilities(const struct FGameplayAbilitySpec& Spec, uint8 operation);
	void OnAvatarActorDestroyed(class AActor* InActor);
	void OnOwnerActorDestroyed(class AActor* InActor);
	void OnPredictionKeyRejected(const class FString& Key);
	void OnRep_ActivateAbilities();
	void OnRep_ClientDebugString();
	void OnRep_OwningActor();
	void OnRep_ReplicatedAnimMontage();
	void OnRep_ReplicatedAnimTimeline();
	void OnRep_ServerDebugString();
	void OnRep_SpawnedAttributes(const TArray<class UAttributeSet*>& PreviousSpawnedAttributes);
	void OnSpawnedAttributesEndPlayed(class AActor* InActor, EEndPlayReason EndPlayReason);
	void PressInputID(int32 InputID);
	void ReleaseInputID(int32 InputID);
	int32 RemoveActiveEffectsWithAppliedTags(const struct FGameplayTagContainer& Tags);
	int32 RemoveActiveEffectsWithGrantedTagRequirements(const struct FGameplayTagRequirements& TagRequirements);
	int32 RemoveActiveEffectsWithGrantedTags(const struct FGameplayTagContainer& Tags);
	int32 RemoveActiveEffectsWithSourceTags(const struct FGameplayTagContainer& Tags);
	int32 RemoveActiveEffectsWithTags(const struct FGameplayTagContainer& Tags);
	bool RemoveActiveGameplayEffect(const struct FActiveGameplayEffectHandle& Handle, int32 StacksToRemove);
	void RemoveActiveGameplayEffectBySourceEffect(TSubclassOf<class UGameplayEffect> GameplayEffect, class UAbilitySystemComponent* InstigatorAbilitySystemComponent, int32 StacksToRemove);
	void RemoveGameplayTag_Predict(const struct FGameplayTag& GameplayTag, const int32 Count);
	void RemoveGameplayTags_Predict(const struct FGameplayTagContainer& GameplayTags);
	void ResetDuration(const struct FActiveGameplayEffectHandle& Handle, const float InDuration);
	void ServerCancelAbility(const struct FGameplayAbilitySpecHandle& AbilityToCancel, const struct FGameplayAbilityActivationInfo& ActivationInfo, const struct FAbilityEndContext& EndContext);
	void ServerCatchUpOperation(const struct FMinimalReplicationTagOperation& InOperation);
	void ServerCurrentMontageJumpToSectionName(class UAnimMontage* ClientAnimMontage, class FName SectionName);
	void ServerCurrentMontageSetNextSectionName(class UAnimMontage* ClientAnimMontage, float ClientPosition, class FName SectionName, class FName NextSectionName);
	void ServerCurrentMontageSetPlayRate(class UAnimMontage* ClientAnimMontage, float InPlayRate);
	void ServerCurrentTimelineSetPlayRate(class UAnimTimeline* Timeline, float InPlayRate);
	void ServerEndAbility(const struct FGameplayAbilitySpecHandle& AbilityToEnd, const struct FGameplayAbilityActivationInfo& ActivationInfo, const struct FPredictionKey& PredictionKey, const struct FAbilityEndContext& EndContext);
	void ServerInternalOfferData_Dynamic(const struct FPredictionKey& PredictionKey, float ValidTime, const struct FPredictionDynamicParamHandle& Handle);
	void ServerInternalReboot_Dynamic(const struct FPredictionKey& PredictionKey, const struct FPredictionDynamicParamHandle& Handle);
	void ServerInternalRebootChannel_Dynamic(const struct FPredictionKey& PredictionKey, const struct FPredictionDynamicParamHandle& Handle);
	void ServerPrintDebug_Request();
	void ServerPrintDebug_RequestWithStrings(const TArray<class FString>& Strings);
	void ServerTestDynamicParamHandle(const struct FPredictionDynamicParamHandle& Handle);
	void ServerTryActivateAbility(const struct FGameplayAbilitySpecHandle& AbilityToActivate, bool InputPressed, const struct FPredictionKey& PredictionKey, const struct FAbilityActivationExtraInfo& InActivationInfo);
	void ServerTryActivateAbilityWithEventData(const struct FGameplayAbilitySpecHandle& AbilityToActivate, bool InputPressed, const struct FPredictionKey& PredictionKey, const struct FGameplayEventData& TriggerEventData, const struct FAbilityActivationExtraInfo& InActivationInfo);
	void ServerVerifyPredictionKeys(const TArray<class FString>& Keys);
	void SetActiveGameplayEffectLevel(const struct FActiveGameplayEffectHandle& ActiveHandle, int32 NewLevel);
	void SetActiveGameplayEffectLevelUsingQuery(const struct FGameplayEffectQuery& Query, int32 NewLevel);
	void SetMontageRepAnimPositionMethod(ERepAnimPositionMethod InMethod);
	void SetUserAbilityActivationInhibited(bool NewInhibit);
	void TestDynamicRPC();
	void TestFunction(int32 Data1, const TArray<struct FHitResult>& Data2, const struct FHitResult& Data3, const class FString& Data4, class FName Data5);
	void TestFunction2(const struct FHitResult& Data1, const class FString& Data2, int32 Data3, const TArray<struct FHitResult>& Data4, class FName Data5);
	void TestFunction3(int32 Data1, const TArray<struct FHitResult>& Data2, const struct FHitResult& Data3, const class FString& Data4);
	void TestOfferDataCallback(const struct FPredictionDynamicParamHandle& LocalHandle, const struct FPredictionDynamicParamHandle& RemoteHandle);
	void TickUpdatePredictionKey();
	bool TryActivateAbilitiesByTag(const struct FGameplayTagContainer& GameplayTagContainer, bool bAllowRemoteActivation);
	bool TryActivateAbility(const struct FGameplayAbilitySpecHandle& AbilityToActivate, bool bAllowRemoteActivation);
	bool TryActivateAbilityByClass(TSubclassOf<class UGameplayAbility> InAbilityToActivate, bool bAllowRemoteActivation);
	void UpdateActiveGameplayEffectSetByCallerMagnitude(const struct FActiveGameplayEffectHandle& ActiveHandle, const struct FGameplayTag& SetByCallerTag, float NewValue);
	void UpdateActiveGameplayEffectSetByCallerMagnitudes(const struct FActiveGameplayEffectHandle& ActiveHandle, const TMap<struct FGameplayTag, float>& NewSetByCallerValues);

	void FindAllAbilitiesMatchingQuery(TArray<struct FGameplayAbilitySpecHandle>* OutAbilityHandles, const struct FGameplayTagQuery& Query) const;
	void FindAllAbilitiesWithInputID(TArray<struct FGameplayAbilitySpecHandle>* OutAbilityHandles, int32 InputID) const;
	void FindAllAbilitiesWithTags(TArray<struct FGameplayAbilitySpecHandle>* OutAbilityHandles, const struct FGameplayTagContainer& Tags, bool bExactMatch) const;
	float GetAbilityActivateDelayTime(const class FString& InActivationKey) const;
	TArray<struct FActiveGameplayEffectHandle> GetActiveEffects(const struct FGameplayEffectQuery& Query) const;
	TArray<struct FActiveGameplayEffectHandle> GetActiveEffectsWithAllTags(const struct FGameplayTagContainer& Tags) const;
	void GetAllAbilities(TArray<struct FGameplayAbilitySpecHandle>* OutAbilityHandles) const;
	const class UAttributeSet* GetAttributeSet(TSubclassOf<class UAttributeSet> AttributeSetClass) const;
	float GetCurrentAbilityActivateDelayTime() const;
	float GetGameplayAttributeValue(const struct FGameplayAttribute& Attribute, bool* bFound) const;
	int32 GetGameplayEffectCount(TSubclassOf<class UGameplayEffect> SourceGameplayEffect, class UAbilitySystemComponent* OptionalInstigatorFilterComponent, bool bEnforceOnGoingCheck) const;
	int32 GetGameplayEffectCount_IfLoaded(TSoftClassPtr<class UClass> SoftSourceGameplayEffect, class UAbilitySystemComponent* OptionalInstigatorFilterComponent, bool bEnforceOnGoingCheck) const;
	float GetGameplayEffectMagnitude(const struct FActiveGameplayEffectHandle& Handle, const struct FGameplayAttribute& Attribute) const;
	int32 GetGameplayTagCount(const struct FGameplayTag& GameplayTag) const;
	class FString GetKeyDebugString(const class FString& InKey) const;
	bool GetUserAbilityActivationInhibited() const;
	bool IsForRemoteClient() const;
	bool IsForRunAlone() const;
	bool IsGameplayCueActive(const struct FGameplayTag& GameplayCueTag) const;
	bool IsLocallyControlled() const;
	bool IsNetAuthority() const;
	bool IsPredictingClient() const;
	struct FGameplayEffectContextHandle MakeEffectContext() const;
	struct FGameplayEffectSpecHandle MakeOutgoingSpec(TSubclassOf<class UGameplayEffect> GameplayEffectClass, float Level, const struct FGameplayEffectContextHandle& Context) const;

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("AbilitySystemComponent")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"AbilitySystemComponent")
	}
	static class UAbilitySystemComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilitySystemComponent>();
	}
};
DUMPER7_ASSERTS_UAbilitySystemComponent;

// Class GameplayAbilities.AbilitySystemDebugHUDExtension
// 0x0000 (0x0030 - 0x0030)
class UAbilitySystemDebugHUDExtension : public UObject
{
public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("AbilitySystemDebugHUDExtension")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"AbilitySystemDebugHUDExtension")
	}
	static class UAbilitySystemDebugHUDExtension* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilitySystemDebugHUDExtension>();
	}
};
DUMPER7_ASSERTS_UAbilitySystemDebugHUDExtension;

// Class GameplayAbilities.AbilitySystemDebugHUDExtension_Tags
// 0x0058 (0x0088 - 0x0030)
class UAbilitySystemDebugHUDExtension_Tags final : public UAbilitySystemDebugHUDExtension
{
public:
	uint8                                         Pad_30[0x58];                                      // 0x0030(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("AbilitySystemDebugHUDExtension_Tags")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"AbilitySystemDebugHUDExtension_Tags")
	}
	static class UAbilitySystemDebugHUDExtension_Tags* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilitySystemDebugHUDExtension_Tags>();
	}
};
DUMPER7_ASSERTS_UAbilitySystemDebugHUDExtension_Tags;

// Class GameplayAbilities.AbilitySystemDebugHUDExtension_Attributes
// 0x0058 (0x0088 - 0x0030)
class UAbilitySystemDebugHUDExtension_Attributes final : public UAbilitySystemDebugHUDExtension
{
public:
	uint8                                         Pad_30[0x58];                                      // 0x0030(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("AbilitySystemDebugHUDExtension_Attributes")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"AbilitySystemDebugHUDExtension_Attributes")
	}
	static class UAbilitySystemDebugHUDExtension_Attributes* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilitySystemDebugHUDExtension_Attributes>();
	}
};
DUMPER7_ASSERTS_UAbilitySystemDebugHUDExtension_Attributes;

// Class GameplayAbilities.AbilitySystemDebugHUDExtension_BlockedAbilityTags
// 0x0058 (0x0088 - 0x0030)
class UAbilitySystemDebugHUDExtension_BlockedAbilityTags final : public UAbilitySystemDebugHUDExtension
{
public:
	uint8                                         Pad_30[0x58];                                      // 0x0030(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("AbilitySystemDebugHUDExtension_BlockedAbilityTags")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"AbilitySystemDebugHUDExtension_BlockedAbilityTags")
	}
	static class UAbilitySystemDebugHUDExtension_BlockedAbilityTags* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilitySystemDebugHUDExtension_BlockedAbilityTags>();
	}
};
DUMPER7_ASSERTS_UAbilitySystemDebugHUDExtension_BlockedAbilityTags;

// Class GameplayAbilities.AbilitySystemGlobals
// 0x0678 (0x06A8 - 0x0030)
class UAbilitySystemGlobals : public UObject
{
public:
	struct FSoftClassPath                         AbilitySystemGlobalsClassName;                     // 0x0030(0x0028)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         MagnitudeDiffusionClassName;                       // 0x0058(0x0028)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_80[0x28];                                      // 0x0080(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bUseDebugTargetFromHud;                            // 0x00A8(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AbilitySupportSimulation;                          // 0x00A9(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AA[0x1EE];                                     // 0x00AA(0x01EE)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           ActivateFailIsDeadTag;                             // 0x0298(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ActivateFailIsDeadName;                            // 0x02A4(0x000C)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ActivateFailActivateIntervalTag;                   // 0x02B0(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ActivateFailActivateIntervalName;                  // 0x02BC(0x000C)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ActivateFailCooldownTag;                           // 0x02C8(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ActivateFailCooldownName;                          // 0x02D4(0x000C)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ActivateFailCostTag;                               // 0x02E0(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ActivateFailCostName;                              // 0x02EC(0x000C)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ActivateFailTagsBlockedTag;                        // 0x02F8(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ActivateFailTagsBlockedName;                       // 0x0304(0x000C)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ActivateFailTagsMissingTag;                        // 0x0310(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ActivateFailTagsMissingName;                       // 0x031C(0x000C)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ActivateFailNetworkingTag;                         // 0x0328(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ActivateFailNetworkingName;                        // 0x0334(0x000C)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           SimulatedCanActiveTag;                             // 0x0340(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SimulatedCanActiveName;                            // 0x034C(0x000C)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinimalReplicationTagCountBits;                    // 0x0358(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ActivateFailRetryTag;                              // 0x035C(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ActivateFailRetryName;                             // 0x0368(0x000C)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ActivateFailHasActiveInstanceTag;                  // 0x0374(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ActivateFailHasActiveInstanceName;                 // 0x0380(0x000C)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxForceEndByRemoteTime_Server;                    // 0x038C(0x0004)(BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxForceEndByRemoteTime_Client;                    // 0x0390(0x0004)(BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ForceEndByRemoteMutableAddedTime;                  // 0x0394(0x0004)(BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxForceEndByRemoteMutableTime;                    // 0x0398(0x0004)(BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ForceEndByRemoteMutableTimeRecoverSpeed;           // 0x039C(0x0004)(BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxActivationBufferWaitTime;                       // 0x03A0(0x0004)(BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxActivationBufferWaitingCancelTime;              // 0x03A4(0x0004)(BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxActivationBufferWaitingRetryTime;               // 0x03A8(0x0004)(BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxActivationBufferSize;                           // 0x03AC(0x0004)(BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ServerDashStopWaitData_Hit;                        // 0x03B0(0x0004)(BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ServerDashStopWaitData_Other;                      // 0x03B4(0x0004)(BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNoCancelByServerAbilityInClient;                  // 0x03B8(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNoCancelByBuffInClient;                           // 0x03B9(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNoEnterBufferIfBlockedByServerBuff;               // 0x03BA(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3BB[0x5];                                      // 0x03BB(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FNetSerializeScriptStructCache         TargetDataStructCache;                             // 0x03C0(0x0010)(NativeAccessSpecifierPublic)
	struct FNetSerializeScriptStructCache         EffectContextStructCache;                          // 0x03D0(0x0010)(NativeAccessSpecifierPublic)
	bool                                          bAllowGameplayModEvaluationChannels;               // 0x03E0(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EGameplayModEvaluationChannel                 DefaultGameplayModEvaluationChannel;               // 0x03E1(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3E2[0x2];                                      // 0x03E2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   GameplayModEvaluationChannelAliases[0xA];          // 0x03E4(0x000C)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_45C[0x4];                                      // 0x045C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        GlobalCurveTableName;                              // 0x0460(0x0028)(ZeroConstructor, Config, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveTable*                            GlobalCurveTable;                                  // 0x0488(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSoftObjectPath                        GlobalAttributeMetaDataTableName;                  // 0x0490(0x0028)(ZeroConstructor, Config, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             GlobalAttributeMetaDataTable;                      // 0x04B8(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSoftObjectPath                        GlobalAttributeSetDefaultsTableName;               // 0x04C0(0x0028)(ZeroConstructor, Config, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FSoftObjectPath>                GlobalAttributeSetDefaultsTableNames;              // 0x04E8(0x0010)(ZeroConstructor, Config, Protected, NativeAccessSpecifierProtected)
	TArray<class UCurveTable*>                    GlobalAttributeDefaultsTables;                     // 0x04F8(0x0010)(ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	struct FSoftObjectPath                        GlobalGameplayCueManagerClass;                     // 0x0508(0x0028)(ZeroConstructor, Config, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSoftObjectPath                        GlobalGameplayCueManagerName;                      // 0x0530(0x0028)(ZeroConstructor, Config, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class FString>                         GameplayCueNotifyPaths;                            // 0x0558(0x0010)(ZeroConstructor, Config, Protected, NativeAccessSpecifierProtected)
	int32                                         MaxCueActorsToPreAllocate;                         // 0x0568(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_56C[0x4];                                      // 0x056C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        GameplayTagResponseTableName;                      // 0x0570(0x0028)(ZeroConstructor, Config, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGameplayTagReponseTable*               GameplayTagResponseTable;                          // 0x0598(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5A0[0x1];                                      // 0x05A0(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          PredictTargetGameplayEffects;                      // 0x05A1(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          ReplicateActivationOwnedTags;                      // 0x05A2(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5A3[0x5];                                      // 0x05A3(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class UGameplayCueManager*                    GlobalGameplayCueManager;                          // 0x05A8(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5B0[0x40];                                     // 0x05B0(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UObject*>                        ReferencedObjects;                                 // 0x05F0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TMap<struct FObjectPoolKey, struct FObjectPoolItems> Pools;                                      // 0x0600(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_650[0x58];                                     // 0x0650(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ResetIgnoreCooldownAndCost();

	int32 GetIgnoreCostsMode() const;
	bool ShouldIgnoreCooldowns() const;
	bool ShouldIgnoreCosts() const;

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("AbilitySystemGlobals")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"AbilitySystemGlobals")
	}
	static class UAbilitySystemGlobals* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilitySystemGlobals>();
	}
};
DUMPER7_ASSERTS_UAbilitySystemGlobals;

// Class GameplayAbilities.AbilitySystemInterface
// 0x0000 (0x0000 - 0x0000)
class IAbilitySystemInterface final
{
public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("AbilitySystemInterface")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"AbilitySystemInterface")
	}
	static class IAbilitySystemInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IAbilitySystemInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
DUMPER7_ASSERTS_IAbilitySystemInterface;

// Class GameplayAbilities.AbilitySystemReplicationProxyInterface
// 0x0000 (0x0000 - 0x0000)
class IAbilitySystemReplicationProxyInterface final
{
public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("AbilitySystemReplicationProxyInterface")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"AbilitySystemReplicationProxyInterface")
	}
	static class IAbilitySystemReplicationProxyInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IAbilitySystemReplicationProxyInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
DUMPER7_ASSERTS_IAbilitySystemReplicationProxyInterface;

// Class GameplayAbilities.AttributeSet
// 0x0008 (0x0038 - 0x0030)
class UAttributeSet : public UObject
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("AttributeSet")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"AttributeSet")
	}
	static class UAttributeSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAttributeSet>();
	}
};
DUMPER7_ASSERTS_UAttributeSet;

// Class GameplayAbilities.AbilitySystemTestAttributeSet
// 0x0048 (0x0080 - 0x0038)
class UAbilitySystemTestAttributeSet final : public UAttributeSet
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxHealth;                                         // 0x0040(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Health;                                            // 0x0044(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Mana;                                              // 0x0048(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxMana;                                           // 0x004C(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Damage;                                            // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpellDamage;                                       // 0x0054(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PhysicalDamage;                                    // 0x0058(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CritChance;                                        // 0x005C(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CritMultiplier;                                    // 0x0060(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ArmorDamageReduction;                              // 0x0064(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DodgeChance;                                       // 0x0068(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LifeSteal;                                         // 0x006C(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Strength;                                          // 0x0070(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StackingAttribute1;                                // 0x0074(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StackingAttribute2;                                // 0x0078(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NoStackAttribute;                                  // 0x007C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("AbilitySystemTestAttributeSet")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"AbilitySystemTestAttributeSet")
	}
	static class UAbilitySystemTestAttributeSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilitySystemTestAttributeSet>();
	}
};
DUMPER7_ASSERTS_UAbilitySystemTestAttributeSet;

// Class GameplayAbilities.AbilitySystemTestPawn
// 0x0020 (0x07C0 - 0x07A0)
class AAbilitySystemTestPawn final : public ADefaultPawn
{
public:
	uint8                                         Pad_798[0x18];                                     // 0x0798(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UAbilitySystemComponent*                AbilitySystemComponent;                            // 0x07B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7B8[0x8];                                      // 0x07B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("AbilitySystemTestPawn")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"AbilitySystemTestPawn")
	}
	static class AAbilitySystemTestPawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAbilitySystemTestPawn>();
	}
};
DUMPER7_ASSERTS_AAbilitySystemTestPawn;

// Class GameplayAbilities.AnimNotify_GameplayCue
// 0x0010 (0x0050 - 0x0040)
class UAnimNotify_GameplayCue final : public UAnimNotify
{
public:
	struct FGameplayCueTag                        GameplayCue;                                       // 0x0040(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("AnimNotify_GameplayCue")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"AnimNotify_GameplayCue")
	}
	static class UAnimNotify_GameplayCue* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_GameplayCue>();
	}
};
DUMPER7_ASSERTS_UAnimNotify_GameplayCue;

// Class GameplayAbilities.AnimNotify_GameplayCueState
// 0x0010 (0x0048 - 0x0038)
class UAnimNotify_GameplayCueState final : public UAnimNotifyState
{
public:
	struct FGameplayCueTag                        GameplayCue;                                       // 0x0038(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("AnimNotify_GameplayCueState")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"AnimNotify_GameplayCueState")
	}
	static class UAnimNotify_GameplayCueState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_GameplayCueState>();
	}
};
DUMPER7_ASSERTS_UAnimNotify_GameplayCueState;

// Class GameplayAbilities.GameplayAbilityBlueprint
// 0x0000 (0x00B0 - 0x00B0)
class UGameplayAbilityBlueprint final : public UBlueprint
{
public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("GameplayAbilityBlueprint")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"GameplayAbilityBlueprint")
	}
	static class UGameplayAbilityBlueprint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayAbilityBlueprint>();
	}
};
DUMPER7_ASSERTS_UGameplayAbilityBlueprint;

// Class GameplayAbilities.AbilityAsyncDataOwnerInterface
// 0x0000 (0x0000 - 0x0000)
class IAbilityAsyncDataOwnerInterface final
{
public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("AbilityAsyncDataOwnerInterface")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"AbilityAsyncDataOwnerInterface")
	}
	static class IAbilityAsyncDataOwnerInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IAbilityAsyncDataOwnerInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
DUMPER7_ASSERTS_IAbilityAsyncDataOwnerInterface;

// Class GameplayAbilities.GameplayCueFunctionLibrary
// 0x0000 (0x0030 - 0x0030)
class UGameplayCueFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void AddGameplayCueOnActor(class AActor* Target, const struct FGameplayTag& GameplayCueTag, const struct FGameplayCueParameters& Parameters);
	static void ExecuteGameplayCueOnActor(class AActor* Target, const struct FGameplayTag& GameplayCueTag, const struct FGameplayCueParameters& Parameters);
	static struct FGameplayCueParameters MakeGameplayCueParametersFromHitResult(const struct FHitResult& HitResult);
	static void RemoveGameplayCueOnActor(class AActor* Target, const struct FGameplayTag& GameplayCueTag, const struct FGameplayCueParameters& Parameters);

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("GameplayCueFunctionLibrary")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"GameplayCueFunctionLibrary")
	}
	static class UGameplayCueFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayCueFunctionLibrary>();
	}
};
DUMPER7_ASSERTS_UGameplayCueFunctionLibrary;

// Class GameplayAbilities.GameplayCueInterface
// 0x0000 (0x0000 - 0x0000)
class IGameplayCueInterface final
{
public:
	void BlueprintCustomHandler(EGameplayCueEvent EventType, const struct FGameplayCueParameters& Parameters);
	void ForwardGameplayCueToParent();

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("GameplayCueInterface")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"GameplayCueInterface")
	}
	static class IGameplayCueInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IGameplayCueInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
DUMPER7_ASSERTS_IGameplayCueInterface;

// Class GameplayAbilities.GameplayCueManager
// 0x0310 (0x0348 - 0x0038)
class UGameplayCueManager : public UDataAsset
{
public:
	uint8                                         Pad_38[0x18];                                      // 0x0038(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayCueObjectLibrary              RuntimeGameplayCueObjectLibrary;                   // 0x0050(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FGameplayCueObjectLibrary              EditorGameplayCueObjectLibrary;                    // 0x00A0(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_F0[0x1F8];                                     // 0x00F0(0x01F8)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UObject>>            LoadedGameplayCueNotifyClasses;                    // 0x02E8(0x0010)(ZeroConstructor, Transient, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<TSubclassOf<class AGameplayCueNotify_Actor>> GameplayCueClassesForPreallocation;          // 0x02F8(0x0010)(ZeroConstructor, Transient, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<struct FGameplayCuePendingExecute>     PendingExecuteCues;                                // 0x0308(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	int32                                         GameplayCueSendContextCount;                       // 0x0318(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_31C[0x4];                                      // 0x031C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPreallocationInfo>             PreallocationInfoList_Internal;                    // 0x0320(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_330[0x18];                                     // 0x0330(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("GameplayCueManager")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"GameplayCueManager")
	}
	static class UGameplayCueManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayCueManager>();
	}
};
DUMPER7_ASSERTS_UGameplayCueManager;

// Class GameplayAbilities.GameplayCueNotify_Actor
// 0x0150 (0x0830 - 0x06E0)
class AGameplayCueNotify_Actor : public AActor
{
public:
	bool                                          bAutoDestroyOnRemove;                              // 0x06D8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6D9[0x3];                                      // 0x06D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AutoDestroyDelay;                                  // 0x06DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          WarnIfTimelineIsStillRunning;                      // 0x06E0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          WarnIfLatentActionIsStillRunning;                  // 0x06E1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6E2[0x6];                                      // 0x06E2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnActiveDispatcher;                                // 0x06E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_6F8[0x18];                                     // 0x06F8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              WhileActiveDispatcher;                             // 0x0710(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_720[0x18];                                     // 0x0720(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              ExecutedDispatcher;                                // 0x0738(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_748[0x18];                                     // 0x0748(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              RemovedDispatcher;                                 // 0x0760(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_770[0x18];                                     // 0x0770(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              RecycleDispatcher;                                 // 0x0788(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_798[0x18];                                     // 0x0798(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           GameplayCueTag;                                    // 0x07B0(0x000C)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   GameplayCueName;                                   // 0x07BC(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoAttachToOwner;                                // 0x07C8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsOverride;                                        // 0x07C9(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUniqueInstancePerInstigator;                      // 0x07CA(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUniqueInstancePerSourceObject;                    // 0x07CB(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowMultipleOnActiveEvents;                      // 0x07CC(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowMultipleWhileActiveEvents;                   // 0x07CD(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowMultipleOnRemoveEvents;                      // 0x07CE(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7CF[0x1];                                      // 0x07CF(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NumPreallocatedInstances;                          // 0x07D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDontDisableCueRecycle;                            // 0x07D4(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7D5[0x56];                                     // 0x07D5(0x0056)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bAllowEditCollision;                               // 0x082B(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_82C[0x4];                                      // 0x082C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AttachToOwnerIfNecessary();
	void K2_EndGameplayCue();
	void K2_HandleGameplayCue(class AActor* MyTarget, EGameplayCueEvent EventType, const struct FGameplayCueParameters& Parameters);
	bool OnActive(class AActor* MyTarget, const struct FGameplayCueParameters& Parameters);
	bool OnExecute(class AActor* MyTarget, const struct FGameplayCueParameters& Parameters);
	void OnOwnerDestroyed(class AActor* DestroyedActor);
	void OnOwnerEndPlay(class AActor* Actor, EEndPlayReason EndPlayReason);
	bool OnRemove(class AActor* MyTarget, const struct FGameplayCueParameters& Parameters);
	bool WhileActive(class AActor* MyTarget, const struct FGameplayCueParameters& Parameters);

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("GameplayCueNotify_Actor")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"GameplayCueNotify_Actor")
	}
	static class AGameplayCueNotify_Actor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGameplayCueNotify_Actor>();
	}
};
DUMPER7_ASSERTS_AGameplayCueNotify_Actor;

// Class GameplayAbilities.GameplayCueNotify_Static
// 0x0020 (0x0050 - 0x0030)
class UGameplayCueNotify_Static : public UObject
{
public:
	struct FGameplayTag                           GameplayCueTag;                                    // 0x0030(0x000C)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   GameplayCueName;                                   // 0x003C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsOverride;                                        // 0x0048(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bNetCullCheck : 1;                                 // 0x0049(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_4A[0x6];                                       // 0x004A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void K2_HandleGameplayCue(class AActor* MyTarget, EGameplayCueEvent EventType, const struct FGameplayCueParameters& Parameters) const;
	bool OnActive(class AActor* MyTarget, const struct FGameplayCueParameters& Parameters) const;
	bool OnExecute(class AActor* MyTarget, const struct FGameplayCueParameters& Parameters) const;
	bool OnRemove(class AActor* MyTarget, const struct FGameplayCueParameters& Parameters) const;
	bool WhileActive(class AActor* MyTarget, const struct FGameplayCueParameters& Parameters) const;

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("GameplayCueNotify_Static")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"GameplayCueNotify_Static")
	}
	static class UGameplayCueNotify_Static* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayCueNotify_Static>();
	}
};
DUMPER7_ASSERTS_UGameplayCueNotify_Static;

// Class GameplayAbilities.GameplayCueNotify_Burst
// 0x0340 (0x0390 - 0x0050)
class UGameplayCueNotify_Burst final : public UGameplayCueNotify_Static
{
public:
	struct FGameplayCueNotify_SpawnCondition      DefaultSpawnCondition;                             // 0x0050(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayCueNotify_PlacementInfo       DefaultPlacementInfo;                              // 0x0088(0x0048)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FGameplayCueNotify_BurstEffects        BurstEffects;                                      // 0x00D0(0x02C0)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	void OnBurst(class AActor* Target, const struct FGameplayCueParameters& Parameters, const struct FGameplayCueNotify_SpawnResult& SpawnResults) const;

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("GameplayCueNotify_Burst")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"GameplayCueNotify_Burst")
	}
	static class UGameplayCueNotify_Burst* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayCueNotify_Burst>();
	}
};
DUMPER7_ASSERTS_UGameplayCueNotify_Burst;

// Class GameplayAbilities.GameplayCueNotify_BurstLatent
// 0x03A0 (0x0BD0 - 0x0830)
class AGameplayCueNotify_BurstLatent final : public AGameplayCueNotify_Actor
{
public:
	struct FGameplayCueNotify_SpawnCondition      DefaultSpawnCondition;                             // 0x0830(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayCueNotify_PlacementInfo       DefaultPlacementInfo;                              // 0x0868(0x0048)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FGameplayCueNotify_BurstEffects        BurstEffects;                                      // 0x08B0(0x02C0)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayCueNotify_SpawnResult         BurstSpawnResults;                                 // 0x0B70(0x0058)(BlueprintVisible, BlueprintReadOnly, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_BC8[0x8];                                      // 0x0BC8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnBurst(class AActor* Target, const struct FGameplayCueParameters& Parameters, const struct FGameplayCueNotify_SpawnResult& SpawnResults);

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("GameplayCueNotify_BurstLatent")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"GameplayCueNotify_BurstLatent")
	}
	static class AGameplayCueNotify_BurstLatent* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGameplayCueNotify_BurstLatent>();
	}
};
DUMPER7_ASSERTS_AGameplayCueNotify_BurstLatent;

// Class GameplayAbilities.GameplayCueNotify_HitImpact
// 0x0010 (0x0060 - 0x0050)
class UGameplayCueNotify_HitImpact final : public UGameplayCueNotify_Static
{
public:
	class USoundBase*                             Sound;                                             // 0x0050(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        ParticleSystem;                                    // 0x0058(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("GameplayCueNotify_HitImpact")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"GameplayCueNotify_HitImpact")
	}
	static class UGameplayCueNotify_HitImpact* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayCueNotify_HitImpact>();
	}
};
DUMPER7_ASSERTS_UGameplayCueNotify_HitImpact;

// Class GameplayAbilities.GameplayCueNotify_Looping
// 0x0C40 (0x1470 - 0x0830)
class AGameplayCueNotify_Looping final : public AGameplayCueNotify_Actor
{
public:
	struct FGameplayCueNotify_SpawnCondition      DefaultSpawnCondition;                             // 0x0830(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayCueNotify_PlacementInfo       DefaultPlacementInfo;                              // 0x0868(0x0048)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FGameplayCueNotify_BurstEffects        ApplicationEffects;                                // 0x08B0(0x02C0)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayCueNotify_SpawnResult         ApplicationSpawnResults;                           // 0x0B70(0x0058)(BlueprintVisible, BlueprintReadOnly, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FGameplayCueNotify_LoopingEffects      LoopingEffects;                                    // 0x0BC8(0x0210)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayCueNotify_SpawnResult         LoopingSpawnResults;                               // 0x0DD8(0x0058)(BlueprintVisible, BlueprintReadOnly, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FGameplayCueNotify_BurstEffects        RecurringEffects;                                  // 0x0E30(0x02C0)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayCueNotify_SpawnResult         RecurringSpawnResults;                             // 0x10F0(0x0058)(BlueprintVisible, BlueprintReadOnly, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FGameplayCueNotify_BurstEffects        RemovalEffects;                                    // 0x1148(0x02C0)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayCueNotify_SpawnResult         RemovalSpawnResults;                               // 0x1408(0x0058)(BlueprintVisible, BlueprintReadOnly, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1460[0x10];                                    // 0x1460(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnApplication(class AActor* Target, const struct FGameplayCueParameters& Parameters, const struct FGameplayCueNotify_SpawnResult& SpawnResults);
	void OnLoopingStart(class AActor* Target, const struct FGameplayCueParameters& Parameters, const struct FGameplayCueNotify_SpawnResult& SpawnResults);
	void OnRecurring(class AActor* Target, const struct FGameplayCueParameters& Parameters, const struct FGameplayCueNotify_SpawnResult& SpawnResults);
	void OnRemoval(class AActor* Target, const struct FGameplayCueParameters& Parameters, const struct FGameplayCueNotify_SpawnResult& SpawnResults);

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("GameplayCueNotify_Looping")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"GameplayCueNotify_Looping")
	}
	static class AGameplayCueNotify_Looping* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGameplayCueNotify_Looping>();
	}
};
DUMPER7_ASSERTS_AGameplayCueNotify_Looping;

// Class GameplayAbilities.GameplayCueSet
// 0x0060 (0x0098 - 0x0038)
class UGameplayCueSet : public UDataAsset
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGameplayCueNotifyData>         GameplayCueData;                                   // 0x0088(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static void CleanCueTypeCount();
	static void RecordAndCleanCueTypeCount();
	static void RecordCueTypeCount();

	void RecordCueRecycleInfo(class UGameplayCueManager* InGameplayCueManager, class AActor* InTargetActor, int32 InCueDataIndex);

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("GameplayCueSet")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"GameplayCueSet")
	}
	static class UGameplayCueSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayCueSet>();
	}
};
DUMPER7_ASSERTS_UGameplayCueSet;

// Class GameplayAbilities.GameplayCueTranslator
// 0x0000 (0x0030 - 0x0030)
class UGameplayCueTranslator : public UObject
{
public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("GameplayCueTranslator")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"GameplayCueTranslator")
	}
	static class UGameplayCueTranslator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayCueTranslator>();
	}
};
DUMPER7_ASSERTS_UGameplayCueTranslator;

// Class GameplayAbilities.GameplayCueTranslator_Test
// 0x0000 (0x0030 - 0x0030)
class UGameplayCueTranslator_Test final : public UGameplayCueTranslator
{
public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("GameplayCueTranslator_Test")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"GameplayCueTranslator_Test")
	}
	static class UGameplayCueTranslator_Test* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayCueTranslator_Test>();
	}
};
DUMPER7_ASSERTS_UGameplayCueTranslator_Test;

// Class GameplayAbilities.GameplayEffectCalculation
// 0x0010 (0x0040 - 0x0030)
class UGameplayEffectCalculation : public UObject
{
public:
	TArray<struct FGameplayEffectAttributeCaptureDefinition> RelevantAttributesToCapture;            // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("GameplayEffectCalculation")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"GameplayEffectCalculation")
	}
	static class UGameplayEffectCalculation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayEffectCalculation>();
	}
};
DUMPER7_ASSERTS_UGameplayEffectCalculation;

// Class GameplayAbilities.GameplayEffectCustomApplicationRequirement
// 0x0000 (0x0030 - 0x0030)
class UGameplayEffectCustomApplicationRequirement : public UObject
{
public:
	bool CanApplyGameplayEffect(const class UGameplayEffect* GameplayEffect, const struct FGameplayEffectSpec& Spec, class UAbilitySystemComponent* ASC) const;

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("GameplayEffectCustomApplicationRequirement")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"GameplayEffectCustomApplicationRequirement")
	}
	static class UGameplayEffectCustomApplicationRequirement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayEffectCustomApplicationRequirement>();
	}
};
DUMPER7_ASSERTS_UGameplayEffectCustomApplicationRequirement;

// Class GameplayAbilities.GameplayEffectExecutionCalculation
// 0x0008 (0x0048 - 0x0040)
class UGameplayEffectExecutionCalculation : public UGameplayEffectCalculation
{
public:
	bool                                          bRequiresPassedInTags;                             // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Execute(const struct FGameplayEffectCustomExecutionParameters& ExecutionParams, struct FGameplayEffectCustomExecutionOutput* OutExecutionOutput) const;
	void PostExecute(const struct FGameplayEffectCustomExecutionParameters& ExecutionParams, struct FGameplayEffectCustomExecutionOutput* OutExecutionOutput) const;
	void PreExecute(const struct FGameplayEffectCustomExecutionParameters& ExecutionParams, struct FGameplayEffectCustomExecutionOutput* OutExecutionOutput) const;

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("GameplayEffectExecutionCalculation")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"GameplayEffectExecutionCalculation")
	}
	static class UGameplayEffectExecutionCalculation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayEffectExecutionCalculation>();
	}
};
DUMPER7_ASSERTS_UGameplayEffectExecutionCalculation;

// Class GameplayAbilities.GameplayModMagnitudeCalculation
// 0x0008 (0x0048 - 0x0040)
class UGameplayModMagnitudeCalculation : public UGameplayEffectCalculation
{
public:
	bool                                          bAllowNonNetAuthorityDependencyRegistration;       // 0x0040(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float CalculateBaseMagnitude(const struct FGameplayEffectSpec& Spec) const;
	float GetSetByCallerMagnitudeByName(const struct FGameplayEffectSpec& EffectSpec, const class FName& MagnitudeName) const;
	float GetSetByCallerMagnitudeByTag(const struct FGameplayEffectSpec& EffectSpec, const struct FGameplayTag& Tag) const;
	const struct FGameplayTagContainer GetSourceActorTags(const struct FGameplayEffectSpec& EffectSpec) const;
	struct FGameplayTagContainer GetSourceAggregatedTags(const struct FGameplayEffectSpec& EffectSpec) const;
	const struct FGameplayTagContainer GetSourceSpecTags(const struct FGameplayEffectSpec& EffectSpec) const;
	const struct FGameplayTagContainer GetTargetActorTags(const struct FGameplayEffectSpec& EffectSpec) const;
	struct FGameplayTagContainer GetTargetAggregatedTags(const struct FGameplayEffectSpec& EffectSpec) const;
	const struct FGameplayTagContainer GetTargetSpecTags(const struct FGameplayEffectSpec& EffectSpec) const;
	float K2_GetCapturedAttributeMagnitude(const struct FGameplayEffectSpec& EffectSpec, const struct FGameplayAttribute& Attribute, const struct FGameplayTagContainer& SourceTags, const struct FGameplayTagContainer& TargetTags) const;

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("GameplayModMagnitudeCalculation")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"GameplayModMagnitudeCalculation")
	}
	static class UGameplayModMagnitudeCalculation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayModMagnitudeCalculation>();
	}
};
DUMPER7_ASSERTS_UGameplayModMagnitudeCalculation;

// Class GameplayAbilities.GameplayTagReponseTable
// 0x0270 (0x02A8 - 0x0038)
class UGameplayTagReponseTable final : public UDataAsset
{
public:
	TArray<struct FGameplayTagResponseTableEntry> Entries;                                           // 0x0038(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x260];                                     // 0x0048(0x0260)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void TagResponseEvent(const struct FGameplayTag& Tag, int32 NewCount, class UAbilitySystemComponent* ASC, int32 idx);

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("GameplayTagReponseTable")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"GameplayTagReponseTable")
	}
	static class UGameplayTagReponseTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayTagReponseTable>();
	}
};
DUMPER7_ASSERTS_UGameplayTagReponseTable;

// Class GameplayAbilities.MovieSceneGameplayCueSection
// 0x0098 (0x01A8 - 0x0110)
class UMovieSceneGameplayCueSection final : public UMovieSceneHookSection
{
public:
	struct FMovieSceneGameplayCueKey              Cue;                                               // 0x0110(0x0098)(Edit, NoDestructor, AssetRegistrySearchable, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("MovieSceneGameplayCueSection")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"MovieSceneGameplayCueSection")
	}
	static class UMovieSceneGameplayCueSection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMovieSceneGameplayCueSection>();
	}
};
DUMPER7_ASSERTS_UMovieSceneGameplayCueSection;

// Class GameplayAbilities.MovieSceneGameplayCueTrack
// 0x0010 (0x00B0 - 0x00A0)
class UMovieSceneGameplayCueTrack final : public UMovieSceneNameableTrack
{
public:
	TArray<class UMovieSceneSection*>             Sections;                                          // 0x00A0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	static void SetSequencerTrackHandler(TDelegate<void(class AActor* Target, const struct FGameplayTag& GameplayTag, const struct FGameplayCueParameters& Parameters, EGameplayCueEvent Event)> InGameplayCueTrackHandler);

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("MovieSceneGameplayCueTrack")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"MovieSceneGameplayCueTrack")
	}
	static class UMovieSceneGameplayCueTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMovieSceneGameplayCueTrack>();
	}
};
DUMPER7_ASSERTS_UMovieSceneGameplayCueTrack;

// Class GameplayAbilities.TickableAttributeSetInterface
// 0x0000 (0x0000 - 0x0000)
class ITickableAttributeSetInterface final
{
public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("TickableAttributeSetInterface")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"TickableAttributeSetInterface")
	}
	static class ITickableAttributeSetInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ITickableAttributeSetInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
DUMPER7_ASSERTS_ITickableAttributeSetInterface;

}

