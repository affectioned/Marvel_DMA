#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: GameplayAbilities

#include "Basic.hpp"

#include "NetCore_structs.hpp"
#include "Engine_structs.hpp"
#include "IrisStub_structs.hpp"
#include "GameplayTags_structs.hpp"
#include "DataRegistry_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "PhysicsCore_structs.hpp"
#include "MovieScene_structs.hpp"


namespace SDK
{

// Enum GameplayAbilities.EGameplayCueExecuteType
// NumValues: 0x000B
enum class EGameplayCueExecuteType : uint8
{
	ExecuteNone                              = 0,
	ExecuteFX                                = 1,
	ExecuteBeamFX                            = 2,
	ExecuteDecal                             = 4,
	ExecuteAudio                             = 8,
	ExecuteUI                                = 16,
	ExecuteCameraShake                       = 32,
	QueryCueProperty                         = 64,
	ExecuteAnyFX                             = 7,
	ExecuteAll                               = 63,
	EGameplayCueExecuteType_MAX              = 65,
};

// Enum GameplayAbilities.EGameplayCueEvent
// NumValues: 0x0005
enum class EGameplayCueEvent : uint8
{
	OnActive                                 = 0,
	WhileActive                              = 1,
	Executed                                 = 2,
	Removed                                  = 3,
	EGameplayCueEvent_MAX                    = 4,
};

// Enum GameplayAbilities.EGameplayEffectGrantedAbilityRemovePolicy
// NumValues: 0x0004
enum class EGameplayEffectGrantedAbilityRemovePolicy : uint8
{
	CancelAbilityImmediately                 = 0,
	RemoveAbilityOnEnd                       = 1,
	DoNothing                                = 2,
	EGameplayEffectGrantedAbilityRemovePolicy_MAX = 3,
};

// Enum GameplayAbilities.EGameplayEffectAttributeCaptureSource
// NumValues: 0x0003
enum class EGameplayEffectAttributeCaptureSource : uint8
{
	Source                                   = 0,
	Target                                   = 1,
	EGameplayEffectAttributeCaptureSource_MAX = 2,
};

// Enum GameplayAbilities.ERootMotionTaskEndReason
// NumValues: 0x0004
enum class ERootMotionTaskEndReason : uint8
{
	TimeOut                                  = 1,
	Arrived                                  = 2,
	Interrupted                              = 4,
	ERootMotionTaskEndReason_MAX             = 5,
};

// Enum GameplayAbilities.EGameplayEffectRemovedReason
// NumValues: 0x000E
enum class EGameplayEffectRemovedReason : uint8
{
	UnKnown                                  = 0,
	DurationHandleInvalid                    = 1,
	TimeExpired                              = 2,
	RemovedByOtherGE                         = 3,
	RemovedByCoexist                         = 4,
	RemovedByTagRequirements                 = 5,
	RemovedByCustomMatchDelegate             = 6,
	RemovedByClean                           = 7,
	RemovedByPrediction                      = 8,
	RemovedByBuffSpec                        = 9,
	RemovedByLifeBinding                     = 10,
	RemovedByAbilityLogic                    = 11,
	RemovedByLogic                           = 12,
	EGameplayEffectRemovedReason_MAX         = 13,
};

// Enum GameplayAbilities.EGameplayAbilityActivationMode
// NumValues: 0x0006
enum class EGameplayAbilityActivationMode : uint8
{
	Authority                                = 0,
	NonAuthority                             = 1,
	Predicting                               = 2,
	Confirmed                                = 3,
	Rejected                                 = 4,
	EGameplayAbilityActivationMode_MAX       = 5,
};

// Enum GameplayAbilities.ETagOperationStatus
// NumValues: 0x0007
enum class ETagOperationStatus : uint8
{
	Predict                                  = 0,
	Catchup_Server                           = 1,
	Catchup_HasPredicted_Predicted           = 2,
	Catchup_HasPredicted_Replicate           = 3,
	Catchup_NotPredicted                     = 4,
	Rejected                                 = 5,
	ETagOperationStatus_MAX                  = 6,
};

// Enum GameplayAbilities.ETagOperationType
// NumValues: 0x0004
enum class ETagOperationType : uint8
{
	None                                     = 0,
	Add                                      = 1,
	Remove                                   = 2,
	ETagOperationType_MAX                    = 3,
};

// Enum GameplayAbilities.ERepAnimPositionMethod
// NumValues: 0x0003
enum class ERepAnimPositionMethod : uint8
{
	Position                                 = 0,
	CurrentSectionId                         = 1,
	ERepAnimPositionMethod_MAX               = 2,
};

// Enum GameplayAbilities.EAbilityDataSetValueType
// NumValues: 0x0007
enum class EAbilityDataSetValueType : uint8
{
	None                                     = 0,
	Bool                                     = 1,
	Int                                      = 2,
	Float                                    = 3,
	Vector                                   = 4,
	String                                   = 5,
	EAbilityDataSetValueType_MAX             = 6,
};

// Enum GameplayAbilities.EGameplayCuePayloadType
// NumValues: 0x0003
enum class EGameplayCuePayloadType : uint8
{
	CueParameters                            = 0,
	FromSpec                                 = 1,
	EGameplayCuePayloadType_MAX              = 2,
};

// Enum GameplayAbilities.EAbilityEndReason
// NumValues: 0x0006
enum class EAbilityEndReason : uint8
{
	NONE                                     = 0,
	Complete                                 = 1,
	UserCancel                               = 2,
	Fail                                     = 3,
	Interrupt                                = 4,
	EAbilityEndReason_MAX                    = 5,
};

// Enum GameplayAbilities.EGameplayAbilityInputBinds
// NumValues: 0x000A
enum class EGameplayAbilityInputBinds : uint8
{
	Ability1                                 = 0,
	Ability2                                 = 1,
	Ability3                                 = 2,
	Ability4                                 = 3,
	Ability5                                 = 4,
	Ability6                                 = 5,
	Ability7                                 = 6,
	Ability8                                 = 7,
	Ability9                                 = 8,
	EGameplayAbilityInputBinds_MAX           = 9,
};

// Enum GameplayAbilities.ETargetDataFilterSelf
// NumValues: 0x0004
enum class ETargetDataFilterSelf : uint8
{
	TDFS_Any                                 = 0,
	TDFS_NoSelf                              = 1,
	TDFS_NoOthers                            = 2,
	TDFS_MAX                                 = 3,
};

// Enum GameplayAbilities.EAbilityTaskWaitState
// NumValues: 0x0004
enum class EAbilityTaskWaitState : uint8
{
	WaitingOnGame                            = 1,
	WaitingOnUser                            = 2,
	WaitingOnAvatar                          = 4,
	EAbilityTaskWaitState_MAX                = 5,
};

// Enum GameplayAbilities.ERootMotionMoveToActorTargetOffsetType
// NumValues: 0x0004
enum class ERootMotionMoveToActorTargetOffsetType : uint8
{
	AlignFromTargetToSource                  = 0,
	AlignToTargetForward                     = 1,
	AlignToWorldSpace                        = 2,
	ERootMotionMoveToActorTargetOffsetType_MAX = 3,
};

// Enum GameplayAbilities.EAbilityTaskNetSyncType
// NumValues: 0x0004
enum class EAbilityTaskNetSyncType : uint8
{
	BothWait                                 = 0,
	OnlyServerWait                           = 1,
	OnlyClientWait                           = 2,
	EAbilityTaskNetSyncType_MAX              = 3,
};

// Enum GameplayAbilities.EWaitAttributeChangeComparison
// NumValues: 0x0009
enum class EWaitAttributeChangeComparison : uint8
{
	None                                     = 0,
	GreaterThan                              = 1,
	LessThan                                 = 2,
	GreaterThanOrEqualTo                     = 3,
	LessThanOrEqualTo                        = 4,
	NotEqualTo                               = 5,
	ExactlyEqualTo                           = 6,
	ExactlyDivision                          = 7,
	MAX                                      = 8,
};

// Enum GameplayAbilities.EWaitGameplayTagQueryTriggerCondition
// NumValues: 0x0003
enum class EWaitGameplayTagQueryTriggerCondition : uint8
{
	WhenTrue                                 = 0,
	WhenFalse                                = 1,
	EWaitGameplayTagQueryTriggerCondition_MAX = 2,
};

// Enum GameplayAbilities.EGameplayEffectReplicationMode
// NumValues: 0x0004
enum class EGameplayEffectReplicationMode : uint8
{
	Minimal                                  = 0,
	Mixed                                    = 1,
	Full                                     = 2,
	EGameplayEffectReplicationMode_MAX       = 3,
};

// Enum GameplayAbilities.EGameplayTargetingConfirmation
// NumValues: 0x0005
enum class EGameplayTargetingConfirmation : uint8
{
	Instant                                  = 0,
	UserConfirmed                            = 1,
	Custom                                   = 2,
	CustomMulti                              = 3,
	EGameplayTargetingConfirmation_MAX       = 4,
};

// Enum GameplayAbilities.EGameplayAbilityTargetingLocationType
// NumValues: 0x0004
enum class EGameplayAbilityTargetingLocationType : uint8
{
	LiteralTransform                         = 0,
	ActorTransform                           = 1,
	SocketTransform                          = 2,
	EGameplayAbilityTargetingLocationType_MAX = 3,
};

// Enum GameplayAbilities.EAbilityGenericReplicatedEvent
// NumValues: 0x0028
enum class EAbilityGenericReplicatedEvent : uint8
{
	GenericConfirm                           = 0,
	GenericCancel                            = 1,
	InputPressed                             = 2,
	InputReleased                            = 3,
	GenericSignalFromClient                  = 4,
	GenericSignalFromServer                  = 5,
	GameCustom1                              = 6,
	GameCustom2                              = 7,
	GameCustom3                              = 8,
	GameCustom4                              = 9,
	GameCustom5                              = 10,
	GameCustom6                              = 11,
	InputCustom1                             = 12,
	InputCustom2                             = 13,
	InputCustom3                             = 14,
	InputCustom4                             = 15,
	InputCustom5                             = 16,
	InputCustom6                             = 17,
	InputCustom7                             = 18,
	InputCustom8                             = 19,
	InputCustom9                             = 20,
	InputCustom10                            = 21,
	InputCustom11                            = 22,
	InputCustom12                            = 23,
	InputCustom13                            = 24,
	InputCustom14                            = 25,
	InputCustom15                            = 26,
	InputCustom16                            = 27,
	InputCustomMax                           = 28,
	LoopCustom1                              = 29,
	LoopCustom2                              = 30,
	LoopCustom3                              = 31,
	LoopCustom4                              = 32,
	LoopCustom5                              = 33,
	LoopCustom6                              = 34,
	LoopCustom7                              = 35,
	LoopCustomMax                            = 36,
	DashStart                                = 37,
	DashStop                                 = 38,
	MAX                                      = 39,
};

// Enum GameplayAbilities.EGameplayAbilityInstancingPolicy
// NumValues: 0x0004
enum class EGameplayAbilityInstancingPolicy : uint8
{
	NonInstanced                             = 0,
	InstancedPerActor                        = 1,
	InstancedPerExecution                    = 2,
	EGameplayAbilityInstancingPolicy_MAX     = 3,
};

// Enum GameplayAbilities.EGameplayAbilityNetExecutionPolicy
// NumValues: 0x0005
enum class EGameplayAbilityNetExecutionPolicy : uint8
{
	LocalPredicted                           = 0,
	LocalOnly                                = 1,
	ServerInitiated                          = 2,
	ServerOnly                               = 3,
	EGameplayAbilityNetExecutionPolicy_MAX   = 4,
};

// Enum GameplayAbilities.EGameplayAbilityNetSecurityPolicy
// NumValues: 0x0005
enum class EGameplayAbilityNetSecurityPolicy : uint8
{
	ClientOrServer                           = 0,
	ServerOnlyExecution                      = 1,
	ServerOnlyTermination                    = 2,
	ServerOnly                               = 3,
	EGameplayAbilityNetSecurityPolicy_MAX    = 4,
};

// Enum GameplayAbilities.EGameplayAbilityReplicationPolicy
// NumValues: 0x0003
enum class EGameplayAbilityReplicationPolicy : uint8
{
	ReplicateNo                              = 0,
	ReplicateYes                             = 1,
	EGameplayAbilityReplicationPolicy_MAX    = 2,
};

// Enum GameplayAbilities.EGameplayAbilityTriggerSource
// NumValues: 0x0004
enum class EGameplayAbilityTriggerSource : uint8
{
	GameplayEvent                            = 0,
	OwnedTagAdded                            = 1,
	OwnedTagPresent                          = 2,
	EGameplayAbilityTriggerSource_MAX        = 3,
};

// Enum GameplayAbilities.EGACancelType
// NumValues: 0x0005
enum class EGACancelType : uint8
{
	NONE                                     = 0,
	Buff                                     = 1,
	Ability                                  = 2,
	All                                      = 255,
	EGACancelType_MAX                        = 256,
};

// Enum GameplayAbilities.EAbilityReconnectMode
// NumValues: 0x0006
enum class EAbilityReconnectMode : uint8
{
	Default                                  = 0,
	DoNothing                                = 1,
	Cancel                                   = 2,
	Reactivate                               = 3,
	KeepActive                               = 4,
	EAbilityReconnectMode_MAX                = 5,
};

// Enum GameplayAbilities.ERepEventCallType
// NumValues: 0x0003
enum class ERepEventCallType : uint8
{
	Client                                   = 0,
	Server                                   = 1,
	ERepEventCallType_MAX                    = 2,
};

// Enum GameplayAbilities.EGameplayCueNotify_EffectPlaySpace
// NumValues: 0x0003
enum class EGameplayCueNotify_EffectPlaySpace : uint8
{
	WorldSpace                               = 0,
	CameraSpace                              = 1,
	EGameplayCueNotify_MAX                   = 2,
};

// Enum GameplayAbilities.EGameplayCueNotify_LocallyControlledSource
// NumValues: 0x0003
enum class EGameplayCueNotify_LocallyControlledSource : uint8
{
	InstigatorActor                          = 0,
	TargetActor                              = 1,
	EGameplayCueNotify_MAX                   = 2,
};

// Enum GameplayAbilities.EGameplayCueNotify_LocallyControlledPolicy
// NumValues: 0x0004
enum class EGameplayCueNotify_LocallyControlledPolicy : uint8
{
	Always                                   = 0,
	LocalOnly                                = 1,
	NotLocal                                 = 2,
	EGameplayCueNotify_MAX                   = 3,
};

// Enum GameplayAbilities.EGameplayCueNotify_AttachPolicy
// NumValues: 0x0003
enum class EGameplayCueNotify_AttachPolicy : uint8
{
	DoNotAttach                              = 0,
	AttachToTarget                           = 1,
	EGameplayCueNotify_MAX                   = 2,
};

// Enum GameplayAbilities.EGameplayEffectMagnitudeCalculation
// NumValues: 0x0005
enum class EGameplayEffectMagnitudeCalculation : uint8
{
	ScalableFloat                            = 0,
	AttributeBased                           = 1,
	CustomCalculationClass                   = 2,
	SetByCaller                              = 3,
	EGameplayEffectMagnitudeCalculation_MAX  = 4,
};

// Enum GameplayAbilities.EAttributeBasedFloatCalculationType
// NumValues: 0x0005
enum class EAttributeBasedFloatCalculationType : uint8
{
	AttributeMagnitude                       = 0,
	AttributeBaseValue                       = 1,
	AttributeBonusMagnitude                  = 2,
	AttributeMagnitudeEvaluatedUpToChannel   = 3,
	EAttributeBasedFloatCalculationType_MAX  = 4,
};

// Enum GameplayAbilities.EGameplayEffectVersion
// NumValues: 0x0005
enum class EGameplayEffectVersion : uint8
{
	Monolithic                               = 0,
	Modular53                                = 1,
	AbilitiesComponent53                     = 2,
	Current                                  = 2,
	EGameplayEffectVersion_MAX               = 3,
};

// Enum GameplayAbilities.EGameplayEffectScopedModifierAggregatorType
// NumValues: 0x0003
enum class EGameplayEffectScopedModifierAggregatorType : uint8
{
	CapturedAttributeBacked                  = 0,
	Transient                                = 1,
	EGameplayEffectScopedModifierAggregatorType_MAX = 2,
};

// Enum GameplayAbilities.EGameplayEffectDurationType
// NumValues: 0x0004
enum class EGameplayEffectDurationType : uint8
{
	Instant                                  = 0,
	Infinite                                 = 1,
	HasDuration                              = 2,
	EGameplayEffectDurationType_MAX          = 3,
};

// Enum GameplayAbilities.EGameplayEffectStackingDurationPolicy
// NumValues: 0x0003
enum class EGameplayEffectStackingDurationPolicy : uint8
{
	RefreshOnSuccessfulApplication           = 0,
	NeverRefresh                             = 1,
	EGameplayEffectStackingDurationPolicy_MAX = 2,
};

// Enum GameplayAbilities.EGameplayEffectStackingPeriodPolicy
// NumValues: 0x0003
enum class EGameplayEffectStackingPeriodPolicy : uint8
{
	ResetOnSuccessfulApplication             = 0,
	NeverReset                               = 1,
	EGameplayEffectStackingPeriodPolicy_MAX  = 2,
};

// Enum GameplayAbilities.EGameplayEffectStackingExpirationPolicy
// NumValues: 0x0004
enum class EGameplayEffectStackingExpirationPolicy : uint8
{
	ClearEntireStack                         = 0,
	RemoveSingleStackAndRefreshDuration      = 1,
	RefreshDuration                          = 2,
	EGameplayEffectStackingExpirationPolicy_MAX = 3,
};

// Enum GameplayAbilities.EGameplayEffectPeriodInhibitionRemovedPolicy
// NumValues: 0x0004
enum class EGameplayEffectPeriodInhibitionRemovedPolicy : uint8
{
	NeverReset                               = 0,
	ResetPeriod                              = 1,
	ExecuteAndResetPeriod                    = 2,
	EGameplayEffectPeriodInhibitionRemovedPolicy_MAX = 3,
};

// Enum GameplayAbilities.EGameplayModEvaluationChannel
// NumValues: 0x000C
enum class EGameplayModEvaluationChannel : uint8
{
	Channel0                                 = 0,
	Channel1                                 = 1,
	Channel2                                 = 2,
	Channel3                                 = 3,
	Channel4                                 = 4,
	Channel5                                 = 5,
	Channel6                                 = 6,
	Channel7                                 = 7,
	Channel8                                 = 8,
	Channel9                                 = 9,
	Channel_MAX                              = 10,
	EGameplayModEvaluationChannel_MAX        = 11,
};

// Enum GameplayAbilities.EGameplayModOp
// NumValues: 0x0006
enum class EGameplayModOp : uint8
{
	Additive                                 = 0,
	Multiplicitive                           = 1,
	Division                                 = 2,
	Override                                 = 3,
	Max                                      = 4,
	EGameplayModOp_MAX                       = 5,
};

// Enum GameplayAbilities.EGameplayEffectStackingType
// NumValues: 0x0005
enum class EGameplayEffectStackingType : uint8
{
	None                                     = 0,
	AggregateBySource                        = 1,
	AggregateByTarget                        = 2,
	Replace                                  = 3,
	EGameplayEffectStackingType_MAX          = 4,
};

// Enum GameplayAbilities.EGameplayTagEventType
// NumValues: 0x0003
enum class EGameplayTagEventType : uint8
{
	NewOrRemoved                             = 0,
	AnyCountChange                           = 1,
	EGameplayTagEventType_MAX                = 2,
};

// Enum GameplayAbilities.ECalculationType
// NumValues: 0x0006
enum class ECalculationType : uint8
{
	Calculation_Base                         = 0,
	DiffusionFactorCalculation               = 1,
	DiffusionFactorCalculation2              = 2,
	MarvelModMagnitudeDiffusion              = 3,
	HitShapeDamageCalculation                = 4,
	ECalculationType_MAX                     = 5,
};

// Enum GameplayAbilities.EPredictionKeyState
// NumValues: 0x0006
enum class EPredictionKeyState : uint8
{
	None                                     = 0,
	Waiting                                  = 1,
	CatchUp                                  = 2,
	Reject                                   = 3,
	Timeout                                  = 4,
	EPredictionKeyState_MAX                  = 5,
};

// Enum GameplayAbilities.EScopedPWType
// NumValues: 0x0005
enum class EScopedPWType : uint8
{
	Pw_Set                                   = 0,
	Pw_Child                                 = 1,
	Pw_Back                                  = 2,
	Pw_Empty                                 = 3,
	Pw_MAX                                   = 4,
};

// ScriptStruct GameplayAbilities.GameplayAbilitySpecHandle
// 0x0004 (0x0004 - 0x0000)
struct FGameplayAbilitySpecHandle final
{
public:
	int32                                         Handle;                                            // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FGameplayAbilitySpecHandle) == 0x000004, "Wrong alignment on FGameplayAbilitySpecHandle");
static_assert(sizeof(FGameplayAbilitySpecHandle) == 0x000004, "Wrong size on FGameplayAbilitySpecHandle");
static_assert(offsetof(FGameplayAbilitySpecHandle, Handle) == 0x000000, "Member 'FGameplayAbilitySpecHandle::Handle' has a wrong offset!");

// ScriptStruct GameplayAbilities.GameplayAbilitySpecHandleAndPredictionKey
// 0x0018 (0x0018 - 0x0000)
struct FGameplayAbilitySpecHandleAndPredictionKey final
{
public:
	struct FGameplayAbilitySpecHandle             AbilityHandle;                                     // 0x0000(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 PredictionKeyAtCreation;                           // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameplayAbilitySpecHandleAndPredictionKey) == 0x000008, "Wrong alignment on FGameplayAbilitySpecHandleAndPredictionKey");
static_assert(sizeof(FGameplayAbilitySpecHandleAndPredictionKey) == 0x000018, "Wrong size on FGameplayAbilitySpecHandleAndPredictionKey");
static_assert(offsetof(FGameplayAbilitySpecHandleAndPredictionKey, AbilityHandle) == 0x000000, "Member 'FGameplayAbilitySpecHandleAndPredictionKey::AbilityHandle' has a wrong offset!");
static_assert(offsetof(FGameplayAbilitySpecHandleAndPredictionKey, PredictionKeyAtCreation) == 0x000008, "Member 'FGameplayAbilitySpecHandleAndPredictionKey::PredictionKeyAtCreation' has a wrong offset!");

// ScriptStruct GameplayAbilities.GameplayEffectRemovedContext
// 0x0010 (0x0010 - 0x0000)
struct FGameplayEffectRemovedContext final
{
public:
	EGameplayEffectRemovedReason                  RemovedReason;                                     // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   RemovedOriginInfo;                                 // 0x0004(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameplayEffectRemovedContext) == 0x000004, "Wrong alignment on FGameplayEffectRemovedContext");
static_assert(sizeof(FGameplayEffectRemovedContext) == 0x000010, "Wrong size on FGameplayEffectRemovedContext");
static_assert(offsetof(FGameplayEffectRemovedContext, RemovedReason) == 0x000000, "Member 'FGameplayEffectRemovedContext::RemovedReason' has a wrong offset!");
static_assert(offsetof(FGameplayEffectRemovedContext, RemovedOriginInfo) == 0x000004, "Member 'FGameplayEffectRemovedContext::RemovedOriginInfo' has a wrong offset!");

// ScriptStruct GameplayAbilities.PredictionKey
// 0x0070 (0x0070 - 0x0000)
struct FPredictionKey final
{
public:
	class UPackageMap*                            PredictiveConnection;                              // 0x0000(0x0008)(ZeroConstructor, RepSkip, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Current;                                           // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsStale;                                          // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsServerInitiated;                                // 0x0019(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x16];                                      // 0x001A(0x0016)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         DependOn;                                          // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x30];                                      // 0x0040(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPredictionKey) == 0x000008, "Wrong alignment on FPredictionKey");
static_assert(sizeof(FPredictionKey) == 0x000070, "Wrong size on FPredictionKey");
static_assert(offsetof(FPredictionKey, PredictiveConnection) == 0x000000, "Member 'FPredictionKey::PredictiveConnection' has a wrong offset!");
static_assert(offsetof(FPredictionKey, Current) == 0x000008, "Member 'FPredictionKey::Current' has a wrong offset!");
static_assert(offsetof(FPredictionKey, bIsStale) == 0x000018, "Member 'FPredictionKey::bIsStale' has a wrong offset!");
static_assert(offsetof(FPredictionKey, bIsServerInitiated) == 0x000019, "Member 'FPredictionKey::bIsServerInitiated' has a wrong offset!");
static_assert(offsetof(FPredictionKey, DependOn) == 0x000030, "Member 'FPredictionKey::DependOn' has a wrong offset!");

// ScriptStruct GameplayAbilities.GameplayAttribute
// 0x0040 (0x0040 - 0x0000)
struct FGameplayAttribute final
{
public:
	class FString                                 AttributeName;                                     // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TFieldPath<class FProperty>                   Attribute;                                         // 0x0010(0x0020)(Edit, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStruct*                                AttributeOwner;                                    // 0x0030(0x0008)(Edit, ZeroConstructor, EditConst, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int16                                         AttributeIndex;                                    // 0x0038(0x0002)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bFromInternal;                                     // 0x003A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3B[0x5];                                       // 0x003B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayAttribute) == 0x000008, "Wrong alignment on FGameplayAttribute");
static_assert(sizeof(FGameplayAttribute) == 0x000040, "Wrong size on FGameplayAttribute");
static_assert(offsetof(FGameplayAttribute, AttributeName) == 0x000000, "Member 'FGameplayAttribute::AttributeName' has a wrong offset!");
static_assert(offsetof(FGameplayAttribute, Attribute) == 0x000010, "Member 'FGameplayAttribute::Attribute' has a wrong offset!");
static_assert(offsetof(FGameplayAttribute, AttributeOwner) == 0x000030, "Member 'FGameplayAttribute::AttributeOwner' has a wrong offset!");
static_assert(offsetof(FGameplayAttribute, AttributeIndex) == 0x000038, "Member 'FGameplayAttribute::AttributeIndex' has a wrong offset!");
static_assert(offsetof(FGameplayAttribute, bFromInternal) == 0x00003A, "Member 'FGameplayAttribute::bFromInternal' has a wrong offset!");

// ScriptStruct GameplayAbilities.OnAttributeChangeDataExtend
// 0x0048 (0x0048 - 0x0000)
struct FOnAttributeChangeDataExtend final
{
public:
	struct FGameplayAttribute                     Attribute;                                         // 0x0000(0x0040)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NewValue;                                          // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OldValue;                                          // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOnAttributeChangeDataExtend) == 0x000008, "Wrong alignment on FOnAttributeChangeDataExtend");
static_assert(sizeof(FOnAttributeChangeDataExtend) == 0x000048, "Wrong size on FOnAttributeChangeDataExtend");
static_assert(offsetof(FOnAttributeChangeDataExtend, Attribute) == 0x000000, "Member 'FOnAttributeChangeDataExtend::Attribute' has a wrong offset!");
static_assert(offsetof(FOnAttributeChangeDataExtend, NewValue) == 0x000040, "Member 'FOnAttributeChangeDataExtend::NewValue' has a wrong offset!");
static_assert(offsetof(FOnAttributeChangeDataExtend, OldValue) == 0x000044, "Member 'FOnAttributeChangeDataExtend::OldValue' has a wrong offset!");

// ScriptStruct GameplayAbilities.GameplayEffectContextHandle
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FGameplayEffectContextHandle final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayEffectContextHandle) == 0x000008, "Wrong alignment on FGameplayEffectContextHandle");
static_assert(sizeof(FGameplayEffectContextHandle) == 0x000018, "Wrong size on FGameplayEffectContextHandle");

// ScriptStruct GameplayAbilities.GameplayCueParameters
// 0x01D0 (0x01D0 - 0x0000)
struct FGameplayCueParameters final
{
public:
	float                                         NormalizedMagnitude;                               // 0x0000(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RawMagnitude;                                      // 0x0004(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DurationPolicy;                                    // 0x0008(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x000C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Period;                                            // 0x0010(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayEffectContextHandle           EffectContext;                                     // 0x0018(0x0018)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FGameplayTag                           MatchedTagName;                                    // 0x0030(0x000C)(BlueprintVisible, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           OriginalTag;                                       // 0x003C(0x000C)(BlueprintVisible, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  AggregatedSourceTags;                              // 0x0048(0x0068)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  AggregatedTargetTags;                              // 0x00B0(0x0068)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize10                  Location;                                          // 0x0118(0x0018)(BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantizeNormal              Normal;                                            // 0x0130(0x0018)(BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AActor>                  Instigator;                                        // 0x0148(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AActor>                  EffectCauser;                                      // 0x0150(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UObject>                 SourceObject;                                      // 0x0158(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SourceAbilityExecution;                            // 0x0160(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UPhysicalMaterial>       PhysicalMaterial;                                  // 0x0164(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GameplayEffectLevel;                               // 0x016C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AbilityLevel;                                      // 0x0170(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SkinID;                                            // 0x0174(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int64>                                 SkinFXSlots;                                       // 0x0178(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bSlotsSet;                                         // 0x0188(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_189[0x3];                                      // 0x0189(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         UID;                                               // 0x018C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ProfileHandle;                                     // 0x0190(0x0004)(ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BuffID;                                            // 0x0194(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPredictablyRemovePredictedCue;                    // 0x0198(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_199[0x3];                                      // 0x0199(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class USceneComponent>         TargetAttachComponent;                             // 0x019C(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReplicateLocationWhenUsingMinimalRepProxy;        // 0x01A4(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGameplayCueExecuteType                       CueExecuteType;                                    // 0x01A5(0x0001)(ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A6[0x12];                                     // 0x01A6(0x0012)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void()>                             CustomDynamicDelegate;                             // 0x01B8(0x0014)(ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1CC[0x4];                                      // 0x01CC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayCueParameters) == 0x000008, "Wrong alignment on FGameplayCueParameters");
static_assert(sizeof(FGameplayCueParameters) == 0x0001D0, "Wrong size on FGameplayCueParameters");
static_assert(offsetof(FGameplayCueParameters, NormalizedMagnitude) == 0x000000, "Member 'FGameplayCueParameters::NormalizedMagnitude' has a wrong offset!");
static_assert(offsetof(FGameplayCueParameters, RawMagnitude) == 0x000004, "Member 'FGameplayCueParameters::RawMagnitude' has a wrong offset!");
static_assert(offsetof(FGameplayCueParameters, DurationPolicy) == 0x000008, "Member 'FGameplayCueParameters::DurationPolicy' has a wrong offset!");
static_assert(offsetof(FGameplayCueParameters, Duration) == 0x00000C, "Member 'FGameplayCueParameters::Duration' has a wrong offset!");
static_assert(offsetof(FGameplayCueParameters, Period) == 0x000010, "Member 'FGameplayCueParameters::Period' has a wrong offset!");
static_assert(offsetof(FGameplayCueParameters, EffectContext) == 0x000018, "Member 'FGameplayCueParameters::EffectContext' has a wrong offset!");
static_assert(offsetof(FGameplayCueParameters, MatchedTagName) == 0x000030, "Member 'FGameplayCueParameters::MatchedTagName' has a wrong offset!");
static_assert(offsetof(FGameplayCueParameters, OriginalTag) == 0x00003C, "Member 'FGameplayCueParameters::OriginalTag' has a wrong offset!");
static_assert(offsetof(FGameplayCueParameters, AggregatedSourceTags) == 0x000048, "Member 'FGameplayCueParameters::AggregatedSourceTags' has a wrong offset!");
static_assert(offsetof(FGameplayCueParameters, AggregatedTargetTags) == 0x0000B0, "Member 'FGameplayCueParameters::AggregatedTargetTags' has a wrong offset!");
static_assert(offsetof(FGameplayCueParameters, Location) == 0x000118, "Member 'FGameplayCueParameters::Location' has a wrong offset!");
static_assert(offsetof(FGameplayCueParameters, Normal) == 0x000130, "Member 'FGameplayCueParameters::Normal' has a wrong offset!");
static_assert(offsetof(FGameplayCueParameters, Instigator) == 0x000148, "Member 'FGameplayCueParameters::Instigator' has a wrong offset!");
static_assert(offsetof(FGameplayCueParameters, EffectCauser) == 0x000150, "Member 'FGameplayCueParameters::EffectCauser' has a wrong offset!");
static_assert(offsetof(FGameplayCueParameters, SourceObject) == 0x000158, "Member 'FGameplayCueParameters::SourceObject' has a wrong offset!");
static_assert(offsetof(FGameplayCueParameters, SourceAbilityExecution) == 0x000160, "Member 'FGameplayCueParameters::SourceAbilityExecution' has a wrong offset!");
static_assert(offsetof(FGameplayCueParameters, PhysicalMaterial) == 0x000164, "Member 'FGameplayCueParameters::PhysicalMaterial' has a wrong offset!");
static_assert(offsetof(FGameplayCueParameters, GameplayEffectLevel) == 0x00016C, "Member 'FGameplayCueParameters::GameplayEffectLevel' has a wrong offset!");
static_assert(offsetof(FGameplayCueParameters, AbilityLevel) == 0x000170, "Member 'FGameplayCueParameters::AbilityLevel' has a wrong offset!");
static_assert(offsetof(FGameplayCueParameters, SkinID) == 0x000174, "Member 'FGameplayCueParameters::SkinID' has a wrong offset!");
static_assert(offsetof(FGameplayCueParameters, SkinFXSlots) == 0x000178, "Member 'FGameplayCueParameters::SkinFXSlots' has a wrong offset!");
static_assert(offsetof(FGameplayCueParameters, bSlotsSet) == 0x000188, "Member 'FGameplayCueParameters::bSlotsSet' has a wrong offset!");
static_assert(offsetof(FGameplayCueParameters, UID) == 0x00018C, "Member 'FGameplayCueParameters::UID' has a wrong offset!");
static_assert(offsetof(FGameplayCueParameters, ProfileHandle) == 0x000190, "Member 'FGameplayCueParameters::ProfileHandle' has a wrong offset!");
static_assert(offsetof(FGameplayCueParameters, BuffID) == 0x000194, "Member 'FGameplayCueParameters::BuffID' has a wrong offset!");
static_assert(offsetof(FGameplayCueParameters, bPredictablyRemovePredictedCue) == 0x000198, "Member 'FGameplayCueParameters::bPredictablyRemovePredictedCue' has a wrong offset!");
static_assert(offsetof(FGameplayCueParameters, TargetAttachComponent) == 0x00019C, "Member 'FGameplayCueParameters::TargetAttachComponent' has a wrong offset!");
static_assert(offsetof(FGameplayCueParameters, bReplicateLocationWhenUsingMinimalRepProxy) == 0x0001A4, "Member 'FGameplayCueParameters::bReplicateLocationWhenUsingMinimalRepProxy' has a wrong offset!");
static_assert(offsetof(FGameplayCueParameters, CueExecuteType) == 0x0001A5, "Member 'FGameplayCueParameters::CueExecuteType' has a wrong offset!");
static_assert(offsetof(FGameplayCueParameters, CustomDynamicDelegate) == 0x0001B8, "Member 'FGameplayCueParameters::CustomDynamicDelegate' has a wrong offset!");

// ScriptStruct GameplayAbilities.AbilityTriggerData
// 0x0010 (0x0010 - 0x0000)
struct FAbilityTriggerData final
{
public:
	struct FGameplayTag                           TriggerTag;                                        // 0x0000(0x000C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGameplayAbilityTriggerSource                 TriggerSource;                                     // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAbilityTriggerData) == 0x000004, "Wrong alignment on FAbilityTriggerData");
static_assert(sizeof(FAbilityTriggerData) == 0x000010, "Wrong size on FAbilityTriggerData");
static_assert(offsetof(FAbilityTriggerData, TriggerTag) == 0x000000, "Member 'FAbilityTriggerData::TriggerTag' has a wrong offset!");
static_assert(offsetof(FAbilityTriggerData, TriggerSource) == 0x00000C, "Member 'FAbilityTriggerData::TriggerSource' has a wrong offset!");

// ScriptStruct GameplayAbilities.ActiveGameplayEffectHandle
// 0x0008 (0x0008 - 0x0000)
struct FActiveGameplayEffectHandle final
{
public:
	int32                                         Handle;                                            // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bPassedFiltersAndWasExecuted;                      // 0x0004(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FActiveGameplayEffectHandle) == 0x000004, "Wrong alignment on FActiveGameplayEffectHandle");
static_assert(sizeof(FActiveGameplayEffectHandle) == 0x000008, "Wrong size on FActiveGameplayEffectHandle");
static_assert(offsetof(FActiveGameplayEffectHandle, Handle) == 0x000000, "Member 'FActiveGameplayEffectHandle::Handle' has a wrong offset!");
static_assert(offsetof(FActiveGameplayEffectHandle, bPassedFiltersAndWasExecuted) == 0x000004, "Member 'FActiveGameplayEffectHandle::bPassedFiltersAndWasExecuted' has a wrong offset!");

// ScriptStruct GameplayAbilities.GameplayEffectCue
// 0x00B0 (0x00B0 - 0x0000)
struct FGameplayEffectCue final
{
public:
	struct FGameplayAttribute                     MagnitudeAttribute;                                // 0x0000(0x0040)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinLevel;                                          // 0x0040(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxLevel;                                          // 0x0044(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  GameplayCueTags;                                   // 0x0048(0x0068)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameplayEffectCue) == 0x000008, "Wrong alignment on FGameplayEffectCue");
static_assert(sizeof(FGameplayEffectCue) == 0x0000B0, "Wrong size on FGameplayEffectCue");
static_assert(offsetof(FGameplayEffectCue, MagnitudeAttribute) == 0x000000, "Member 'FGameplayEffectCue::MagnitudeAttribute' has a wrong offset!");
static_assert(offsetof(FGameplayEffectCue, MinLevel) == 0x000040, "Member 'FGameplayEffectCue::MinLevel' has a wrong offset!");
static_assert(offsetof(FGameplayEffectCue, MaxLevel) == 0x000044, "Member 'FGameplayEffectCue::MaxLevel' has a wrong offset!");
static_assert(offsetof(FGameplayEffectCue, GameplayCueTags) == 0x000048, "Member 'FGameplayEffectCue::GameplayCueTags' has a wrong offset!");

// ScriptStruct GameplayAbilities.ModifierSpec
// 0x0004 (0x0004 - 0x0000)
struct FModifierSpec final
{
public:
	float                                         EvaluatedMagnitude;                                // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FModifierSpec) == 0x000004, "Wrong alignment on FModifierSpec");
static_assert(sizeof(FModifierSpec) == 0x000004, "Wrong size on FModifierSpec");
static_assert(offsetof(FModifierSpec, EvaluatedMagnitude) == 0x000000, "Member 'FModifierSpec::EvaluatedMagnitude' has a wrong offset!");

// ScriptStruct GameplayAbilities.GameplayEffectModifiedAttribute
// 0x0048 (0x0048 - 0x0000)
struct FGameplayEffectModifiedAttribute final
{
public:
	struct FGameplayAttribute                     Attribute;                                         // 0x0000(0x0040)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TotalMagnitude;                                    // 0x0040(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayEffectModifiedAttribute) == 0x000008, "Wrong alignment on FGameplayEffectModifiedAttribute");
static_assert(sizeof(FGameplayEffectModifiedAttribute) == 0x000048, "Wrong size on FGameplayEffectModifiedAttribute");
static_assert(offsetof(FGameplayEffectModifiedAttribute, Attribute) == 0x000000, "Member 'FGameplayEffectModifiedAttribute::Attribute' has a wrong offset!");
static_assert(offsetof(FGameplayEffectModifiedAttribute, TotalMagnitude) == 0x000040, "Member 'FGameplayEffectModifiedAttribute::TotalMagnitude' has a wrong offset!");

// ScriptStruct GameplayAbilities.GameplayEffectAttributeCaptureDefinition
// 0x0048 (0x0048 - 0x0000)
struct FGameplayEffectAttributeCaptureDefinition final
{
public:
	struct FGameplayAttribute                     AttributeToCapture;                                // 0x0000(0x0040)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGameplayEffectAttributeCaptureSource         AttributeSource;                                   // 0x0040(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSnapshot;                                         // 0x0041(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42[0x6];                                       // 0x0042(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayEffectAttributeCaptureDefinition) == 0x000008, "Wrong alignment on FGameplayEffectAttributeCaptureDefinition");
static_assert(sizeof(FGameplayEffectAttributeCaptureDefinition) == 0x000048, "Wrong size on FGameplayEffectAttributeCaptureDefinition");
static_assert(offsetof(FGameplayEffectAttributeCaptureDefinition, AttributeToCapture) == 0x000000, "Member 'FGameplayEffectAttributeCaptureDefinition::AttributeToCapture' has a wrong offset!");
static_assert(offsetof(FGameplayEffectAttributeCaptureDefinition, AttributeSource) == 0x000040, "Member 'FGameplayEffectAttributeCaptureDefinition::AttributeSource' has a wrong offset!");
static_assert(offsetof(FGameplayEffectAttributeCaptureDefinition, bSnapshot) == 0x000041, "Member 'FGameplayEffectAttributeCaptureDefinition::bSnapshot' has a wrong offset!");

// ScriptStruct GameplayAbilities.GameplayEffectAttributeCaptureSpec
// 0x0058 (0x0058 - 0x0000)
struct FGameplayEffectAttributeCaptureSpec final
{
public:
	struct FGameplayEffectAttributeCaptureDefinition BackingDefinition;                              // 0x0000(0x0048)(HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_48[0x10];                                      // 0x0048(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayEffectAttributeCaptureSpec) == 0x000008, "Wrong alignment on FGameplayEffectAttributeCaptureSpec");
static_assert(sizeof(FGameplayEffectAttributeCaptureSpec) == 0x000058, "Wrong size on FGameplayEffectAttributeCaptureSpec");
static_assert(offsetof(FGameplayEffectAttributeCaptureSpec, BackingDefinition) == 0x000000, "Member 'FGameplayEffectAttributeCaptureSpec::BackingDefinition' has a wrong offset!");

// ScriptStruct GameplayAbilities.GameplayEffectAttributeCaptureSpecContainer
// 0x0028 (0x0028 - 0x0000)
struct FGameplayEffectAttributeCaptureSpecContainer final
{
public:
	TArray<struct FGameplayEffectAttributeCaptureSpec> SourceAttributes;                             // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FGameplayEffectAttributeCaptureSpec> TargetAttributes;                             // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	bool                                          bHasNonSnapshottedAttributes;                      // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayEffectAttributeCaptureSpecContainer) == 0x000008, "Wrong alignment on FGameplayEffectAttributeCaptureSpecContainer");
static_assert(sizeof(FGameplayEffectAttributeCaptureSpecContainer) == 0x000028, "Wrong size on FGameplayEffectAttributeCaptureSpecContainer");
static_assert(offsetof(FGameplayEffectAttributeCaptureSpecContainer, SourceAttributes) == 0x000000, "Member 'FGameplayEffectAttributeCaptureSpecContainer::SourceAttributes' has a wrong offset!");
static_assert(offsetof(FGameplayEffectAttributeCaptureSpecContainer, TargetAttributes) == 0x000010, "Member 'FGameplayEffectAttributeCaptureSpecContainer::TargetAttributes' has a wrong offset!");
static_assert(offsetof(FGameplayEffectAttributeCaptureSpecContainer, bHasNonSnapshottedAttributes) == 0x000020, "Member 'FGameplayEffectAttributeCaptureSpecContainer::bHasNonSnapshottedAttributes' has a wrong offset!");

// ScriptStruct GameplayAbilities.GameplayTagRequirements
// 0x0118 (0x0118 - 0x0000)
struct FGameplayTagRequirements final
{
public:
	struct FGameplayTagContainer                  RequireTags;                                       // 0x0000(0x0068)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  IgnoreTags;                                        // 0x0068(0x0068)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FGameplayTagQuery                      TagQuery;                                          // 0x00D0(0x0048)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameplayTagRequirements) == 0x000008, "Wrong alignment on FGameplayTagRequirements");
static_assert(sizeof(FGameplayTagRequirements) == 0x000118, "Wrong size on FGameplayTagRequirements");
static_assert(offsetof(FGameplayTagRequirements, RequireTags) == 0x000000, "Member 'FGameplayTagRequirements::RequireTags' has a wrong offset!");
static_assert(offsetof(FGameplayTagRequirements, IgnoreTags) == 0x000068, "Member 'FGameplayTagRequirements::IgnoreTags' has a wrong offset!");
static_assert(offsetof(FGameplayTagRequirements, TagQuery) == 0x0000D0, "Member 'FGameplayTagRequirements::TagQuery' has a wrong offset!");

// ScriptStruct GameplayAbilities.TagContainerAggregator
// 0x01A8 (0x01A8 - 0x0000)
struct FTagContainerAggregator final
{
public:
	struct FGameplayTagContainer                  CapturedActorTags;                                 // 0x0000(0x0068)(NativeAccessSpecifierPrivate)
	struct FGameplayTagContainer                  CapturedSpecTags;                                  // 0x0068(0x0068)(NativeAccessSpecifierPrivate)
	struct FGameplayTagContainer                  ScopedTags;                                        // 0x00D0(0x0068)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_138[0x70];                                     // 0x0138(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTagContainerAggregator) == 0x000008, "Wrong alignment on FTagContainerAggregator");
static_assert(sizeof(FTagContainerAggregator) == 0x0001A8, "Wrong size on FTagContainerAggregator");
static_assert(offsetof(FTagContainerAggregator, CapturedActorTags) == 0x000000, "Member 'FTagContainerAggregator::CapturedActorTags' has a wrong offset!");
static_assert(offsetof(FTagContainerAggregator, CapturedSpecTags) == 0x000068, "Member 'FTagContainerAggregator::CapturedSpecTags' has a wrong offset!");
static_assert(offsetof(FTagContainerAggregator, ScopedTags) == 0x0000D0, "Member 'FTagContainerAggregator::ScopedTags' has a wrong offset!");

// ScriptStruct GameplayAbilities.ScalableFloat
// 0x0038 (0x0038 - 0x0000)
struct FScalableFloat final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCurveTableRowHandle                   Curve;                                             // 0x0008(0x0018)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDataRegistryType                      RegistryType;                                      // 0x0020(0x000C)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0xC];                                       // 0x002C(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FScalableFloat) == 0x000008, "Wrong alignment on FScalableFloat");
static_assert(sizeof(FScalableFloat) == 0x000038, "Wrong size on FScalableFloat");
static_assert(offsetof(FScalableFloat, Value) == 0x000000, "Member 'FScalableFloat::Value' has a wrong offset!");
static_assert(offsetof(FScalableFloat, Curve) == 0x000008, "Member 'FScalableFloat::Curve' has a wrong offset!");
static_assert(offsetof(FScalableFloat, RegistryType) == 0x000020, "Member 'FScalableFloat::RegistryType' has a wrong offset!");

// ScriptStruct GameplayAbilities.GameplayAbilitySpecDef
// 0x00B0 (0x00B0 - 0x0000)
struct FGameplayAbilitySpecDef final
{
public:
	TSubclassOf<class UGameplayAbility>           Ability;                                           // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, RepSkip, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FScalableFloat                         LevelScalableFloat;                                // 0x0008(0x0038)(Edit, DisableEditOnInstance, RepSkip, NativeAccessSpecifierPublic)
	bool                                          ActivateOnceImmediately;                           // 0x0040(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         InputID;                                           // 0x0044(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AbilityID;                                         // 0x0048(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGameplayEffectGrantedAbilityRemovePolicy     RemovalPolicy;                                     // 0x004C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UObject>                 SourceObject;                                      // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_58[0x50];                                      // 0x0058(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayAbilitySpecHandle             AssignedHandle;                                    // 0x00A8(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayAbilitySpecDef) == 0x000008, "Wrong alignment on FGameplayAbilitySpecDef");
static_assert(sizeof(FGameplayAbilitySpecDef) == 0x0000B0, "Wrong size on FGameplayAbilitySpecDef");
static_assert(offsetof(FGameplayAbilitySpecDef, Ability) == 0x000000, "Member 'FGameplayAbilitySpecDef::Ability' has a wrong offset!");
static_assert(offsetof(FGameplayAbilitySpecDef, LevelScalableFloat) == 0x000008, "Member 'FGameplayAbilitySpecDef::LevelScalableFloat' has a wrong offset!");
static_assert(offsetof(FGameplayAbilitySpecDef, ActivateOnceImmediately) == 0x000040, "Member 'FGameplayAbilitySpecDef::ActivateOnceImmediately' has a wrong offset!");
static_assert(offsetof(FGameplayAbilitySpecDef, InputID) == 0x000044, "Member 'FGameplayAbilitySpecDef::InputID' has a wrong offset!");
static_assert(offsetof(FGameplayAbilitySpecDef, AbilityID) == 0x000048, "Member 'FGameplayAbilitySpecDef::AbilityID' has a wrong offset!");
static_assert(offsetof(FGameplayAbilitySpecDef, RemovalPolicy) == 0x00004C, "Member 'FGameplayAbilitySpecDef::RemovalPolicy' has a wrong offset!");
static_assert(offsetof(FGameplayAbilitySpecDef, SourceObject) == 0x000050, "Member 'FGameplayAbilitySpecDef::SourceObject' has a wrong offset!");
static_assert(offsetof(FGameplayAbilitySpecDef, AssignedHandle) == 0x0000A8, "Member 'FGameplayAbilitySpecDef::AssignedHandle' has a wrong offset!");

// ScriptStruct GameplayAbilities.GameplayEffectSpec
// 0x09F0 (0x09F0 - 0x0000)
struct FGameplayEffectSpec final
{
public:
	class UGameplayEffect*                        Def;                                               // 0x0000(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGameplayEffectCue>             GameplayCues;                                      // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FGameplayEffectCue>             PendingGameplayCues;                               // 0x0018(0x0010)(ZeroConstructor, RepSkip, NativeAccessSpecifierPublic)
	TArray<struct FGameplayEffectModifiedAttribute> ModifiedAttributes;                              // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FGameplayEffectAttributeCaptureSpecContainer CapturedRelevantAttributes;                  // 0x0038(0x0028)(RepSkip, NativeAccessSpecifierPublic)
	uint8                                         Pad_60[0x10];                                      // 0x0060(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Duration;                                          // 0x0070(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Period;                                            // 0x0074(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PeriodCount;                                       // 0x0078(0x0004)(ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PeriodLimitCount;                                  // 0x007C(0x0004)(ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         QuoteDepth;                                        // 0x0080(0x0004)(ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InstanceId;                                        // 0x0084(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RefreshStackTime;                                  // 0x0088(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89[0x3];                                       // 0x0089(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         StackLimitCount;                                   // 0x008C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAccumulateDuration;                               // 0x0090(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x3];                                       // 0x0091(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxAccumulateDuration;                             // 0x0094(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseRemainingMagnitudes;                           // 0x0098(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRefreshWhenReplace;                               // 0x0099(0x0001)(ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInvalidSyncBuff;                                  // 0x009A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9B[0x1];                                       // 0x009B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ChanceToApplyToTarget;                             // 0x009C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SkinID;                                            // 0x00A0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int64>                                 SkinFXSlots;                                       // 0x00A8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         UID;                                               // 0x00B8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DiffusionMode;                                     // 0x00BC(0x0004)(ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DiffusionPeriod;                                   // 0x00C0(0x0004)(ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C4[0x4];                                       // 0x00C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTagContainerAggregator                CapturedSourceTags;                                // 0x00C8(0x01A8)(RepSkip, NativeAccessSpecifierPublic)
	struct FTagContainerAggregator                CapturedTargetTags;                                // 0x0270(0x01A8)(RepSkip, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  DynamicGrantedTags;                                // 0x0418(0x0068)(NativeAccessSpecifierPublic)
	struct FGameplayTagRequirements               CancelAbilitiesWithTag;                            // 0x0480(0x0118)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTagRequirements               BlockAbilitiesWithTag;                             // 0x0598(0x0118)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  DynamicAssetTags;                                  // 0x06B0(0x0068)(NativeAccessSpecifierPublic)
	TArray<struct FModifierSpec>                  Modifiers;                                         // 0x0718(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         StackCount;                                        // 0x0728(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bCompletedSourceAttributeCapture : 1;              // 0x072C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCompletedTargetAttributeCapture : 1;              // 0x072C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDurationLocked : 1;                               // 0x072C(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_72D[0x3];                                      // 0x072D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGameplayAbilitySpecDef>        GrantedAbilitySpecs;                               // 0x0730(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FGameplayAbilitySpecDef>        DynamicGrantedAbilitySpecs;                        // 0x0740(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bReplaceEffectAbilityIfNotChild;                   // 0x0750(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_751[0x147];                                    // 0x0751(0x0147)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bOverrideEffectStackRule;                          // 0x0898(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bModifierCleanAutoRemove;                          // 0x0899(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOwnerDeathAutoRemove;                             // 0x089A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUsePredictionEffectDuration;                      // 0x089B(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLocalUsePredictionEffectDuration;                 // 0x089C(0x0001)(ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89D[0x3];                                      // 0x089D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagRequirements               DynamicRemovalTagRequirements;                     // 0x08A0(0x0118)(RepSkip, NativeAccessSpecifierPublic)
	struct FGameplayEffectContextHandle           EffectContext;                                     // 0x09B8(0x0018)(NativeAccessSpecifierPrivate)
	float                                         Level;                                             // 0x09D0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_9D4[0x1];                                      // 0x09D4(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bEnableCullDistance;                               // 0x09D5(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9D6[0x1A];                                     // 0x09D6(0x001A)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayEffectSpec) == 0x000008, "Wrong alignment on FGameplayEffectSpec");
static_assert(sizeof(FGameplayEffectSpec) == 0x0009F0, "Wrong size on FGameplayEffectSpec");
static_assert(offsetof(FGameplayEffectSpec, Def) == 0x000000, "Member 'FGameplayEffectSpec::Def' has a wrong offset!");
static_assert(offsetof(FGameplayEffectSpec, GameplayCues) == 0x000008, "Member 'FGameplayEffectSpec::GameplayCues' has a wrong offset!");
static_assert(offsetof(FGameplayEffectSpec, PendingGameplayCues) == 0x000018, "Member 'FGameplayEffectSpec::PendingGameplayCues' has a wrong offset!");
static_assert(offsetof(FGameplayEffectSpec, ModifiedAttributes) == 0x000028, "Member 'FGameplayEffectSpec::ModifiedAttributes' has a wrong offset!");
static_assert(offsetof(FGameplayEffectSpec, CapturedRelevantAttributes) == 0x000038, "Member 'FGameplayEffectSpec::CapturedRelevantAttributes' has a wrong offset!");
static_assert(offsetof(FGameplayEffectSpec, Duration) == 0x000070, "Member 'FGameplayEffectSpec::Duration' has a wrong offset!");
static_assert(offsetof(FGameplayEffectSpec, Period) == 0x000074, "Member 'FGameplayEffectSpec::Period' has a wrong offset!");
static_assert(offsetof(FGameplayEffectSpec, PeriodCount) == 0x000078, "Member 'FGameplayEffectSpec::PeriodCount' has a wrong offset!");
static_assert(offsetof(FGameplayEffectSpec, PeriodLimitCount) == 0x00007C, "Member 'FGameplayEffectSpec::PeriodLimitCount' has a wrong offset!");
static_assert(offsetof(FGameplayEffectSpec, QuoteDepth) == 0x000080, "Member 'FGameplayEffectSpec::QuoteDepth' has a wrong offset!");
static_assert(offsetof(FGameplayEffectSpec, InstanceId) == 0x000084, "Member 'FGameplayEffectSpec::InstanceId' has a wrong offset!");
static_assert(offsetof(FGameplayEffectSpec, RefreshStackTime) == 0x000088, "Member 'FGameplayEffectSpec::RefreshStackTime' has a wrong offset!");
static_assert(offsetof(FGameplayEffectSpec, StackLimitCount) == 0x00008C, "Member 'FGameplayEffectSpec::StackLimitCount' has a wrong offset!");
static_assert(offsetof(FGameplayEffectSpec, bAccumulateDuration) == 0x000090, "Member 'FGameplayEffectSpec::bAccumulateDuration' has a wrong offset!");
static_assert(offsetof(FGameplayEffectSpec, MaxAccumulateDuration) == 0x000094, "Member 'FGameplayEffectSpec::MaxAccumulateDuration' has a wrong offset!");
static_assert(offsetof(FGameplayEffectSpec, bUseRemainingMagnitudes) == 0x000098, "Member 'FGameplayEffectSpec::bUseRemainingMagnitudes' has a wrong offset!");
static_assert(offsetof(FGameplayEffectSpec, bRefreshWhenReplace) == 0x000099, "Member 'FGameplayEffectSpec::bRefreshWhenReplace' has a wrong offset!");
static_assert(offsetof(FGameplayEffectSpec, bInvalidSyncBuff) == 0x00009A, "Member 'FGameplayEffectSpec::bInvalidSyncBuff' has a wrong offset!");
static_assert(offsetof(FGameplayEffectSpec, ChanceToApplyToTarget) == 0x00009C, "Member 'FGameplayEffectSpec::ChanceToApplyToTarget' has a wrong offset!");
static_assert(offsetof(FGameplayEffectSpec, SkinID) == 0x0000A0, "Member 'FGameplayEffectSpec::SkinID' has a wrong offset!");
static_assert(offsetof(FGameplayEffectSpec, SkinFXSlots) == 0x0000A8, "Member 'FGameplayEffectSpec::SkinFXSlots' has a wrong offset!");
static_assert(offsetof(FGameplayEffectSpec, UID) == 0x0000B8, "Member 'FGameplayEffectSpec::UID' has a wrong offset!");
static_assert(offsetof(FGameplayEffectSpec, DiffusionMode) == 0x0000BC, "Member 'FGameplayEffectSpec::DiffusionMode' has a wrong offset!");
static_assert(offsetof(FGameplayEffectSpec, DiffusionPeriod) == 0x0000C0, "Member 'FGameplayEffectSpec::DiffusionPeriod' has a wrong offset!");
static_assert(offsetof(FGameplayEffectSpec, CapturedSourceTags) == 0x0000C8, "Member 'FGameplayEffectSpec::CapturedSourceTags' has a wrong offset!");
static_assert(offsetof(FGameplayEffectSpec, CapturedTargetTags) == 0x000270, "Member 'FGameplayEffectSpec::CapturedTargetTags' has a wrong offset!");
static_assert(offsetof(FGameplayEffectSpec, DynamicGrantedTags) == 0x000418, "Member 'FGameplayEffectSpec::DynamicGrantedTags' has a wrong offset!");
static_assert(offsetof(FGameplayEffectSpec, CancelAbilitiesWithTag) == 0x000480, "Member 'FGameplayEffectSpec::CancelAbilitiesWithTag' has a wrong offset!");
static_assert(offsetof(FGameplayEffectSpec, BlockAbilitiesWithTag) == 0x000598, "Member 'FGameplayEffectSpec::BlockAbilitiesWithTag' has a wrong offset!");
static_assert(offsetof(FGameplayEffectSpec, DynamicAssetTags) == 0x0006B0, "Member 'FGameplayEffectSpec::DynamicAssetTags' has a wrong offset!");
static_assert(offsetof(FGameplayEffectSpec, Modifiers) == 0x000718, "Member 'FGameplayEffectSpec::Modifiers' has a wrong offset!");
static_assert(offsetof(FGameplayEffectSpec, StackCount) == 0x000728, "Member 'FGameplayEffectSpec::StackCount' has a wrong offset!");
static_assert(offsetof(FGameplayEffectSpec, GrantedAbilitySpecs) == 0x000730, "Member 'FGameplayEffectSpec::GrantedAbilitySpecs' has a wrong offset!");
static_assert(offsetof(FGameplayEffectSpec, DynamicGrantedAbilitySpecs) == 0x000740, "Member 'FGameplayEffectSpec::DynamicGrantedAbilitySpecs' has a wrong offset!");
static_assert(offsetof(FGameplayEffectSpec, bReplaceEffectAbilityIfNotChild) == 0x000750, "Member 'FGameplayEffectSpec::bReplaceEffectAbilityIfNotChild' has a wrong offset!");
static_assert(offsetof(FGameplayEffectSpec, bOverrideEffectStackRule) == 0x000898, "Member 'FGameplayEffectSpec::bOverrideEffectStackRule' has a wrong offset!");
static_assert(offsetof(FGameplayEffectSpec, bModifierCleanAutoRemove) == 0x000899, "Member 'FGameplayEffectSpec::bModifierCleanAutoRemove' has a wrong offset!");
static_assert(offsetof(FGameplayEffectSpec, bOwnerDeathAutoRemove) == 0x00089A, "Member 'FGameplayEffectSpec::bOwnerDeathAutoRemove' has a wrong offset!");
static_assert(offsetof(FGameplayEffectSpec, bUsePredictionEffectDuration) == 0x00089B, "Member 'FGameplayEffectSpec::bUsePredictionEffectDuration' has a wrong offset!");
static_assert(offsetof(FGameplayEffectSpec, bLocalUsePredictionEffectDuration) == 0x00089C, "Member 'FGameplayEffectSpec::bLocalUsePredictionEffectDuration' has a wrong offset!");
static_assert(offsetof(FGameplayEffectSpec, DynamicRemovalTagRequirements) == 0x0008A0, "Member 'FGameplayEffectSpec::DynamicRemovalTagRequirements' has a wrong offset!");
static_assert(offsetof(FGameplayEffectSpec, EffectContext) == 0x0009B8, "Member 'FGameplayEffectSpec::EffectContext' has a wrong offset!");
static_assert(offsetof(FGameplayEffectSpec, Level) == 0x0009D0, "Member 'FGameplayEffectSpec::Level' has a wrong offset!");
static_assert(offsetof(FGameplayEffectSpec, bEnableCullDistance) == 0x0009D5, "Member 'FGameplayEffectSpec::bEnableCullDistance' has a wrong offset!");

// ScriptStruct GameplayAbilities.ActiveGameplayEffect
// 0x0B78 (0x0B90 - 0x0018)
struct FActiveGameplayEffect final : public FFastArraySerializerItem
{
public:
	struct FActiveGameplayEffectHandle            Handle;                                            // 0x0018(0x0008)(RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEffectSpec                    Spec;                                              // 0x0020(0x09F0)(NativeAccessSpecifierPublic)
	struct FPredictionKey                         PredictionKey;                                     // 0x0A10(0x0070)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGameplayAbilitySpecHandle>     GrantedAbilityHandles;                             // 0x0A80(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         StartServerWorldTime;                              // 0x0A90(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CachedStartServerWorldTime;                        // 0x0A94(0x0004)(ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartWorldTime;                                    // 0x0A98(0x0004)(ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInhibited;                                      // 0x0A9C(0x0001)(ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9D[0xEB];                                     // 0x0A9D(0x00EB)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bActiveCullDistance;                               // 0x0B88(0x0001)(ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B89[0x7];                                      // 0x0B89(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FActiveGameplayEffect) == 0x000008, "Wrong alignment on FActiveGameplayEffect");
static_assert(sizeof(FActiveGameplayEffect) == 0x000B90, "Wrong size on FActiveGameplayEffect");
static_assert(offsetof(FActiveGameplayEffect, Handle) == 0x000018, "Member 'FActiveGameplayEffect::Handle' has a wrong offset!");
static_assert(offsetof(FActiveGameplayEffect, Spec) == 0x000020, "Member 'FActiveGameplayEffect::Spec' has a wrong offset!");
static_assert(offsetof(FActiveGameplayEffect, PredictionKey) == 0x000A10, "Member 'FActiveGameplayEffect::PredictionKey' has a wrong offset!");
static_assert(offsetof(FActiveGameplayEffect, GrantedAbilityHandles) == 0x000A80, "Member 'FActiveGameplayEffect::GrantedAbilityHandles' has a wrong offset!");
static_assert(offsetof(FActiveGameplayEffect, StartServerWorldTime) == 0x000A90, "Member 'FActiveGameplayEffect::StartServerWorldTime' has a wrong offset!");
static_assert(offsetof(FActiveGameplayEffect, CachedStartServerWorldTime) == 0x000A94, "Member 'FActiveGameplayEffect::CachedStartServerWorldTime' has a wrong offset!");
static_assert(offsetof(FActiveGameplayEffect, StartWorldTime) == 0x000A98, "Member 'FActiveGameplayEffect::StartWorldTime' has a wrong offset!");
static_assert(offsetof(FActiveGameplayEffect, bIsInhibited) == 0x000A9C, "Member 'FActiveGameplayEffect::bIsInhibited' has a wrong offset!");
static_assert(offsetof(FActiveGameplayEffect, bActiveCullDistance) == 0x000B88, "Member 'FActiveGameplayEffect::bActiveCullDistance' has a wrong offset!");

// ScriptStruct GameplayAbilities.MinimalReplicationTagOperation
// 0x00F8 (0x0110 - 0x0018)
struct FMinimalReplicationTagOperation final : public FFastArraySerializerItem
{
public:
	struct FPredictionKey                         PredictionKey;                                     // 0x0018(0x0070)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETagOperationType                             Type;                                              // 0x0088(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89[0x3];                                       // 0x0089(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           Tag;                                               // 0x008C(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0098(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  Tags;                                              // 0x00A0(0x0068)(NativeAccessSpecifierPublic)
	float                                         TimeStamp;                                         // 0x0108(0x0004)(ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETagOperationStatus                           Status;                                            // 0x010C(0x0001)(ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10D[0x3];                                      // 0x010D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMinimalReplicationTagOperation) == 0x000008, "Wrong alignment on FMinimalReplicationTagOperation");
static_assert(sizeof(FMinimalReplicationTagOperation) == 0x000110, "Wrong size on FMinimalReplicationTagOperation");
static_assert(offsetof(FMinimalReplicationTagOperation, PredictionKey) == 0x000018, "Member 'FMinimalReplicationTagOperation::PredictionKey' has a wrong offset!");
static_assert(offsetof(FMinimalReplicationTagOperation, Type) == 0x000088, "Member 'FMinimalReplicationTagOperation::Type' has a wrong offset!");
static_assert(offsetof(FMinimalReplicationTagOperation, Tag) == 0x00008C, "Member 'FMinimalReplicationTagOperation::Tag' has a wrong offset!");
static_assert(offsetof(FMinimalReplicationTagOperation, Count) == 0x000098, "Member 'FMinimalReplicationTagOperation::Count' has a wrong offset!");
static_assert(offsetof(FMinimalReplicationTagOperation, Tags) == 0x0000A0, "Member 'FMinimalReplicationTagOperation::Tags' has a wrong offset!");
static_assert(offsetof(FMinimalReplicationTagOperation, TimeStamp) == 0x000108, "Member 'FMinimalReplicationTagOperation::TimeStamp' has a wrong offset!");
static_assert(offsetof(FMinimalReplicationTagOperation, Status) == 0x00010C, "Member 'FMinimalReplicationTagOperation::Status' has a wrong offset!");

// ScriptStruct GameplayAbilities.GameplayEffectRemovalInfo
// 0x0038 (0x0038 - 0x0000)
struct FGameplayEffectRemovalInfo final
{
public:
	bool                                          bPrematureRemoval;                                 // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         StackCount;                                        // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEffectContextHandle           EffectContext;                                     // 0x0008(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayEffectRemovedContext          RemovedContext;                                    // 0x0020(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayEffectRemovalInfo) == 0x000008, "Wrong alignment on FGameplayEffectRemovalInfo");
static_assert(sizeof(FGameplayEffectRemovalInfo) == 0x000038, "Wrong size on FGameplayEffectRemovalInfo");
static_assert(offsetof(FGameplayEffectRemovalInfo, bPrematureRemoval) == 0x000000, "Member 'FGameplayEffectRemovalInfo::bPrematureRemoval' has a wrong offset!");
static_assert(offsetof(FGameplayEffectRemovalInfo, StackCount) == 0x000004, "Member 'FGameplayEffectRemovalInfo::StackCount' has a wrong offset!");
static_assert(offsetof(FGameplayEffectRemovalInfo, EffectContext) == 0x000008, "Member 'FGameplayEffectRemovalInfo::EffectContext' has a wrong offset!");
static_assert(offsetof(FGameplayEffectRemovalInfo, RemovedContext) == 0x000020, "Member 'FGameplayEffectRemovalInfo::RemovedContext' has a wrong offset!");

// ScriptStruct GameplayAbilities.GameplayCueNotify_SpawnCondition
// 0x0038 (0x0038 - 0x0000)
struct FGameplayCueNotify_SpawnCondition final
{
public:
	EGameplayCueNotify_LocallyControlledSource    LocallyControlledSource;                           // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGameplayCueNotify_LocallyControlledPolicy    LocallyControlledPolicy;                           // 0x0001(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ChanceToPlay;                                      // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EPhysicalSurface>                      AllowedSurfaceTypes;                               // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x8];                                       // 0x0018(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EPhysicalSurface>                      RejectedSurfaceTypes;                              // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayCueNotify_SpawnCondition) == 0x000008, "Wrong alignment on FGameplayCueNotify_SpawnCondition");
static_assert(sizeof(FGameplayCueNotify_SpawnCondition) == 0x000038, "Wrong size on FGameplayCueNotify_SpawnCondition");
static_assert(offsetof(FGameplayCueNotify_SpawnCondition, LocallyControlledSource) == 0x000000, "Member 'FGameplayCueNotify_SpawnCondition::LocallyControlledSource' has a wrong offset!");
static_assert(offsetof(FGameplayCueNotify_SpawnCondition, LocallyControlledPolicy) == 0x000001, "Member 'FGameplayCueNotify_SpawnCondition::LocallyControlledPolicy' has a wrong offset!");
static_assert(offsetof(FGameplayCueNotify_SpawnCondition, ChanceToPlay) == 0x000004, "Member 'FGameplayCueNotify_SpawnCondition::ChanceToPlay' has a wrong offset!");
static_assert(offsetof(FGameplayCueNotify_SpawnCondition, AllowedSurfaceTypes) == 0x000008, "Member 'FGameplayCueNotify_SpawnCondition::AllowedSurfaceTypes' has a wrong offset!");
static_assert(offsetof(FGameplayCueNotify_SpawnCondition, RejectedSurfaceTypes) == 0x000020, "Member 'FGameplayCueNotify_SpawnCondition::RejectedSurfaceTypes' has a wrong offset!");

// ScriptStruct GameplayAbilities.GameplayCueNotify_PlacementInfo
// 0x0048 (0x0048 - 0x0000)
struct FGameplayCueNotify_PlacementInfo final
{
public:
	class FName                                   SocketName;                                        // 0x0000(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGameplayCueNotify_AttachPolicy               AttachPolicy;                                      // 0x000C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttachmentRule                               AttachmentRule;                                    // 0x000D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E[0x2];                                        // 0x000E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bOverrideRotation : 1;                             // 0x0010(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverrideScale : 1;                                // 0x0010(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               RotationOverride;                                  // 0x0018(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                ScaleOverride;                                     // 0x0030(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameplayCueNotify_PlacementInfo) == 0x000008, "Wrong alignment on FGameplayCueNotify_PlacementInfo");
static_assert(sizeof(FGameplayCueNotify_PlacementInfo) == 0x000048, "Wrong size on FGameplayCueNotify_PlacementInfo");
static_assert(offsetof(FGameplayCueNotify_PlacementInfo, SocketName) == 0x000000, "Member 'FGameplayCueNotify_PlacementInfo::SocketName' has a wrong offset!");
static_assert(offsetof(FGameplayCueNotify_PlacementInfo, AttachPolicy) == 0x00000C, "Member 'FGameplayCueNotify_PlacementInfo::AttachPolicy' has a wrong offset!");
static_assert(offsetof(FGameplayCueNotify_PlacementInfo, AttachmentRule) == 0x00000D, "Member 'FGameplayCueNotify_PlacementInfo::AttachmentRule' has a wrong offset!");
static_assert(offsetof(FGameplayCueNotify_PlacementInfo, RotationOverride) == 0x000018, "Member 'FGameplayCueNotify_PlacementInfo::RotationOverride' has a wrong offset!");
static_assert(offsetof(FGameplayCueNotify_PlacementInfo, ScaleOverride) == 0x000030, "Member 'FGameplayCueNotify_PlacementInfo::ScaleOverride' has a wrong offset!");

// ScriptStruct GameplayAbilities.GameplayCueNotify_ParticleInfo
// 0x0090 (0x0090 - 0x0000)
struct FGameplayCueNotify_ParticleInfo final
{
public:
	struct FGameplayCueNotify_SpawnCondition      SpawnConditionOverride;                            // 0x0000(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayCueNotify_PlacementInfo       PlacementInfoOverride;                             // 0x0038(0x0048)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         NiagaraSystem;                                     // 0x0080(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverrideSpawnCondition : 1;                       // 0x0088(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverridePlacementInfo : 1;                        // 0x0088(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCastShadow : 1;                                   // 0x0088(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_89[0x7];                                       // 0x0089(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayCueNotify_ParticleInfo) == 0x000008, "Wrong alignment on FGameplayCueNotify_ParticleInfo");
static_assert(sizeof(FGameplayCueNotify_ParticleInfo) == 0x000090, "Wrong size on FGameplayCueNotify_ParticleInfo");
static_assert(offsetof(FGameplayCueNotify_ParticleInfo, SpawnConditionOverride) == 0x000000, "Member 'FGameplayCueNotify_ParticleInfo::SpawnConditionOverride' has a wrong offset!");
static_assert(offsetof(FGameplayCueNotify_ParticleInfo, PlacementInfoOverride) == 0x000038, "Member 'FGameplayCueNotify_ParticleInfo::PlacementInfoOverride' has a wrong offset!");
static_assert(offsetof(FGameplayCueNotify_ParticleInfo, NiagaraSystem) == 0x000080, "Member 'FGameplayCueNotify_ParticleInfo::NiagaraSystem' has a wrong offset!");

// ScriptStruct GameplayAbilities.GameplayAbilityLocalAnimMontage
// 0x0028 (0x0028 - 0x0000)
struct FGameplayAbilityLocalAnimMontage final
{
public:
	class UAnimMontage*                           AnimMontage;                                       // 0x0000(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         PlayInstanceId;                                    // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UGameplayAbility>        AnimatingAbility;                                  // 0x000C(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsSimulated;                                       // 0x0014(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 StartKey;                                          // 0x0018(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameplayAbilityLocalAnimMontage) == 0x000008, "Wrong alignment on FGameplayAbilityLocalAnimMontage");
static_assert(sizeof(FGameplayAbilityLocalAnimMontage) == 0x000028, "Wrong size on FGameplayAbilityLocalAnimMontage");
static_assert(offsetof(FGameplayAbilityLocalAnimMontage, AnimMontage) == 0x000000, "Member 'FGameplayAbilityLocalAnimMontage::AnimMontage' has a wrong offset!");
static_assert(offsetof(FGameplayAbilityLocalAnimMontage, PlayInstanceId) == 0x000008, "Member 'FGameplayAbilityLocalAnimMontage::PlayInstanceId' has a wrong offset!");
static_assert(offsetof(FGameplayAbilityLocalAnimMontage, AnimatingAbility) == 0x00000C, "Member 'FGameplayAbilityLocalAnimMontage::AnimatingAbility' has a wrong offset!");
static_assert(offsetof(FGameplayAbilityLocalAnimMontage, IsSimulated) == 0x000014, "Member 'FGameplayAbilityLocalAnimMontage::IsSimulated' has a wrong offset!");
static_assert(offsetof(FGameplayAbilityLocalAnimMontage, StartKey) == 0x000018, "Member 'FGameplayAbilityLocalAnimMontage::StartKey' has a wrong offset!");

// ScriptStruct GameplayAbilities.AbilityDataSetValueWrapper
// 0x0038 (0x0038 - 0x0000)
struct FAbilityDataSetValueWrapper final
{
public:
	EAbilityDataSetValueType                      ValueType;                                         // 0x0000(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          BoolValue;                                         // 0x0001(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         IntValue;                                          // 0x0004(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         FloatValue;                                        // 0x0008(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                VectorValue;                                       // 0x0010(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 StringValue;                                       // 0x0028(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FAbilityDataSetValueWrapper) == 0x000008, "Wrong alignment on FAbilityDataSetValueWrapper");
static_assert(sizeof(FAbilityDataSetValueWrapper) == 0x000038, "Wrong size on FAbilityDataSetValueWrapper");
static_assert(offsetof(FAbilityDataSetValueWrapper, ValueType) == 0x000000, "Member 'FAbilityDataSetValueWrapper::ValueType' has a wrong offset!");
static_assert(offsetof(FAbilityDataSetValueWrapper, BoolValue) == 0x000001, "Member 'FAbilityDataSetValueWrapper::BoolValue' has a wrong offset!");
static_assert(offsetof(FAbilityDataSetValueWrapper, IntValue) == 0x000004, "Member 'FAbilityDataSetValueWrapper::IntValue' has a wrong offset!");
static_assert(offsetof(FAbilityDataSetValueWrapper, FloatValue) == 0x000008, "Member 'FAbilityDataSetValueWrapper::FloatValue' has a wrong offset!");
static_assert(offsetof(FAbilityDataSetValueWrapper, VectorValue) == 0x000010, "Member 'FAbilityDataSetValueWrapper::VectorValue' has a wrong offset!");
static_assert(offsetof(FAbilityDataSetValueWrapper, StringValue) == 0x000028, "Member 'FAbilityDataSetValueWrapper::StringValue' has a wrong offset!");

// ScriptStruct GameplayAbilities.GameplayEffectInhibitContext
// 0x0018 (0x0018 - 0x0000)
struct FGameplayEffectInhibitContext final
{
public:
	struct FGameplayTag                           InhibitTag;                                        // 0x0000(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   InhibitOriginInfo;                                 // 0x000C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameplayEffectInhibitContext) == 0x000004, "Wrong alignment on FGameplayEffectInhibitContext");
static_assert(sizeof(FGameplayEffectInhibitContext) == 0x000018, "Wrong size on FGameplayEffectInhibitContext");
static_assert(offsetof(FGameplayEffectInhibitContext, InhibitTag) == 0x000000, "Member 'FGameplayEffectInhibitContext::InhibitTag' has a wrong offset!");
static_assert(offsetof(FGameplayEffectInhibitContext, InhibitOriginInfo) == 0x00000C, "Member 'FGameplayEffectInhibitContext::InhibitOriginInfo' has a wrong offset!");

// ScriptStruct GameplayAbilities.GameplayAbilityLocalAnimTimeline
// 0x0020 (0x0020 - 0x0000)
struct FGameplayAbilityLocalAnimTimeline final
{
public:
	class UAnimTimeline*                          AnimTimeline;                                      // 0x0000(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameplayAbility*                       AnimatingAbility;                                  // 0x0008(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 StartKey;                                          // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameplayAbilityLocalAnimTimeline) == 0x000008, "Wrong alignment on FGameplayAbilityLocalAnimTimeline");
static_assert(sizeof(FGameplayAbilityLocalAnimTimeline) == 0x000020, "Wrong size on FGameplayAbilityLocalAnimTimeline");
static_assert(offsetof(FGameplayAbilityLocalAnimTimeline, AnimTimeline) == 0x000000, "Member 'FGameplayAbilityLocalAnimTimeline::AnimTimeline' has a wrong offset!");
static_assert(offsetof(FGameplayAbilityLocalAnimTimeline, AnimatingAbility) == 0x000008, "Member 'FGameplayAbilityLocalAnimTimeline::AnimatingAbility' has a wrong offset!");
static_assert(offsetof(FGameplayAbilityLocalAnimTimeline, StartKey) == 0x000010, "Member 'FGameplayAbilityLocalAnimTimeline::StartKey' has a wrong offset!");

// ScriptStruct GameplayAbilities.AttributeDefaults
// 0x0010 (0x0010 - 0x0000)
struct FAttributeDefaults final
{
public:
	TSubclassOf<class UAttributeSet>              Attributes;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             DefaultStartingTable;                              // 0x0008(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAttributeDefaults) == 0x000008, "Wrong alignment on FAttributeDefaults");
static_assert(sizeof(FAttributeDefaults) == 0x000010, "Wrong size on FAttributeDefaults");
static_assert(offsetof(FAttributeDefaults, Attributes) == 0x000000, "Member 'FAttributeDefaults::Attributes' has a wrong offset!");
static_assert(offsetof(FAttributeDefaults, DefaultStartingTable) == 0x000008, "Member 'FAttributeDefaults::DefaultStartingTable' has a wrong offset!");

// ScriptStruct GameplayAbilities.GameplayAbilityTargetDataHandle
// 0x0168 (0x0168 - 0x0000)
struct alignas(0x08) FGameplayAbilityTargetDataHandle final
{
public:
	uint8                                         Pad_0[0x168];                                      // 0x0000(0x0168)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayAbilityTargetDataHandle) == 0x000008, "Wrong alignment on FGameplayAbilityTargetDataHandle");
static_assert(sizeof(FGameplayAbilityTargetDataHandle) == 0x000168, "Wrong size on FGameplayAbilityTargetDataHandle");

// ScriptStruct GameplayAbilities.GameplayEventData
// 0x0290 (0x0290 - 0x0000)
struct FGameplayEventData final
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0000(0x000C)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EventName;                                         // 0x000C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Instigator;                                        // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Target;                                            // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                OptionalObject;                                    // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                OptionalObject2;                                   // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEffectContextHandle           ContextHandle;                                     // 0x0038(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  InstigatorTags;                                    // 0x0050(0x0068)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  TargetTags;                                        // 0x00B8(0x0068)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         EventMagnitude;                                    // 0x0120(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_124[0x4];                                      // 0x0124(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayAbilityTargetDataHandle       TargetData;                                        // 0x0128(0x0168)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameplayEventData) == 0x000008, "Wrong alignment on FGameplayEventData");
static_assert(sizeof(FGameplayEventData) == 0x000290, "Wrong size on FGameplayEventData");
static_assert(offsetof(FGameplayEventData, EventTag) == 0x000000, "Member 'FGameplayEventData::EventTag' has a wrong offset!");
static_assert(offsetof(FGameplayEventData, EventName) == 0x00000C, "Member 'FGameplayEventData::EventName' has a wrong offset!");
static_assert(offsetof(FGameplayEventData, Instigator) == 0x000018, "Member 'FGameplayEventData::Instigator' has a wrong offset!");
static_assert(offsetof(FGameplayEventData, Target) == 0x000020, "Member 'FGameplayEventData::Target' has a wrong offset!");
static_assert(offsetof(FGameplayEventData, OptionalObject) == 0x000028, "Member 'FGameplayEventData::OptionalObject' has a wrong offset!");
static_assert(offsetof(FGameplayEventData, OptionalObject2) == 0x000030, "Member 'FGameplayEventData::OptionalObject2' has a wrong offset!");
static_assert(offsetof(FGameplayEventData, ContextHandle) == 0x000038, "Member 'FGameplayEventData::ContextHandle' has a wrong offset!");
static_assert(offsetof(FGameplayEventData, InstigatorTags) == 0x000050, "Member 'FGameplayEventData::InstigatorTags' has a wrong offset!");
static_assert(offsetof(FGameplayEventData, TargetTags) == 0x0000B8, "Member 'FGameplayEventData::TargetTags' has a wrong offset!");
static_assert(offsetof(FGameplayEventData, EventMagnitude) == 0x000120, "Member 'FGameplayEventData::EventMagnitude' has a wrong offset!");
static_assert(offsetof(FGameplayEventData, TargetData) == 0x000128, "Member 'FGameplayEventData::TargetData' has a wrong offset!");

// ScriptStruct GameplayAbilities.GameplayCueNotify_SoundParameterInterfaceInfo
// 0x000C (0x000C - 0x0000)
struct FGameplayCueNotify_SoundParameterInterfaceInfo final
{
public:
	class FName                                   StopTriggerName;                                   // 0x0000(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameplayCueNotify_SoundParameterInterfaceInfo) == 0x000004, "Wrong alignment on FGameplayCueNotify_SoundParameterInterfaceInfo");
static_assert(sizeof(FGameplayCueNotify_SoundParameterInterfaceInfo) == 0x00000C, "Wrong size on FGameplayCueNotify_SoundParameterInterfaceInfo");
static_assert(offsetof(FGameplayCueNotify_SoundParameterInterfaceInfo, StopTriggerName) == 0x000000, "Member 'FGameplayCueNotify_SoundParameterInterfaceInfo::StopTriggerName' has a wrong offset!");

// ScriptStruct GameplayAbilities.GameplayAbilityRepAnimTimeline
// 0x0020 (0x0038 - 0x0018)
struct FGameplayAbilityRepAnimTimeline final : public FFastArraySerializerItem
{
public:
	class UAnimTimeline*                          AnimTimeline;                                      // 0x0018(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayRate;                                          // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Position;                                          // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         NextSectionID;                                     // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bRepPosition : 1;                                  // 0x0029(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         IsStopped : 1;                                     // 0x0029(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         SkipPositionCorrection : 1;                        // 0x0029(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSkipPlayRate : 1;                                 // 0x0029(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         SectionIdToPlay;                                   // 0x002A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B[0x1];                                       // 0x002B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Handle;                                            // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayAbilityRepAnimTimeline) == 0x000008, "Wrong alignment on FGameplayAbilityRepAnimTimeline");
static_assert(sizeof(FGameplayAbilityRepAnimTimeline) == 0x000038, "Wrong size on FGameplayAbilityRepAnimTimeline");
static_assert(offsetof(FGameplayAbilityRepAnimTimeline, AnimTimeline) == 0x000018, "Member 'FGameplayAbilityRepAnimTimeline::AnimTimeline' has a wrong offset!");
static_assert(offsetof(FGameplayAbilityRepAnimTimeline, PlayRate) == 0x000020, "Member 'FGameplayAbilityRepAnimTimeline::PlayRate' has a wrong offset!");
static_assert(offsetof(FGameplayAbilityRepAnimTimeline, Position) == 0x000024, "Member 'FGameplayAbilityRepAnimTimeline::Position' has a wrong offset!");
static_assert(offsetof(FGameplayAbilityRepAnimTimeline, NextSectionID) == 0x000028, "Member 'FGameplayAbilityRepAnimTimeline::NextSectionID' has a wrong offset!");
static_assert(offsetof(FGameplayAbilityRepAnimTimeline, SectionIdToPlay) == 0x00002A, "Member 'FGameplayAbilityRepAnimTimeline::SectionIdToPlay' has a wrong offset!");
static_assert(offsetof(FGameplayAbilityRepAnimTimeline, Handle) == 0x00002C, "Member 'FGameplayAbilityRepAnimTimeline::Handle' has a wrong offset!");

// ScriptStruct GameplayAbilities.GameplayAbilityMultiRepAnimTimeline
// 0x0010 (0x0120 - 0x0110)
struct FGameplayAbilityMultiRepAnimTimeline final : public FFastArraySerializer
{
public:
	TArray<struct FGameplayAbilityRepAnimTimeline> AnimTimelines;                                    // 0x0110(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameplayAbilityMultiRepAnimTimeline) == 0x000008, "Wrong alignment on FGameplayAbilityMultiRepAnimTimeline");
static_assert(sizeof(FGameplayAbilityMultiRepAnimTimeline) == 0x000120, "Wrong size on FGameplayAbilityMultiRepAnimTimeline");
static_assert(offsetof(FGameplayAbilityMultiRepAnimTimeline, AnimTimelines) == 0x000110, "Member 'FGameplayAbilityMultiRepAnimTimeline::AnimTimelines' has a wrong offset!");

// ScriptStruct GameplayAbilities.GameplayAbilityMultiLocalAnimTimeline
// 0x0010 (0x0010 - 0x0000)
struct FGameplayAbilityMultiLocalAnimTimeline final
{
public:
	TArray<struct FGameplayAbilityLocalAnimTimeline> AnimTimelines;                                  // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameplayAbilityMultiLocalAnimTimeline) == 0x000008, "Wrong alignment on FGameplayAbilityMultiLocalAnimTimeline");
static_assert(sizeof(FGameplayAbilityMultiLocalAnimTimeline) == 0x000010, "Wrong size on FGameplayAbilityMultiLocalAnimTimeline");
static_assert(offsetof(FGameplayAbilityMultiLocalAnimTimeline, AnimTimelines) == 0x000000, "Member 'FGameplayAbilityMultiLocalAnimTimeline::AnimTimelines' has a wrong offset!");

// ScriptStruct GameplayAbilities.ActiveGameplayEffectsContainer
// 0x16D8 (0x17E8 - 0x0110)
struct FActiveGameplayEffectsContainer final : public FFastArraySerializer
{
public:
	uint8                                         Pad_110[0x28];                                     // 0x0110(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FActiveGameplayEffect>          GameplayEffects_Internal;                          // 0x0138(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_148[0x16A0];                                   // 0x0148(0x16A0)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FActiveGameplayEffectsContainer) == 0x000008, "Wrong alignment on FActiveGameplayEffectsContainer");
static_assert(sizeof(FActiveGameplayEffectsContainer) == 0x0017E8, "Wrong size on FActiveGameplayEffectsContainer");
static_assert(offsetof(FActiveGameplayEffectsContainer, GameplayEffects_Internal) == 0x000138, "Member 'FActiveGameplayEffectsContainer::GameplayEffects_Internal' has a wrong offset!");

// ScriptStruct GameplayAbilities.GameplayCueTranslationLink
// 0x0018 (0x0018 - 0x0000)
struct FGameplayCueTranslationLink final
{
public:
	class UGameplayCueTranslator*                 RulesCDO;                                          // 0x0000(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x10];                                       // 0x0008(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayCueTranslationLink) == 0x000008, "Wrong alignment on FGameplayCueTranslationLink");
static_assert(sizeof(FGameplayCueTranslationLink) == 0x000018, "Wrong size on FGameplayCueTranslationLink");
static_assert(offsetof(FGameplayCueTranslationLink, RulesCDO) == 0x000000, "Member 'FGameplayCueTranslationLink::RulesCDO' has a wrong offset!");

// ScriptStruct GameplayAbilities.GameplayCueTranslatorNodeIndex
// 0x0004 (0x0004 - 0x0000)
struct FGameplayCueTranslatorNodeIndex final
{
public:
	int32                                         Index;                                             // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameplayCueTranslatorNodeIndex) == 0x000004, "Wrong alignment on FGameplayCueTranslatorNodeIndex");
static_assert(sizeof(FGameplayCueTranslatorNodeIndex) == 0x000004, "Wrong size on FGameplayCueTranslatorNodeIndex");
static_assert(offsetof(FGameplayCueTranslatorNodeIndex, Index) == 0x000000, "Member 'FGameplayCueTranslatorNodeIndex::Index' has a wrong offset!");

// ScriptStruct GameplayAbilities.GameplayCueTranslatorNode
// 0x0080 (0x0080 - 0x0000)
struct FGameplayCueTranslatorNode final
{
public:
	TArray<struct FGameplayCueTranslationLink>    Links;                                             // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FGameplayCueTranslatorNodeIndex        CachedIndex;                                       // 0x0010(0x0004)(NoDestructor, NativeAccessSpecifierPublic)
	struct FGameplayTag                           CachedGameplayTag;                                 // 0x0014(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CachedGameplayTagName;                             // 0x0020(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x54];                                      // 0x002C(0x0054)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayCueTranslatorNode) == 0x000008, "Wrong alignment on FGameplayCueTranslatorNode");
static_assert(sizeof(FGameplayCueTranslatorNode) == 0x000080, "Wrong size on FGameplayCueTranslatorNode");
static_assert(offsetof(FGameplayCueTranslatorNode, Links) == 0x000000, "Member 'FGameplayCueTranslatorNode::Links' has a wrong offset!");
static_assert(offsetof(FGameplayCueTranslatorNode, CachedIndex) == 0x000010, "Member 'FGameplayCueTranslatorNode::CachedIndex' has a wrong offset!");
static_assert(offsetof(FGameplayCueTranslatorNode, CachedGameplayTag) == 0x000014, "Member 'FGameplayCueTranslatorNode::CachedGameplayTag' has a wrong offset!");
static_assert(offsetof(FGameplayCueTranslatorNode, CachedGameplayTagName) == 0x000020, "Member 'FGameplayCueTranslatorNode::CachedGameplayTagName' has a wrong offset!");

// ScriptStruct GameplayAbilities.CustomCalculationBasedFloat
// 0x00C8 (0x00C8 - 0x0000)
struct FCustomCalculationBasedFloat final
{
public:
	TSubclassOf<class UGameplayModMagnitudeCalculation> CalculationClassMagnitude;                   // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FScalableFloat                         Coefficient;                                       // 0x0008(0x0038)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FScalableFloat                         PreMultiplyAdditiveValue;                          // 0x0040(0x0038)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FScalableFloat                         PostMultiplyAdditiveValue;                         // 0x0078(0x0038)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FCurveTableRowHandle                   FinalLookupCurve;                                  // 0x00B0(0x0018)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCustomCalculationBasedFloat) == 0x000008, "Wrong alignment on FCustomCalculationBasedFloat");
static_assert(sizeof(FCustomCalculationBasedFloat) == 0x0000C8, "Wrong size on FCustomCalculationBasedFloat");
static_assert(offsetof(FCustomCalculationBasedFloat, CalculationClassMagnitude) == 0x000000, "Member 'FCustomCalculationBasedFloat::CalculationClassMagnitude' has a wrong offset!");
static_assert(offsetof(FCustomCalculationBasedFloat, Coefficient) == 0x000008, "Member 'FCustomCalculationBasedFloat::Coefficient' has a wrong offset!");
static_assert(offsetof(FCustomCalculationBasedFloat, PreMultiplyAdditiveValue) == 0x000040, "Member 'FCustomCalculationBasedFloat::PreMultiplyAdditiveValue' has a wrong offset!");
static_assert(offsetof(FCustomCalculationBasedFloat, PostMultiplyAdditiveValue) == 0x000078, "Member 'FCustomCalculationBasedFloat::PostMultiplyAdditiveValue' has a wrong offset!");
static_assert(offsetof(FCustomCalculationBasedFloat, FinalLookupCurve) == 0x0000B0, "Member 'FCustomCalculationBasedFloat::FinalLookupCurve' has a wrong offset!");

// ScriptStruct GameplayAbilities.AttributeBasedFloat
// 0x01E0 (0x01E0 - 0x0000)
struct FAttributeBasedFloat final
{
public:
	struct FScalableFloat                         Coefficient;                                       // 0x0000(0x0038)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FScalableFloat                         PreMultiplyAdditiveValue;                          // 0x0038(0x0038)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FScalableFloat                         PostMultiplyAdditiveValue;                         // 0x0070(0x0038)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayEffectAttributeCaptureDefinition BackingAttribute;                               // 0x00A8(0x0048)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCurveTableRowHandle                   AttributeCurve;                                    // 0x00F0(0x0018)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttributeBasedFloatCalculationType           AttributeCalculationType;                          // 0x0108(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGameplayModEvaluationChannel                 FinalChannel;                                      // 0x0109(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10A[0x6];                                      // 0x010A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  SourceTagFilter;                                   // 0x0110(0x0068)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  TargetTagFilter;                                   // 0x0178(0x0068)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAttributeBasedFloat) == 0x000008, "Wrong alignment on FAttributeBasedFloat");
static_assert(sizeof(FAttributeBasedFloat) == 0x0001E0, "Wrong size on FAttributeBasedFloat");
static_assert(offsetof(FAttributeBasedFloat, Coefficient) == 0x000000, "Member 'FAttributeBasedFloat::Coefficient' has a wrong offset!");
static_assert(offsetof(FAttributeBasedFloat, PreMultiplyAdditiveValue) == 0x000038, "Member 'FAttributeBasedFloat::PreMultiplyAdditiveValue' has a wrong offset!");
static_assert(offsetof(FAttributeBasedFloat, PostMultiplyAdditiveValue) == 0x000070, "Member 'FAttributeBasedFloat::PostMultiplyAdditiveValue' has a wrong offset!");
static_assert(offsetof(FAttributeBasedFloat, BackingAttribute) == 0x0000A8, "Member 'FAttributeBasedFloat::BackingAttribute' has a wrong offset!");
static_assert(offsetof(FAttributeBasedFloat, AttributeCurve) == 0x0000F0, "Member 'FAttributeBasedFloat::AttributeCurve' has a wrong offset!");
static_assert(offsetof(FAttributeBasedFloat, AttributeCalculationType) == 0x000108, "Member 'FAttributeBasedFloat::AttributeCalculationType' has a wrong offset!");
static_assert(offsetof(FAttributeBasedFloat, FinalChannel) == 0x000109, "Member 'FAttributeBasedFloat::FinalChannel' has a wrong offset!");
static_assert(offsetof(FAttributeBasedFloat, SourceTagFilter) == 0x000110, "Member 'FAttributeBasedFloat::SourceTagFilter' has a wrong offset!");
static_assert(offsetof(FAttributeBasedFloat, TargetTagFilter) == 0x000178, "Member 'FAttributeBasedFloat::TargetTagFilter' has a wrong offset!");

// ScriptStruct GameplayAbilities.SetByCallerFloat
// 0x0018 (0x0018 - 0x0000)
struct FSetByCallerFloat final
{
public:
	class FName                                   DataName;                                          // 0x0000(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           DataTag;                                           // 0x000C(0x000C)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSetByCallerFloat) == 0x000004, "Wrong alignment on FSetByCallerFloat");
static_assert(sizeof(FSetByCallerFloat) == 0x000018, "Wrong size on FSetByCallerFloat");
static_assert(offsetof(FSetByCallerFloat, DataName) == 0x000000, "Member 'FSetByCallerFloat::DataName' has a wrong offset!");
static_assert(offsetof(FSetByCallerFloat, DataTag) == 0x00000C, "Member 'FSetByCallerFloat::DataTag' has a wrong offset!");

// ScriptStruct GameplayAbilities.GameplayEffectModifierMagnitude
// 0x0300 (0x0300 - 0x0000)
struct FGameplayEffectModifierMagnitude final
{
public:
	EGameplayEffectMagnitudeCalculation           MagnitudeCalculationType;                          // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FScalableFloat                         ScalableFloatMagnitude;                            // 0x0008(0x0038)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FAttributeBasedFloat                   AttributeBasedMagnitude;                           // 0x0040(0x01E0)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FCustomCalculationBasedFloat           CustomMagnitude;                                   // 0x0220(0x00C8)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FSetByCallerFloat                      SetByCallerMagnitude;                              // 0x02E8(0x0018)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FGameplayEffectModifierMagnitude) == 0x000008, "Wrong alignment on FGameplayEffectModifierMagnitude");
static_assert(sizeof(FGameplayEffectModifierMagnitude) == 0x000300, "Wrong size on FGameplayEffectModifierMagnitude");
static_assert(offsetof(FGameplayEffectModifierMagnitude, MagnitudeCalculationType) == 0x000000, "Member 'FGameplayEffectModifierMagnitude::MagnitudeCalculationType' has a wrong offset!");
static_assert(offsetof(FGameplayEffectModifierMagnitude, ScalableFloatMagnitude) == 0x000008, "Member 'FGameplayEffectModifierMagnitude::ScalableFloatMagnitude' has a wrong offset!");
static_assert(offsetof(FGameplayEffectModifierMagnitude, AttributeBasedMagnitude) == 0x000040, "Member 'FGameplayEffectModifierMagnitude::AttributeBasedMagnitude' has a wrong offset!");
static_assert(offsetof(FGameplayEffectModifierMagnitude, CustomMagnitude) == 0x000220, "Member 'FGameplayEffectModifierMagnitude::CustomMagnitude' has a wrong offset!");
static_assert(offsetof(FGameplayEffectModifierMagnitude, SetByCallerMagnitude) == 0x0002E8, "Member 'FGameplayEffectModifierMagnitude::SetByCallerMagnitude' has a wrong offset!");

// ScriptStruct GameplayAbilities.GameplayModEvaluationChannelSettings
// 0x0001 (0x0001 - 0x0000)
struct FGameplayModEvaluationChannelSettings final
{
public:
	EGameplayModEvaluationChannel                 Channel;                                           // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
};
static_assert(alignof(FGameplayModEvaluationChannelSettings) == 0x000001, "Wrong alignment on FGameplayModEvaluationChannelSettings");
static_assert(sizeof(FGameplayModEvaluationChannelSettings) == 0x000001, "Wrong size on FGameplayModEvaluationChannelSettings");
static_assert(offsetof(FGameplayModEvaluationChannelSettings, Channel) == 0x000000, "Member 'FGameplayModEvaluationChannelSettings::Channel' has a wrong offset!");

// ScriptStruct GameplayAbilities.GameplayEffectExecutionScopedModifierInfo
// 0x0590 (0x0590 - 0x0000)
struct FGameplayEffectExecutionScopedModifierInfo final
{
public:
	struct FGameplayEffectAttributeCaptureDefinition CapturedAttribute;                              // 0x0000(0x0048)(Edit, DisableEditOnInstance, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           TransientAggregatorIdentifier;                     // 0x0048(0x000C)(Edit, DisableEditOnInstance, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGameplayEffectScopedModifierAggregatorType   AggregatorType;                                    // 0x0054(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGameplayModOp                                ModifierOp;                                        // 0x0055(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_56[0x2];                                       // 0x0056(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayEffectModifierMagnitude       ModifierMagnitude;                                 // 0x0058(0x0300)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayModEvaluationChannelSettings  EvaluationChannelSettings;                         // 0x0358(0x0001)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_359[0x7];                                      // 0x0359(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagRequirements               SourceTags;                                        // 0x0360(0x0118)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTagRequirements               TargetTags;                                        // 0x0478(0x0118)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameplayEffectExecutionScopedModifierInfo) == 0x000008, "Wrong alignment on FGameplayEffectExecutionScopedModifierInfo");
static_assert(sizeof(FGameplayEffectExecutionScopedModifierInfo) == 0x000590, "Wrong size on FGameplayEffectExecutionScopedModifierInfo");
static_assert(offsetof(FGameplayEffectExecutionScopedModifierInfo, CapturedAttribute) == 0x000000, "Member 'FGameplayEffectExecutionScopedModifierInfo::CapturedAttribute' has a wrong offset!");
static_assert(offsetof(FGameplayEffectExecutionScopedModifierInfo, TransientAggregatorIdentifier) == 0x000048, "Member 'FGameplayEffectExecutionScopedModifierInfo::TransientAggregatorIdentifier' has a wrong offset!");
static_assert(offsetof(FGameplayEffectExecutionScopedModifierInfo, AggregatorType) == 0x000054, "Member 'FGameplayEffectExecutionScopedModifierInfo::AggregatorType' has a wrong offset!");
static_assert(offsetof(FGameplayEffectExecutionScopedModifierInfo, ModifierOp) == 0x000055, "Member 'FGameplayEffectExecutionScopedModifierInfo::ModifierOp' has a wrong offset!");
static_assert(offsetof(FGameplayEffectExecutionScopedModifierInfo, ModifierMagnitude) == 0x000058, "Member 'FGameplayEffectExecutionScopedModifierInfo::ModifierMagnitude' has a wrong offset!");
static_assert(offsetof(FGameplayEffectExecutionScopedModifierInfo, EvaluationChannelSettings) == 0x000358, "Member 'FGameplayEffectExecutionScopedModifierInfo::EvaluationChannelSettings' has a wrong offset!");
static_assert(offsetof(FGameplayEffectExecutionScopedModifierInfo, SourceTags) == 0x000360, "Member 'FGameplayEffectExecutionScopedModifierInfo::SourceTags' has a wrong offset!");
static_assert(offsetof(FGameplayEffectExecutionScopedModifierInfo, TargetTags) == 0x000478, "Member 'FGameplayEffectExecutionScopedModifierInfo::TargetTags' has a wrong offset!");

// ScriptStruct GameplayAbilities.GameplayAbilityRepAnimMontage
// 0x0128 (0x0128 - 0x0000)
struct FGameplayAbilityRepAnimMontage final
{
public:
	class UAnimMontage*                           AnimMontage;                                       // 0x0000(0x0008)(ZeroConstructor, RepSkip, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x88];                                       // 0x0008(0x0088)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PlayRate;                                          // 0x0090(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Position;                                          // 0x0094(0x0004)(ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendTime;                                         // 0x0098(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         NextSectionID;                                     // 0x009C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         PlayInstanceId;                                    // 0x009D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bRepPosition : 1;                                  // 0x009E(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         IsStopped : 1;                                     // 0x009E(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         SkipPositionCorrection : 1;                        // 0x009E(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSkipPlayRate : 1;                                 // 0x009E(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_9F[0x1];                                       // 0x009F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        OldAbilityID;                                      // 0x00A0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OldBlendTime;                                      // 0x00A4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         OldPlayInstanceId;                                 // 0x00A8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9[0x1];                                       // 0x00A9(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	uint16                                        IntMappedPosition;                                 // 0x00AA(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPredictionKey                         PredictionKey;                                     // 0x00B0(0x0070)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         SectionIdToPlay;                                   // 0x0120(0x0001)(ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_121[0x3];                                      // 0x0121(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        AbilityID;                                         // 0x0124(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameplayAbilityRepAnimMontage) == 0x000008, "Wrong alignment on FGameplayAbilityRepAnimMontage");
static_assert(sizeof(FGameplayAbilityRepAnimMontage) == 0x000128, "Wrong size on FGameplayAbilityRepAnimMontage");
static_assert(offsetof(FGameplayAbilityRepAnimMontage, AnimMontage) == 0x000000, "Member 'FGameplayAbilityRepAnimMontage::AnimMontage' has a wrong offset!");
static_assert(offsetof(FGameplayAbilityRepAnimMontage, PlayRate) == 0x000090, "Member 'FGameplayAbilityRepAnimMontage::PlayRate' has a wrong offset!");
static_assert(offsetof(FGameplayAbilityRepAnimMontage, Position) == 0x000094, "Member 'FGameplayAbilityRepAnimMontage::Position' has a wrong offset!");
static_assert(offsetof(FGameplayAbilityRepAnimMontage, BlendTime) == 0x000098, "Member 'FGameplayAbilityRepAnimMontage::BlendTime' has a wrong offset!");
static_assert(offsetof(FGameplayAbilityRepAnimMontage, NextSectionID) == 0x00009C, "Member 'FGameplayAbilityRepAnimMontage::NextSectionID' has a wrong offset!");
static_assert(offsetof(FGameplayAbilityRepAnimMontage, PlayInstanceId) == 0x00009D, "Member 'FGameplayAbilityRepAnimMontage::PlayInstanceId' has a wrong offset!");
static_assert(offsetof(FGameplayAbilityRepAnimMontage, OldAbilityID) == 0x0000A0, "Member 'FGameplayAbilityRepAnimMontage::OldAbilityID' has a wrong offset!");
static_assert(offsetof(FGameplayAbilityRepAnimMontage, OldBlendTime) == 0x0000A4, "Member 'FGameplayAbilityRepAnimMontage::OldBlendTime' has a wrong offset!");
static_assert(offsetof(FGameplayAbilityRepAnimMontage, OldPlayInstanceId) == 0x0000A8, "Member 'FGameplayAbilityRepAnimMontage::OldPlayInstanceId' has a wrong offset!");
static_assert(offsetof(FGameplayAbilityRepAnimMontage, IntMappedPosition) == 0x0000AA, "Member 'FGameplayAbilityRepAnimMontage::IntMappedPosition' has a wrong offset!");
static_assert(offsetof(FGameplayAbilityRepAnimMontage, PredictionKey) == 0x0000B0, "Member 'FGameplayAbilityRepAnimMontage::PredictionKey' has a wrong offset!");
static_assert(offsetof(FGameplayAbilityRepAnimMontage, SectionIdToPlay) == 0x000120, "Member 'FGameplayAbilityRepAnimMontage::SectionIdToPlay' has a wrong offset!");
static_assert(offsetof(FGameplayAbilityRepAnimMontage, AbilityID) == 0x000124, "Member 'FGameplayAbilityRepAnimMontage::AbilityID' has a wrong offset!");

// ScriptStruct GameplayAbilities.GameplayTargetDataFilterHandle
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FGameplayTargetDataFilterHandle final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayTargetDataFilterHandle) == 0x000008, "Wrong alignment on FGameplayTargetDataFilterHandle");
static_assert(sizeof(FGameplayTargetDataFilterHandle) == 0x000010, "Wrong size on FGameplayTargetDataFilterHandle");

// ScriptStruct GameplayAbilities.GameplayCueNotify_SoundInfo
// 0x00A8 (0x00A8 - 0x0000)
struct FGameplayCueNotify_SoundInfo final
{
public:
	struct FGameplayCueNotify_SpawnCondition      SpawnConditionOverride;                            // 0x0000(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayCueNotify_PlacementInfo       PlacementInfoOverride;                             // 0x0038(0x0048)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	class USoundBase*                             Sound;                                             // 0x0080(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             SoundCue;                                          // 0x0088(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LoopingFadeOutDuration;                            // 0x0090(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LoopingFadeVolumeLevel;                            // 0x0094(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayCueNotify_SoundParameterInterfaceInfo SoundParameterInterfaceInfo;               // 0x0098(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOverrideSpawnCondition : 1;                       // 0x00A4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverridePlacementInfo : 1;                        // 0x00A4(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseSoundParameterInterface : 1;                   // 0x00A4(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_A5[0x3];                                       // 0x00A5(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayCueNotify_SoundInfo) == 0x000008, "Wrong alignment on FGameplayCueNotify_SoundInfo");
static_assert(sizeof(FGameplayCueNotify_SoundInfo) == 0x0000A8, "Wrong size on FGameplayCueNotify_SoundInfo");
static_assert(offsetof(FGameplayCueNotify_SoundInfo, SpawnConditionOverride) == 0x000000, "Member 'FGameplayCueNotify_SoundInfo::SpawnConditionOverride' has a wrong offset!");
static_assert(offsetof(FGameplayCueNotify_SoundInfo, PlacementInfoOverride) == 0x000038, "Member 'FGameplayCueNotify_SoundInfo::PlacementInfoOverride' has a wrong offset!");
static_assert(offsetof(FGameplayCueNotify_SoundInfo, Sound) == 0x000080, "Member 'FGameplayCueNotify_SoundInfo::Sound' has a wrong offset!");
static_assert(offsetof(FGameplayCueNotify_SoundInfo, SoundCue) == 0x000088, "Member 'FGameplayCueNotify_SoundInfo::SoundCue' has a wrong offset!");
static_assert(offsetof(FGameplayCueNotify_SoundInfo, LoopingFadeOutDuration) == 0x000090, "Member 'FGameplayCueNotify_SoundInfo::LoopingFadeOutDuration' has a wrong offset!");
static_assert(offsetof(FGameplayCueNotify_SoundInfo, LoopingFadeVolumeLevel) == 0x000094, "Member 'FGameplayCueNotify_SoundInfo::LoopingFadeVolumeLevel' has a wrong offset!");
static_assert(offsetof(FGameplayCueNotify_SoundInfo, SoundParameterInterfaceInfo) == 0x000098, "Member 'FGameplayCueNotify_SoundInfo::SoundParameterInterfaceInfo' has a wrong offset!");

// ScriptStruct GameplayAbilities.GameplayCueNotify_CameraShakeInfo
// 0x00A0 (0x00A0 - 0x0000)
struct FGameplayCueNotify_CameraShakeInfo final
{
public:
	struct FGameplayCueNotify_SpawnCondition      SpawnConditionOverride;                            // 0x0000(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayCueNotify_PlacementInfo       PlacementInfoOverride;                             // 0x0038(0x0048)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	TSubclassOf<class UCameraShakeBase>           CameraShake;                                       // 0x0080(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShakeScale;                                        // 0x0088(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGameplayCueNotify_EffectPlaySpace            PlaySpace;                                         // 0x008C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8D[0x3];                                       // 0x008D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bOverrideSpawnCondition : 1;                       // 0x0090(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverridePlacementInfo : 1;                        // 0x0090(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bPlayInWorld : 1;                                  // 0x0090(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_91[0x3];                                       // 0x0091(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WorldInnerRadius;                                  // 0x0094(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WorldOuterRadius;                                  // 0x0098(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WorldFalloffExponent;                              // 0x009C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameplayCueNotify_CameraShakeInfo) == 0x000008, "Wrong alignment on FGameplayCueNotify_CameraShakeInfo");
static_assert(sizeof(FGameplayCueNotify_CameraShakeInfo) == 0x0000A0, "Wrong size on FGameplayCueNotify_CameraShakeInfo");
static_assert(offsetof(FGameplayCueNotify_CameraShakeInfo, SpawnConditionOverride) == 0x000000, "Member 'FGameplayCueNotify_CameraShakeInfo::SpawnConditionOverride' has a wrong offset!");
static_assert(offsetof(FGameplayCueNotify_CameraShakeInfo, PlacementInfoOverride) == 0x000038, "Member 'FGameplayCueNotify_CameraShakeInfo::PlacementInfoOverride' has a wrong offset!");
static_assert(offsetof(FGameplayCueNotify_CameraShakeInfo, CameraShake) == 0x000080, "Member 'FGameplayCueNotify_CameraShakeInfo::CameraShake' has a wrong offset!");
static_assert(offsetof(FGameplayCueNotify_CameraShakeInfo, ShakeScale) == 0x000088, "Member 'FGameplayCueNotify_CameraShakeInfo::ShakeScale' has a wrong offset!");
static_assert(offsetof(FGameplayCueNotify_CameraShakeInfo, PlaySpace) == 0x00008C, "Member 'FGameplayCueNotify_CameraShakeInfo::PlaySpace' has a wrong offset!");
static_assert(offsetof(FGameplayCueNotify_CameraShakeInfo, WorldInnerRadius) == 0x000094, "Member 'FGameplayCueNotify_CameraShakeInfo::WorldInnerRadius' has a wrong offset!");
static_assert(offsetof(FGameplayCueNotify_CameraShakeInfo, WorldOuterRadius) == 0x000098, "Member 'FGameplayCueNotify_CameraShakeInfo::WorldOuterRadius' has a wrong offset!");
static_assert(offsetof(FGameplayCueNotify_CameraShakeInfo, WorldFalloffExponent) == 0x00009C, "Member 'FGameplayCueNotify_CameraShakeInfo::WorldFalloffExponent' has a wrong offset!");

// ScriptStruct GameplayAbilities.GameplayCueNotify_CameraLensEffectInfo
// 0x0098 (0x0098 - 0x0000)
struct FGameplayCueNotify_CameraLensEffectInfo final
{
public:
	struct FGameplayCueNotify_SpawnCondition      SpawnConditionOverride;                            // 0x0000(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayCueNotify_PlacementInfo       PlacementInfoOverride;                             // 0x0038(0x0048)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     CameraLensEffect;                                  // 0x0080(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverrideSpawnCondition : 1;                       // 0x0088(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverridePlacementInfo : 1;                        // 0x0088(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bPlayInWorld : 1;                                  // 0x0088(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_89[0x3];                                       // 0x0089(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WorldInnerRadius;                                  // 0x008C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WorldOuterRadius;                                  // 0x0090(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_94[0x4];                                       // 0x0094(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayCueNotify_CameraLensEffectInfo) == 0x000008, "Wrong alignment on FGameplayCueNotify_CameraLensEffectInfo");
static_assert(sizeof(FGameplayCueNotify_CameraLensEffectInfo) == 0x000098, "Wrong size on FGameplayCueNotify_CameraLensEffectInfo");
static_assert(offsetof(FGameplayCueNotify_CameraLensEffectInfo, SpawnConditionOverride) == 0x000000, "Member 'FGameplayCueNotify_CameraLensEffectInfo::SpawnConditionOverride' has a wrong offset!");
static_assert(offsetof(FGameplayCueNotify_CameraLensEffectInfo, PlacementInfoOverride) == 0x000038, "Member 'FGameplayCueNotify_CameraLensEffectInfo::PlacementInfoOverride' has a wrong offset!");
static_assert(offsetof(FGameplayCueNotify_CameraLensEffectInfo, CameraLensEffect) == 0x000080, "Member 'FGameplayCueNotify_CameraLensEffectInfo::CameraLensEffect' has a wrong offset!");
static_assert(offsetof(FGameplayCueNotify_CameraLensEffectInfo, WorldInnerRadius) == 0x00008C, "Member 'FGameplayCueNotify_CameraLensEffectInfo::WorldInnerRadius' has a wrong offset!");
static_assert(offsetof(FGameplayCueNotify_CameraLensEffectInfo, WorldOuterRadius) == 0x000090, "Member 'FGameplayCueNotify_CameraLensEffectInfo::WorldOuterRadius' has a wrong offset!");

// ScriptStruct GameplayAbilities.GameplayCueNotify_ForceFeedbackInfo
// 0x00A8 (0x00A8 - 0x0000)
struct FGameplayCueNotify_ForceFeedbackInfo final
{
public:
	struct FGameplayCueNotify_SpawnCondition      SpawnConditionOverride;                            // 0x0000(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayCueNotify_PlacementInfo       PlacementInfoOverride;                             // 0x0038(0x0048)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	class UForceFeedbackEffect*                   ForceFeedbackEffect;                               // 0x0080(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ForceFeedbackTag;                                  // 0x0088(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bIsLooping : 1;                                    // 0x0094(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverrideSpawnCondition : 1;                       // 0x0094(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverridePlacementInfo : 1;                        // 0x0094(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bPlayInWorld : 1;                                  // 0x0094(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_95[0x3];                                       // 0x0095(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WorldIntensity;                                    // 0x0098(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UForceFeedbackAttenuation*              WorldAttenuation;                                  // 0x00A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameplayCueNotify_ForceFeedbackInfo) == 0x000008, "Wrong alignment on FGameplayCueNotify_ForceFeedbackInfo");
static_assert(sizeof(FGameplayCueNotify_ForceFeedbackInfo) == 0x0000A8, "Wrong size on FGameplayCueNotify_ForceFeedbackInfo");
static_assert(offsetof(FGameplayCueNotify_ForceFeedbackInfo, SpawnConditionOverride) == 0x000000, "Member 'FGameplayCueNotify_ForceFeedbackInfo::SpawnConditionOverride' has a wrong offset!");
static_assert(offsetof(FGameplayCueNotify_ForceFeedbackInfo, PlacementInfoOverride) == 0x000038, "Member 'FGameplayCueNotify_ForceFeedbackInfo::PlacementInfoOverride' has a wrong offset!");
static_assert(offsetof(FGameplayCueNotify_ForceFeedbackInfo, ForceFeedbackEffect) == 0x000080, "Member 'FGameplayCueNotify_ForceFeedbackInfo::ForceFeedbackEffect' has a wrong offset!");
static_assert(offsetof(FGameplayCueNotify_ForceFeedbackInfo, ForceFeedbackTag) == 0x000088, "Member 'FGameplayCueNotify_ForceFeedbackInfo::ForceFeedbackTag' has a wrong offset!");
static_assert(offsetof(FGameplayCueNotify_ForceFeedbackInfo, WorldIntensity) == 0x000098, "Member 'FGameplayCueNotify_ForceFeedbackInfo::WorldIntensity' has a wrong offset!");
static_assert(offsetof(FGameplayCueNotify_ForceFeedbackInfo, WorldAttenuation) == 0x0000A0, "Member 'FGameplayCueNotify_ForceFeedbackInfo::WorldAttenuation' has a wrong offset!");

// ScriptStruct GameplayAbilities.GameplayCueNotify_InputDevicePropertyInfo
// 0x0010 (0x0010 - 0x0000)
struct FGameplayCueNotify_InputDevicePropertyInfo final
{
public:
	TArray<TSubclassOf<class UInputDeviceProperty>> DeviceProperties;                                // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameplayCueNotify_InputDevicePropertyInfo) == 0x000008, "Wrong alignment on FGameplayCueNotify_InputDevicePropertyInfo");
static_assert(sizeof(FGameplayCueNotify_InputDevicePropertyInfo) == 0x000010, "Wrong size on FGameplayCueNotify_InputDevicePropertyInfo");
static_assert(offsetof(FGameplayCueNotify_InputDevicePropertyInfo, DeviceProperties) == 0x000000, "Member 'FGameplayCueNotify_InputDevicePropertyInfo::DeviceProperties' has a wrong offset!");

// ScriptStruct GameplayAbilities.GameplayCueNotify_LoopingEffects
// 0x0210 (0x0210 - 0x0000)
struct FGameplayCueNotify_LoopingEffects final
{
public:
	TArray<struct FGameplayCueNotify_ParticleInfo> LoopingParticles;                                 // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FGameplayCueNotify_SoundInfo>   LoopingSounds;                                     // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayCueNotify_CameraShakeInfo     LoopingCameraShake;                                // 0x0020(0x00A0)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayCueNotify_CameraLensEffectInfo LoopingCameraLensEffect;                          // 0x00C0(0x0098)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayCueNotify_ForceFeedbackInfo   LoopingForceFeedback;                              // 0x0158(0x00A8)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayCueNotify_InputDevicePropertyInfo LoopingInputDevicePropertyEffect;              // 0x0200(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FGameplayCueNotify_LoopingEffects) == 0x000008, "Wrong alignment on FGameplayCueNotify_LoopingEffects");
static_assert(sizeof(FGameplayCueNotify_LoopingEffects) == 0x000210, "Wrong size on FGameplayCueNotify_LoopingEffects");
static_assert(offsetof(FGameplayCueNotify_LoopingEffects, LoopingParticles) == 0x000000, "Member 'FGameplayCueNotify_LoopingEffects::LoopingParticles' has a wrong offset!");
static_assert(offsetof(FGameplayCueNotify_LoopingEffects, LoopingSounds) == 0x000010, "Member 'FGameplayCueNotify_LoopingEffects::LoopingSounds' has a wrong offset!");
static_assert(offsetof(FGameplayCueNotify_LoopingEffects, LoopingCameraShake) == 0x000020, "Member 'FGameplayCueNotify_LoopingEffects::LoopingCameraShake' has a wrong offset!");
static_assert(offsetof(FGameplayCueNotify_LoopingEffects, LoopingCameraLensEffect) == 0x0000C0, "Member 'FGameplayCueNotify_LoopingEffects::LoopingCameraLensEffect' has a wrong offset!");
static_assert(offsetof(FGameplayCueNotify_LoopingEffects, LoopingForceFeedback) == 0x000158, "Member 'FGameplayCueNotify_LoopingEffects::LoopingForceFeedback' has a wrong offset!");
static_assert(offsetof(FGameplayCueNotify_LoopingEffects, LoopingInputDevicePropertyEffect) == 0x000200, "Member 'FGameplayCueNotify_LoopingEffects::LoopingInputDevicePropertyEffect' has a wrong offset!");

// ScriptStruct GameplayAbilities.GameplayCueTag
// 0x000C (0x000C - 0x0000)
struct FGameplayCueTag final
{
public:
	struct FGameplayTag                           GameplayCueTag;                                    // 0x0000(0x000C)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameplayCueTag) == 0x000004, "Wrong alignment on FGameplayCueTag");
static_assert(sizeof(FGameplayCueTag) == 0x00000C, "Wrong size on FGameplayCueTag");
static_assert(offsetof(FGameplayCueTag, GameplayCueTag) == 0x000000, "Member 'FGameplayCueTag::GameplayCueTag' has a wrong offset!");

// ScriptStruct GameplayAbilities.PredictionDynamicParamHandle
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x08) FPredictionDynamicParamHandle final
{
public:
	bool                                          bIsHandleValid;                                    // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x1F];                                       // 0x0001(0x001F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPredictionDynamicParamHandle) == 0x000008, "Wrong alignment on FPredictionDynamicParamHandle");
static_assert(sizeof(FPredictionDynamicParamHandle) == 0x000020, "Wrong size on FPredictionDynamicParamHandle");
static_assert(offsetof(FPredictionDynamicParamHandle, bIsHandleValid) == 0x000000, "Member 'FPredictionDynamicParamHandle::bIsHandleValid' has a wrong offset!");

// ScriptStruct GameplayAbilities.AbilityDataSetDataPair
// 0x0048 (0x0048 - 0x0000)
struct FAbilityDataSetDataPair final
{
public:
	class FName                                   Key;                                               // 0x0000(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAbilityDataSetValueWrapper            Value;                                             // 0x0010(0x0038)(Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAbilityDataSetDataPair) == 0x000008, "Wrong alignment on FAbilityDataSetDataPair");
static_assert(sizeof(FAbilityDataSetDataPair) == 0x000048, "Wrong size on FAbilityDataSetDataPair");
static_assert(offsetof(FAbilityDataSetDataPair, Key) == 0x000000, "Member 'FAbilityDataSetDataPair::Key' has a wrong offset!");
static_assert(offsetof(FAbilityDataSetDataPair, Value) == 0x000010, "Member 'FAbilityDataSetDataPair::Value' has a wrong offset!");

// ScriptStruct GameplayAbilities.GameplayTagBlueprintPropertyMapping
// 0x0058 (0x0058 - 0x0000)
struct FGameplayTagBlueprintPropertyMapping final
{
public:
	struct FGameplayTag                           TagToMap;                                          // 0x0000(0x000C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TFieldPath<class FProperty>                   PropertyToEdit;                                    // 0x0010(0x0020)(Edit, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PropertyName;                                      // 0x0030(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  PropertyGuid;                                      // 0x003C(0x0010)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0xC];                                       // 0x004C(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayTagBlueprintPropertyMapping) == 0x000008, "Wrong alignment on FGameplayTagBlueprintPropertyMapping");
static_assert(sizeof(FGameplayTagBlueprintPropertyMapping) == 0x000058, "Wrong size on FGameplayTagBlueprintPropertyMapping");
static_assert(offsetof(FGameplayTagBlueprintPropertyMapping, TagToMap) == 0x000000, "Member 'FGameplayTagBlueprintPropertyMapping::TagToMap' has a wrong offset!");
static_assert(offsetof(FGameplayTagBlueprintPropertyMapping, PropertyToEdit) == 0x000010, "Member 'FGameplayTagBlueprintPropertyMapping::PropertyToEdit' has a wrong offset!");
static_assert(offsetof(FGameplayTagBlueprintPropertyMapping, PropertyName) == 0x000030, "Member 'FGameplayTagBlueprintPropertyMapping::PropertyName' has a wrong offset!");
static_assert(offsetof(FGameplayTagBlueprintPropertyMapping, PropertyGuid) == 0x00003C, "Member 'FGameplayTagBlueprintPropertyMapping::PropertyGuid' has a wrong offset!");

// ScriptStruct GameplayAbilities.MinimalReplicationTagOperationContainer
// 0x0018 (0x0128 - 0x0110)
struct FMinimalReplicationTagOperationContainer final : public FFastArraySerializer
{
public:
	class UAbilitySystemComponent*                Owner;                                             // 0x0110(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FMinimalReplicationTagOperation> Operations_Internal;                              // 0x0118(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMinimalReplicationTagOperationContainer) == 0x000008, "Wrong alignment on FMinimalReplicationTagOperationContainer");
static_assert(sizeof(FMinimalReplicationTagOperationContainer) == 0x000128, "Wrong size on FMinimalReplicationTagOperationContainer");
static_assert(offsetof(FMinimalReplicationTagOperationContainer, Owner) == 0x000110, "Member 'FMinimalReplicationTagOperationContainer::Owner' has a wrong offset!");
static_assert(offsetof(FMinimalReplicationTagOperationContainer, Operations_Internal) == 0x000118, "Member 'FMinimalReplicationTagOperationContainer::Operations_Internal' has a wrong offset!");

// ScriptStruct GameplayAbilities.GameplayEffectSpecHandle
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FGameplayEffectSpecHandle final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayEffectSpecHandle) == 0x000008, "Wrong alignment on FGameplayEffectSpecHandle");
static_assert(sizeof(FGameplayEffectSpecHandle) == 0x000010, "Wrong size on FGameplayEffectSpecHandle");

// ScriptStruct GameplayAbilities.ActiveGameplayCue
// 0x0258 (0x0270 - 0x0018)
struct FActiveGameplayCue final : public FFastArraySerializerItem
{
public:
	struct FGameplayTag                           GameplayCueTag;                                    // 0x0018(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPredictionKey                         PredictionKey;                                     // 0x0028(0x0070)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayCueParameters                 Parameters;                                        // 0x0098(0x01D0)(ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         SeverAddTime;                                      // 0x0268(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPredictivelyRemoved;                              // 0x026C(0x0001)(ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26D[0x3];                                      // 0x026D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FActiveGameplayCue) == 0x000008, "Wrong alignment on FActiveGameplayCue");
static_assert(sizeof(FActiveGameplayCue) == 0x000270, "Wrong size on FActiveGameplayCue");
static_assert(offsetof(FActiveGameplayCue, GameplayCueTag) == 0x000018, "Member 'FActiveGameplayCue::GameplayCueTag' has a wrong offset!");
static_assert(offsetof(FActiveGameplayCue, PredictionKey) == 0x000028, "Member 'FActiveGameplayCue::PredictionKey' has a wrong offset!");
static_assert(offsetof(FActiveGameplayCue, Parameters) == 0x000098, "Member 'FActiveGameplayCue::Parameters' has a wrong offset!");
static_assert(offsetof(FActiveGameplayCue, SeverAddTime) == 0x000268, "Member 'FActiveGameplayCue::SeverAddTime' has a wrong offset!");
static_assert(offsetof(FActiveGameplayCue, bPredictivelyRemoved) == 0x00026C, "Member 'FActiveGameplayCue::bPredictivelyRemoved' has a wrong offset!");

// ScriptStruct GameplayAbilities.ActiveGameplayCueContainer
// 0x0030 (0x0140 - 0x0110)
struct FActiveGameplayCueContainer final : public FFastArraySerializer
{
public:
	TArray<struct FActiveGameplayCue>             GameplayCues;                                      // 0x0110(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_120[0x8];                                      // 0x0120(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAbilitySystemComponent*                Owner;                                             // 0x0128(0x0008)(ExportObject, ZeroConstructor, InstancedReference, RepSkip, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FGameplayTag>                   PredictiveAddedNeedPredictableRemoveTags;          // 0x0130(0x0010)(ZeroConstructor, RepSkip, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FActiveGameplayCueContainer) == 0x000008, "Wrong alignment on FActiveGameplayCueContainer");
static_assert(sizeof(FActiveGameplayCueContainer) == 0x000140, "Wrong size on FActiveGameplayCueContainer");
static_assert(offsetof(FActiveGameplayCueContainer, GameplayCues) == 0x000110, "Member 'FActiveGameplayCueContainer::GameplayCues' has a wrong offset!");
static_assert(offsetof(FActiveGameplayCueContainer, Owner) == 0x000128, "Member 'FActiveGameplayCueContainer::Owner' has a wrong offset!");
static_assert(offsetof(FActiveGameplayCueContainer, PredictiveAddedNeedPredictableRemoveTags) == 0x000130, "Member 'FActiveGameplayCueContainer::PredictiveAddedNeedPredictableRemoveTags' has a wrong offset!");

// ScriptStruct GameplayAbilities.GameplayAbilityActivationInfo
// 0x01D8 (0x01D8 - 0x0000)
struct FGameplayAbilityActivationInfo final
{
public:
	EGameplayAbilityActivationMode                ActivationMode;                                    // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bCanBeEndedByOtherInstance : 1;                    // 0x0001(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2[0xE];                                        // 0x0002(0x000E)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPredictionKey                         PredictionChildKeyWhenActivated;                   // 0x0010(0x0070)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPredictionKey                         PredictionTimerKey;                                // 0x0080(0x0070)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPredictionKey                         PredictionDurationKey;                             // 0x00F0(0x0070)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_160[0x8];                                      // 0x0160(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPredictionKey                         PredictionKeyWhenActivated;                        // 0x0168(0x0070)(HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FGameplayAbilityActivationInfo) == 0x000008, "Wrong alignment on FGameplayAbilityActivationInfo");
static_assert(sizeof(FGameplayAbilityActivationInfo) == 0x0001D8, "Wrong size on FGameplayAbilityActivationInfo");
static_assert(offsetof(FGameplayAbilityActivationInfo, ActivationMode) == 0x000000, "Member 'FGameplayAbilityActivationInfo::ActivationMode' has a wrong offset!");
static_assert(offsetof(FGameplayAbilityActivationInfo, PredictionChildKeyWhenActivated) == 0x000010, "Member 'FGameplayAbilityActivationInfo::PredictionChildKeyWhenActivated' has a wrong offset!");
static_assert(offsetof(FGameplayAbilityActivationInfo, PredictionTimerKey) == 0x000080, "Member 'FGameplayAbilityActivationInfo::PredictionTimerKey' has a wrong offset!");
static_assert(offsetof(FGameplayAbilityActivationInfo, PredictionDurationKey) == 0x0000F0, "Member 'FGameplayAbilityActivationInfo::PredictionDurationKey' has a wrong offset!");
static_assert(offsetof(FGameplayAbilityActivationInfo, PredictionKeyWhenActivated) == 0x000168, "Member 'FGameplayAbilityActivationInfo::PredictionKeyWhenActivated' has a wrong offset!");

// ScriptStruct GameplayAbilities.GameplayAbilitySpec
// 0x0388 (0x03A0 - 0x0018)
struct FGameplayAbilitySpec final : public FFastArraySerializerItem
{
public:
	struct FGameplayAbilitySpecHandle             Handle;                                            // 0x0018(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UGameplayAbility*                       Ability;                                           // 0x0020(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPredictionKey                         AbilitySpecKey;                                    // 0x0028(0x0070)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Level;                                             // 0x0098(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InputID;                                           // 0x009C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AbilityID;                                         // 0x00A0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UObject>                 SourceObject;                                      // 0x00A4(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ActiveCount;                                       // 0x00AC(0x0001)(ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         InputPressed : 1;                                  // 0x00AD(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         RemoveAfterActivation : 1;                         // 0x00AD(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         PendingRemove : 1;                                 // 0x00AD(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bActivateOnce : 1;                                 // 0x00AD(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_AE[0x12];                                      // 0x00AE(0x0012)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayAbilityActivationInfo         ActivationInfo;                                    // 0x00C0(0x01D8)(RepSkip, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  DynamicAbilityTags;                                // 0x0298(0x0068)(NativeAccessSpecifierPublic)
	TArray<class UGameplayAbility*>               NonReplicatedInstances;                            // 0x0300(0x0010)(ZeroConstructor, RepSkip, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class UGameplayAbility*>               ReplicatedInstances;                               // 0x0310(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	class UGameplayAbilityDataSet*                NonReplicatedAbilityDataSet;                       // 0x0320(0x0008)(ZeroConstructor, RepSkip, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameplayAbilityDataSet*                ReplicatedAbilityDataSet;                          // 0x0328(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ActivateOnceImmediately;                           // 0x0330(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bConfirmInit;                                      // 0x0331(0x0001)(ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_332[0x2];                                      // 0x0332(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           AbilityStatus;                                     // 0x0334(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWasCancelled;                                     // 0x0340(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_341[0x3];                                      // 0x0341(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FActiveGameplayEffectHandle            GameplayEffectHandle;                              // 0x0344(0x0008)(RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34C[0x54];                                     // 0x034C(0x0054)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayAbilitySpec) == 0x000008, "Wrong alignment on FGameplayAbilitySpec");
static_assert(sizeof(FGameplayAbilitySpec) == 0x0003A0, "Wrong size on FGameplayAbilitySpec");
static_assert(offsetof(FGameplayAbilitySpec, Handle) == 0x000018, "Member 'FGameplayAbilitySpec::Handle' has a wrong offset!");
static_assert(offsetof(FGameplayAbilitySpec, Ability) == 0x000020, "Member 'FGameplayAbilitySpec::Ability' has a wrong offset!");
static_assert(offsetof(FGameplayAbilitySpec, AbilitySpecKey) == 0x000028, "Member 'FGameplayAbilitySpec::AbilitySpecKey' has a wrong offset!");
static_assert(offsetof(FGameplayAbilitySpec, Level) == 0x000098, "Member 'FGameplayAbilitySpec::Level' has a wrong offset!");
static_assert(offsetof(FGameplayAbilitySpec, InputID) == 0x00009C, "Member 'FGameplayAbilitySpec::InputID' has a wrong offset!");
static_assert(offsetof(FGameplayAbilitySpec, AbilityID) == 0x0000A0, "Member 'FGameplayAbilitySpec::AbilityID' has a wrong offset!");
static_assert(offsetof(FGameplayAbilitySpec, SourceObject) == 0x0000A4, "Member 'FGameplayAbilitySpec::SourceObject' has a wrong offset!");
static_assert(offsetof(FGameplayAbilitySpec, ActiveCount) == 0x0000AC, "Member 'FGameplayAbilitySpec::ActiveCount' has a wrong offset!");
static_assert(offsetof(FGameplayAbilitySpec, ActivationInfo) == 0x0000C0, "Member 'FGameplayAbilitySpec::ActivationInfo' has a wrong offset!");
static_assert(offsetof(FGameplayAbilitySpec, DynamicAbilityTags) == 0x000298, "Member 'FGameplayAbilitySpec::DynamicAbilityTags' has a wrong offset!");
static_assert(offsetof(FGameplayAbilitySpec, NonReplicatedInstances) == 0x000300, "Member 'FGameplayAbilitySpec::NonReplicatedInstances' has a wrong offset!");
static_assert(offsetof(FGameplayAbilitySpec, ReplicatedInstances) == 0x000310, "Member 'FGameplayAbilitySpec::ReplicatedInstances' has a wrong offset!");
static_assert(offsetof(FGameplayAbilitySpec, NonReplicatedAbilityDataSet) == 0x000320, "Member 'FGameplayAbilitySpec::NonReplicatedAbilityDataSet' has a wrong offset!");
static_assert(offsetof(FGameplayAbilitySpec, ReplicatedAbilityDataSet) == 0x000328, "Member 'FGameplayAbilitySpec::ReplicatedAbilityDataSet' has a wrong offset!");
static_assert(offsetof(FGameplayAbilitySpec, ActivateOnceImmediately) == 0x000330, "Member 'FGameplayAbilitySpec::ActivateOnceImmediately' has a wrong offset!");
static_assert(offsetof(FGameplayAbilitySpec, bConfirmInit) == 0x000331, "Member 'FGameplayAbilitySpec::bConfirmInit' has a wrong offset!");
static_assert(offsetof(FGameplayAbilitySpec, AbilityStatus) == 0x000334, "Member 'FGameplayAbilitySpec::AbilityStatus' has a wrong offset!");
static_assert(offsetof(FGameplayAbilitySpec, bWasCancelled) == 0x000340, "Member 'FGameplayAbilitySpec::bWasCancelled' has a wrong offset!");
static_assert(offsetof(FGameplayAbilitySpec, GameplayEffectHandle) == 0x000344, "Member 'FGameplayAbilitySpec::GameplayEffectHandle' has a wrong offset!");

// ScriptStruct GameplayAbilities.AbilityEndContext
// 0x00D0 (0x00D0 - 0x0000)
struct alignas(0x08) FAbilityEndContext final
{
public:
	uint8                                         Pad_0[0xD0];                                       // 0x0000(0x00D0)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAbilityEndContext) == 0x000008, "Wrong alignment on FAbilityEndContext");
static_assert(sizeof(FAbilityEndContext) == 0x0000D0, "Wrong size on FAbilityEndContext");

// ScriptStruct GameplayAbilities.GameplayAbilitySpecConfig
// 0x0050 (0x0050 - 0x0000)
struct FGameplayAbilitySpecConfig final
{
public:
	TSubclassOf<class UGameplayAbility>           Ability;                                           // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ActivateOnceImmediately;                           // 0x0008(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AbilityID;                                         // 0x000C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FScalableFloat                         LevelScalableFloat;                                // 0x0010(0x0038)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         InputID;                                           // 0x0048(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGameplayEffectGrantedAbilityRemovePolicy     RemovalPolicy;                                     // 0x004C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayAbilitySpecConfig) == 0x000008, "Wrong alignment on FGameplayAbilitySpecConfig");
static_assert(sizeof(FGameplayAbilitySpecConfig) == 0x000050, "Wrong size on FGameplayAbilitySpecConfig");
static_assert(offsetof(FGameplayAbilitySpecConfig, Ability) == 0x000000, "Member 'FGameplayAbilitySpecConfig::Ability' has a wrong offset!");
static_assert(offsetof(FGameplayAbilitySpecConfig, ActivateOnceImmediately) == 0x000008, "Member 'FGameplayAbilitySpecConfig::ActivateOnceImmediately' has a wrong offset!");
static_assert(offsetof(FGameplayAbilitySpecConfig, AbilityID) == 0x00000C, "Member 'FGameplayAbilitySpecConfig::AbilityID' has a wrong offset!");
static_assert(offsetof(FGameplayAbilitySpecConfig, LevelScalableFloat) == 0x000010, "Member 'FGameplayAbilitySpecConfig::LevelScalableFloat' has a wrong offset!");
static_assert(offsetof(FGameplayAbilitySpecConfig, InputID) == 0x000048, "Member 'FGameplayAbilitySpecConfig::InputID' has a wrong offset!");
static_assert(offsetof(FGameplayAbilitySpecConfig, RemovalPolicy) == 0x00004C, "Member 'FGameplayAbilitySpecConfig::RemovalPolicy' has a wrong offset!");

// ScriptStruct GameplayAbilities.ObjectPoolItems
// 0x0010 (0x0010 - 0x0000)
struct FObjectPoolItems final
{
public:
	TArray<class UObject*>                        Items;                                             // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FObjectPoolItems) == 0x000008, "Wrong alignment on FObjectPoolItems");
static_assert(sizeof(FObjectPoolItems) == 0x000010, "Wrong size on FObjectPoolItems");
static_assert(offsetof(FObjectPoolItems, Items) == 0x000000, "Member 'FObjectPoolItems::Items' has a wrong offset!");

// ScriptStruct GameplayAbilities.GameplayEffectQuery
// 0x0208 (0x0208 - 0x0000)
struct FGameplayEffectQuery final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void(const struct FActiveGameplayEffect& Effect, bool* bMatches)> CustomMatchDelegate_BP; // 0x0010(0x0014)(BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x14];                                      // 0x0024(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagQuery                      OwningTagQuery;                                    // 0x0038(0x0048)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FGameplayTagQuery                      EffectTagQuery;                                    // 0x0080(0x0048)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FGameplayTagQuery                      SourceTagQuery;                                    // 0x00C8(0x0048)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FGameplayTagQuery                      SourceAggregateTagQuery;                           // 0x0110(0x0048)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FGameplayAttribute                     ModifyingAttribute;                                // 0x0158(0x0040)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                EffectSource;                                      // 0x0198(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayEffect>            EffectDefinition;                                  // 0x01A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnorePredictEffect;                              // 0x01A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreInhibit;                                    // 0x01A9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreSelfAddEffect;                              // 0x01AA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1AB[0x5];                                      // 0x01AB(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagQuery                      IgnoreTagQuery;                                    // 0x01B0(0x0048)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F8[0x10];                                     // 0x01F8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayEffectQuery) == 0x000008, "Wrong alignment on FGameplayEffectQuery");
static_assert(sizeof(FGameplayEffectQuery) == 0x000208, "Wrong size on FGameplayEffectQuery");
static_assert(offsetof(FGameplayEffectQuery, CustomMatchDelegate_BP) == 0x000010, "Member 'FGameplayEffectQuery::CustomMatchDelegate_BP' has a wrong offset!");
static_assert(offsetof(FGameplayEffectQuery, OwningTagQuery) == 0x000038, "Member 'FGameplayEffectQuery::OwningTagQuery' has a wrong offset!");
static_assert(offsetof(FGameplayEffectQuery, EffectTagQuery) == 0x000080, "Member 'FGameplayEffectQuery::EffectTagQuery' has a wrong offset!");
static_assert(offsetof(FGameplayEffectQuery, SourceTagQuery) == 0x0000C8, "Member 'FGameplayEffectQuery::SourceTagQuery' has a wrong offset!");
static_assert(offsetof(FGameplayEffectQuery, SourceAggregateTagQuery) == 0x000110, "Member 'FGameplayEffectQuery::SourceAggregateTagQuery' has a wrong offset!");
static_assert(offsetof(FGameplayEffectQuery, ModifyingAttribute) == 0x000158, "Member 'FGameplayEffectQuery::ModifyingAttribute' has a wrong offset!");
static_assert(offsetof(FGameplayEffectQuery, EffectSource) == 0x000198, "Member 'FGameplayEffectQuery::EffectSource' has a wrong offset!");
static_assert(offsetof(FGameplayEffectQuery, EffectDefinition) == 0x0001A0, "Member 'FGameplayEffectQuery::EffectDefinition' has a wrong offset!");
static_assert(offsetof(FGameplayEffectQuery, bIgnorePredictEffect) == 0x0001A8, "Member 'FGameplayEffectQuery::bIgnorePredictEffect' has a wrong offset!");
static_assert(offsetof(FGameplayEffectQuery, bIgnoreInhibit) == 0x0001A9, "Member 'FGameplayEffectQuery::bIgnoreInhibit' has a wrong offset!");
static_assert(offsetof(FGameplayEffectQuery, bIgnoreSelfAddEffect) == 0x0001AA, "Member 'FGameplayEffectQuery::bIgnoreSelfAddEffect' has a wrong offset!");
static_assert(offsetof(FGameplayEffectQuery, IgnoreTagQuery) == 0x0001B0, "Member 'FGameplayEffectQuery::IgnoreTagQuery' has a wrong offset!");

// ScriptStruct GameplayAbilities.GameplayModifierEvaluatedData
// 0x0078 (0x0078 - 0x0000)
struct FGameplayModifierEvaluatedData final
{
public:
	struct FGameplayAttribute                     Attribute;                                         // 0x0000(0x0040)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGameplayModOp                                ModifierOp;                                        // 0x0040(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Magnitude;                                         // 0x0044(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentMagnitude;                                  // 0x0048(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PreMagnitudePer;                                   // 0x004C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PreMagnitude;                                      // 0x0050(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DiffusionFactor;                                   // 0x0054(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SourceFactor;                                      // 0x0058(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FActiveGameplayEffectHandle            Handle;                                            // 0x0060(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FActiveGameplayEffectHandle            TargetHandle;                                      // 0x0068(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsValid;                                           // 0x0070(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IgnoreExecuteMod;                                  // 0x0071(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_72[0x6];                                       // 0x0072(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayModifierEvaluatedData) == 0x000008, "Wrong alignment on FGameplayModifierEvaluatedData");
static_assert(sizeof(FGameplayModifierEvaluatedData) == 0x000078, "Wrong size on FGameplayModifierEvaluatedData");
static_assert(offsetof(FGameplayModifierEvaluatedData, Attribute) == 0x000000, "Member 'FGameplayModifierEvaluatedData::Attribute' has a wrong offset!");
static_assert(offsetof(FGameplayModifierEvaluatedData, ModifierOp) == 0x000040, "Member 'FGameplayModifierEvaluatedData::ModifierOp' has a wrong offset!");
static_assert(offsetof(FGameplayModifierEvaluatedData, Magnitude) == 0x000044, "Member 'FGameplayModifierEvaluatedData::Magnitude' has a wrong offset!");
static_assert(offsetof(FGameplayModifierEvaluatedData, CurrentMagnitude) == 0x000048, "Member 'FGameplayModifierEvaluatedData::CurrentMagnitude' has a wrong offset!");
static_assert(offsetof(FGameplayModifierEvaluatedData, PreMagnitudePer) == 0x00004C, "Member 'FGameplayModifierEvaluatedData::PreMagnitudePer' has a wrong offset!");
static_assert(offsetof(FGameplayModifierEvaluatedData, PreMagnitude) == 0x000050, "Member 'FGameplayModifierEvaluatedData::PreMagnitude' has a wrong offset!");
static_assert(offsetof(FGameplayModifierEvaluatedData, DiffusionFactor) == 0x000054, "Member 'FGameplayModifierEvaluatedData::DiffusionFactor' has a wrong offset!");
static_assert(offsetof(FGameplayModifierEvaluatedData, SourceFactor) == 0x000058, "Member 'FGameplayModifierEvaluatedData::SourceFactor' has a wrong offset!");
static_assert(offsetof(FGameplayModifierEvaluatedData, Handle) == 0x000060, "Member 'FGameplayModifierEvaluatedData::Handle' has a wrong offset!");
static_assert(offsetof(FGameplayModifierEvaluatedData, TargetHandle) == 0x000068, "Member 'FGameplayModifierEvaluatedData::TargetHandle' has a wrong offset!");
static_assert(offsetof(FGameplayModifierEvaluatedData, IsValid) == 0x000070, "Member 'FGameplayModifierEvaluatedData::IsValid' has a wrong offset!");
static_assert(offsetof(FGameplayModifierEvaluatedData, IgnoreExecuteMod) == 0x000071, "Member 'FGameplayModifierEvaluatedData::IgnoreExecuteMod' has a wrong offset!");

// ScriptStruct GameplayAbilities.GameplayEffectSpecForRPC
// 0x0070 (0x0070 - 0x0000)
struct FGameplayEffectSpecForRPC final
{
public:
	class UGameplayEffect*                        Def;                                               // 0x0000(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Period;                                            // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGameplayEffectCue>             GameplayCues;                                      // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FGameplayEffectModifiedAttribute> ModifiedAttributes;                              // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FGameplayEffectContextHandle           EffectContext;                                     // 0x0030(0x0018)(NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0048(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Level;                                             // 0x004C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AbilityLevel;                                      // 0x0050(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SkinID;                                            // 0x0054(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int64>                                 SkinFXSlots;                                       // 0x0058(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         UID;                                               // 0x0068(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BuffID;                                            // 0x006C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameplayEffectSpecForRPC) == 0x000008, "Wrong alignment on FGameplayEffectSpecForRPC");
static_assert(sizeof(FGameplayEffectSpecForRPC) == 0x000070, "Wrong size on FGameplayEffectSpecForRPC");
static_assert(offsetof(FGameplayEffectSpecForRPC, Def) == 0x000000, "Member 'FGameplayEffectSpecForRPC::Def' has a wrong offset!");
static_assert(offsetof(FGameplayEffectSpecForRPC, Period) == 0x000008, "Member 'FGameplayEffectSpecForRPC::Period' has a wrong offset!");
static_assert(offsetof(FGameplayEffectSpecForRPC, GameplayCues) == 0x000010, "Member 'FGameplayEffectSpecForRPC::GameplayCues' has a wrong offset!");
static_assert(offsetof(FGameplayEffectSpecForRPC, ModifiedAttributes) == 0x000020, "Member 'FGameplayEffectSpecForRPC::ModifiedAttributes' has a wrong offset!");
static_assert(offsetof(FGameplayEffectSpecForRPC, EffectContext) == 0x000030, "Member 'FGameplayEffectSpecForRPC::EffectContext' has a wrong offset!");
static_assert(offsetof(FGameplayEffectSpecForRPC, Duration) == 0x000048, "Member 'FGameplayEffectSpecForRPC::Duration' has a wrong offset!");
static_assert(offsetof(FGameplayEffectSpecForRPC, Level) == 0x00004C, "Member 'FGameplayEffectSpecForRPC::Level' has a wrong offset!");
static_assert(offsetof(FGameplayEffectSpecForRPC, AbilityLevel) == 0x000050, "Member 'FGameplayEffectSpecForRPC::AbilityLevel' has a wrong offset!");
static_assert(offsetof(FGameplayEffectSpecForRPC, SkinID) == 0x000054, "Member 'FGameplayEffectSpecForRPC::SkinID' has a wrong offset!");
static_assert(offsetof(FGameplayEffectSpecForRPC, SkinFXSlots) == 0x000058, "Member 'FGameplayEffectSpecForRPC::SkinFXSlots' has a wrong offset!");
static_assert(offsetof(FGameplayEffectSpecForRPC, UID) == 0x000068, "Member 'FGameplayEffectSpecForRPC::UID' has a wrong offset!");
static_assert(offsetof(FGameplayEffectSpecForRPC, BuffID) == 0x00006C, "Member 'FGameplayEffectSpecForRPC::BuffID' has a wrong offset!");

// ScriptStruct GameplayAbilities.GameplayCueNotifyActorClassArray
// 0x0050 (0x0050 - 0x0000)
struct FGameplayCueNotifyActorClassArray final
{
public:
	TSet<TSubclassOf<class UObject>>              CueActorClasses;                                   // 0x0000(0x0050)(Transient, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameplayCueNotifyActorClassArray) == 0x000008, "Wrong alignment on FGameplayCueNotifyActorClassArray");
static_assert(sizeof(FGameplayCueNotifyActorClassArray) == 0x000050, "Wrong size on FGameplayCueNotifyActorClassArray");
static_assert(offsetof(FGameplayCueNotifyActorClassArray, CueActorClasses) == 0x000000, "Member 'FGameplayCueNotifyActorClassArray::CueActorClasses' has a wrong offset!");

// ScriptStruct GameplayAbilities.PredictionKeyContext
// 0x0070 (0x0070 - 0x0000)
struct FPredictionKeyContext final
{
public:
	class FString                                 Key;                                               // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 KeyDebugString;                                    // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UAbilitySystemComponent> ASC;                                               // 0x0020(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bImportantKey;                                     // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPredictionKeyState                           KeyState;                                          // 0x0029(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPredictionKeyState                           PendingKeyState;                                   // 0x002A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B[0x1];                                       // 0x002B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UseKeyTime;                                        // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeoutTime;                                       // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecycleTime;                                       // 0x0034(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x38];                                      // 0x0038(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPredictionKeyContext) == 0x000008, "Wrong alignment on FPredictionKeyContext");
static_assert(sizeof(FPredictionKeyContext) == 0x000070, "Wrong size on FPredictionKeyContext");
static_assert(offsetof(FPredictionKeyContext, Key) == 0x000000, "Member 'FPredictionKeyContext::Key' has a wrong offset!");
static_assert(offsetof(FPredictionKeyContext, KeyDebugString) == 0x000010, "Member 'FPredictionKeyContext::KeyDebugString' has a wrong offset!");
static_assert(offsetof(FPredictionKeyContext, ASC) == 0x000020, "Member 'FPredictionKeyContext::ASC' has a wrong offset!");
static_assert(offsetof(FPredictionKeyContext, bImportantKey) == 0x000028, "Member 'FPredictionKeyContext::bImportantKey' has a wrong offset!");
static_assert(offsetof(FPredictionKeyContext, KeyState) == 0x000029, "Member 'FPredictionKeyContext::KeyState' has a wrong offset!");
static_assert(offsetof(FPredictionKeyContext, PendingKeyState) == 0x00002A, "Member 'FPredictionKeyContext::PendingKeyState' has a wrong offset!");
static_assert(offsetof(FPredictionKeyContext, UseKeyTime) == 0x00002C, "Member 'FPredictionKeyContext::UseKeyTime' has a wrong offset!");
static_assert(offsetof(FPredictionKeyContext, TimeoutTime) == 0x000030, "Member 'FPredictionKeyContext::TimeoutTime' has a wrong offset!");
static_assert(offsetof(FPredictionKeyContext, RecycleTime) == 0x000034, "Member 'FPredictionKeyContext::RecycleTime' has a wrong offset!");

// ScriptStruct GameplayAbilities.GameplayAbilitySpecContainer
// 0x0018 (0x0128 - 0x0110)
struct FGameplayAbilitySpecContainer final : public FFastArraySerializer
{
public:
	TArray<struct FGameplayAbilitySpec>           Items;                                             // 0x0110(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class UAbilitySystemComponent*                Owner;                                             // 0x0120(0x0008)(ExportObject, ZeroConstructor, InstancedReference, RepSkip, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameplayAbilitySpecContainer) == 0x000008, "Wrong alignment on FGameplayAbilitySpecContainer");
static_assert(sizeof(FGameplayAbilitySpecContainer) == 0x000128, "Wrong size on FGameplayAbilitySpecContainer");
static_assert(offsetof(FGameplayAbilitySpecContainer, Items) == 0x000110, "Member 'FGameplayAbilitySpecContainer::Items' has a wrong offset!");
static_assert(offsetof(FGameplayAbilitySpecContainer, Owner) == 0x000120, "Member 'FGameplayAbilitySpecContainer::Owner' has a wrong offset!");

// ScriptStruct GameplayAbilities.AbilityActivationExtraInfo
// 0x0038 (0x0038 - 0x0000)
struct alignas(0x08) FAbilityActivationExtraInfo final
{
public:
	uint8                                         Pad_0[0x38];                                       // 0x0000(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAbilityActivationExtraInfo) == 0x000008, "Wrong alignment on FAbilityActivationExtraInfo");
static_assert(sizeof(FAbilityActivationExtraInfo) == 0x000038, "Wrong size on FAbilityActivationExtraInfo");

// ScriptStruct GameplayAbilities.NetSerializeScriptStructCache
// 0x0010 (0x0010 - 0x0000)
struct FNetSerializeScriptStructCache final
{
public:
	TArray<class UScriptStruct*>                  ScriptStructs;                                     // 0x0000(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNetSerializeScriptStructCache) == 0x000008, "Wrong alignment on FNetSerializeScriptStructCache");
static_assert(sizeof(FNetSerializeScriptStructCache) == 0x000010, "Wrong size on FNetSerializeScriptStructCache");
static_assert(offsetof(FNetSerializeScriptStructCache, ScriptStructs) == 0x000000, "Member 'FNetSerializeScriptStructCache::ScriptStructs' has a wrong offset!");

// ScriptStruct GameplayAbilities.ReplicatedPredictionKeyItem
// 0x0070 (0x0088 - 0x0018)
struct FReplicatedPredictionKeyItem final : public FFastArraySerializerItem
{
public:
	struct FPredictionKey                         PredictionKey;                                     // 0x0018(0x0070)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FReplicatedPredictionKeyItem) == 0x000008, "Wrong alignment on FReplicatedPredictionKeyItem");
static_assert(sizeof(FReplicatedPredictionKeyItem) == 0x000088, "Wrong size on FReplicatedPredictionKeyItem");
static_assert(offsetof(FReplicatedPredictionKeyItem, PredictionKey) == 0x000018, "Member 'FReplicatedPredictionKeyItem::PredictionKey' has a wrong offset!");

// ScriptStruct GameplayAbilities.ReplicatedPredictionKeyMap
// 0x0018 (0x0128 - 0x0110)
struct FReplicatedPredictionKeyMap final : public FFastArraySerializer
{
public:
	TArray<struct FReplicatedPredictionKeyItem>   PredictionKeys;                                    // 0x0110(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_120[0x8];                                      // 0x0120(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FReplicatedPredictionKeyMap) == 0x000008, "Wrong alignment on FReplicatedPredictionKeyMap");
static_assert(sizeof(FReplicatedPredictionKeyMap) == 0x000128, "Wrong size on FReplicatedPredictionKeyMap");
static_assert(offsetof(FReplicatedPredictionKeyMap, PredictionKeys) == 0x000110, "Member 'FReplicatedPredictionKeyMap::PredictionKeys' has a wrong offset!");

// ScriptStruct GameplayAbilities.MinimalReplicationTagCountMap
// 0x00B8 (0x00B8 - 0x0000)
struct FMinimalReplicationTagCountMap final
{
public:
	uint8                                         Pad_0[0xA8];                                       // 0x0000(0x00A8)(Fixing Size After Last Property [ Dumper-7 ])
	class UAbilitySystemComponent*                Owner;                                             // 0x00A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B0[0x8];                                       // 0x00B0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMinimalReplicationTagCountMap) == 0x000008, "Wrong alignment on FMinimalReplicationTagCountMap");
static_assert(sizeof(FMinimalReplicationTagCountMap) == 0x0000B8, "Wrong size on FMinimalReplicationTagCountMap");
static_assert(offsetof(FMinimalReplicationTagCountMap, Owner) == 0x0000A8, "Member 'FMinimalReplicationTagCountMap::Owner' has a wrong offset!");

// ScriptStruct GameplayAbilities.GameplayCuePendingExecute
// 0x02E0 (0x02E0 - 0x0000)
struct FGameplayCuePendingExecute final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPredictionKey                         PredictionKey;                                     // 0x0020(0x0070)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGameplayCuePayloadType                       PayloadType;                                       // 0x0090(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x7];                                       // 0x0091(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAbilitySystemComponent*                OwningComponent;                                   // 0x0098(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEffectSpecForRPC              FromSpec;                                          // 0x00A0(0x0070)(NativeAccessSpecifierPublic)
	struct FGameplayCueParameters                 CueParameters;                                     // 0x0110(0x01D0)(ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameplayCuePendingExecute) == 0x000008, "Wrong alignment on FGameplayCuePendingExecute");
static_assert(sizeof(FGameplayCuePendingExecute) == 0x0002E0, "Wrong size on FGameplayCuePendingExecute");
static_assert(offsetof(FGameplayCuePendingExecute, PredictionKey) == 0x000020, "Member 'FGameplayCuePendingExecute::PredictionKey' has a wrong offset!");
static_assert(offsetof(FGameplayCuePendingExecute, PayloadType) == 0x000090, "Member 'FGameplayCuePendingExecute::PayloadType' has a wrong offset!");
static_assert(offsetof(FGameplayCuePendingExecute, OwningComponent) == 0x000098, "Member 'FGameplayCuePendingExecute::OwningComponent' has a wrong offset!");
static_assert(offsetof(FGameplayCuePendingExecute, FromSpec) == 0x0000A0, "Member 'FGameplayCuePendingExecute::FromSpec' has a wrong offset!");
static_assert(offsetof(FGameplayCuePendingExecute, CueParameters) == 0x000110, "Member 'FGameplayCuePendingExecute::CueParameters' has a wrong offset!");

// ScriptStruct GameplayAbilities.GameplayAbilityTargetingLocationInfoNetSerializerConfig
// 0x0001 (0x0001 - 0x0000)
struct FGameplayAbilityTargetingLocationInfoNetSerializerConfig final : public FNetSerializerConfig
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayAbilityTargetingLocationInfoNetSerializerConfig) == 0x000001, "Wrong alignment on FGameplayAbilityTargetingLocationInfoNetSerializerConfig");
static_assert(sizeof(FGameplayAbilityTargetingLocationInfoNetSerializerConfig) == 0x000001, "Wrong size on FGameplayAbilityTargetingLocationInfoNetSerializerConfig");

// ScriptStruct GameplayAbilities.GameplayTagBlueprintPropertyMap
// 0x0020 (0x0020 - 0x0000)
struct FGameplayTagBlueprintPropertyMap final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGameplayTagBlueprintPropertyMapping> PropertyMappings;                            // 0x0010(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FGameplayTagBlueprintPropertyMap) == 0x000008, "Wrong alignment on FGameplayTagBlueprintPropertyMap");
static_assert(sizeof(FGameplayTagBlueprintPropertyMap) == 0x000020, "Wrong size on FGameplayTagBlueprintPropertyMap");
static_assert(offsetof(FGameplayTagBlueprintPropertyMap, PropertyMappings) == 0x000010, "Member 'FGameplayTagBlueprintPropertyMap::PropertyMappings' has a wrong offset!");

// ScriptStruct GameplayAbilities.GameplayAbilityTargetingLocationInfo
// 0x00B0 (0x00B0 - 0x0000)
struct FGameplayAbilityTargetingLocationInfo final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	EGameplayAbilityTargetingLocationType         LocationType;                                      // 0x0010(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0xF];                                       // 0x0011(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             LiteralTransform;                                  // 0x0020(0x0060)(BlueprintVisible, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 SourceActor;                                       // 0x0080(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, ExposeOnSpawn, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMeshComponent*                         SourceComponent;                                   // 0x0088(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, ExposeOnSpawn, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameplayAbility*                       SourceAbility;                                     // 0x0090(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, ExposeOnSpawn, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SourceSocketName;                                  // 0x0098(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A4[0xC];                                       // 0x00A4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayAbilityTargetingLocationInfo) == 0x000010, "Wrong alignment on FGameplayAbilityTargetingLocationInfo");
static_assert(sizeof(FGameplayAbilityTargetingLocationInfo) == 0x0000B0, "Wrong size on FGameplayAbilityTargetingLocationInfo");
static_assert(offsetof(FGameplayAbilityTargetingLocationInfo, LocationType) == 0x000010, "Member 'FGameplayAbilityTargetingLocationInfo::LocationType' has a wrong offset!");
static_assert(offsetof(FGameplayAbilityTargetingLocationInfo, LiteralTransform) == 0x000020, "Member 'FGameplayAbilityTargetingLocationInfo::LiteralTransform' has a wrong offset!");
static_assert(offsetof(FGameplayAbilityTargetingLocationInfo, SourceActor) == 0x000080, "Member 'FGameplayAbilityTargetingLocationInfo::SourceActor' has a wrong offset!");
static_assert(offsetof(FGameplayAbilityTargetingLocationInfo, SourceComponent) == 0x000088, "Member 'FGameplayAbilityTargetingLocationInfo::SourceComponent' has a wrong offset!");
static_assert(offsetof(FGameplayAbilityTargetingLocationInfo, SourceAbility) == 0x000090, "Member 'FGameplayAbilityTargetingLocationInfo::SourceAbility' has a wrong offset!");
static_assert(offsetof(FGameplayAbilityTargetingLocationInfo, SourceSocketName) == 0x000098, "Member 'FGameplayAbilityTargetingLocationInfo::SourceSocketName' has a wrong offset!");

// ScriptStruct GameplayAbilities.GameplayEffectSpecStackHandle
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x08) FGameplayEffectSpecStackHandle final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayEffectSpecStackHandle) == 0x000008, "Wrong alignment on FGameplayEffectSpecStackHandle");
static_assert(sizeof(FGameplayEffectSpecStackHandle) == 0x000008, "Wrong size on FGameplayEffectSpecStackHandle");

// ScriptStruct GameplayAbilities.GameplayAbilityActorInfo
// 0x0058 (0x0058 - 0x0000)
struct alignas(0x08) FGameplayAbilityActorInfo
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AActor>                  OwnerActor;                                        // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AActor>                  AvatarActor;                                       // 0x0010(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class APlayerController>       PlayerController;                                  // 0x0018(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AAIController>           AiController;                                      // 0x0020(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UAbilitySystemComponent> AbilitySystemComponent;                            // 0x0028(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class USkeletalMeshComponent>  SkeletalMeshComponent;                             // 0x0030(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UAnimInstance>           AnimInstance;                                      // 0x0038(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UMovementComponent>      MovementComponent;                                 // 0x0040(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AffectedAnimInstanceTag;                           // 0x0048(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayAbilityActorInfo) == 0x000008, "Wrong alignment on FGameplayAbilityActorInfo");
static_assert(sizeof(FGameplayAbilityActorInfo) == 0x000058, "Wrong size on FGameplayAbilityActorInfo");
static_assert(offsetof(FGameplayAbilityActorInfo, OwnerActor) == 0x000008, "Member 'FGameplayAbilityActorInfo::OwnerActor' has a wrong offset!");
static_assert(offsetof(FGameplayAbilityActorInfo, AvatarActor) == 0x000010, "Member 'FGameplayAbilityActorInfo::AvatarActor' has a wrong offset!");
static_assert(offsetof(FGameplayAbilityActorInfo, PlayerController) == 0x000018, "Member 'FGameplayAbilityActorInfo::PlayerController' has a wrong offset!");
static_assert(offsetof(FGameplayAbilityActorInfo, AiController) == 0x000020, "Member 'FGameplayAbilityActorInfo::AiController' has a wrong offset!");
static_assert(offsetof(FGameplayAbilityActorInfo, AbilitySystemComponent) == 0x000028, "Member 'FGameplayAbilityActorInfo::AbilitySystemComponent' has a wrong offset!");
static_assert(offsetof(FGameplayAbilityActorInfo, SkeletalMeshComponent) == 0x000030, "Member 'FGameplayAbilityActorInfo::SkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(FGameplayAbilityActorInfo, AnimInstance) == 0x000038, "Member 'FGameplayAbilityActorInfo::AnimInstance' has a wrong offset!");
static_assert(offsetof(FGameplayAbilityActorInfo, MovementComponent) == 0x000040, "Member 'FGameplayAbilityActorInfo::MovementComponent' has a wrong offset!");
static_assert(offsetof(FGameplayAbilityActorInfo, AffectedAnimInstanceTag) == 0x000048, "Member 'FGameplayAbilityActorInfo::AffectedAnimInstanceTag' has a wrong offset!");

// ScriptStruct GameplayAbilities.GameplayAbilityTargetData
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x08) FGameplayAbilityTargetData
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayAbilityTargetData) == 0x000008, "Wrong alignment on FGameplayAbilityTargetData");
static_assert(sizeof(FGameplayAbilityTargetData) == 0x000008, "Wrong size on FGameplayAbilityTargetData");

// ScriptStruct GameplayAbilities.ObjectPoolKey
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x04) FObjectPoolKey final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FObjectPoolKey) == 0x000004, "Wrong alignment on FObjectPoolKey");
static_assert(sizeof(FObjectPoolKey) == 0x000010, "Wrong size on FObjectPoolKey");

// ScriptStruct GameplayAbilities.AbilityEndedData
// 0x0010 (0x0010 - 0x0000)
struct FAbilityEndedData final
{
public:
	class UGameplayAbility*                       AbilityThatEnded;                                  // 0x0000(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAbilitySpecHandle             AbilitySpecHandle;                                 // 0x0008(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReplicateEndAbility;                              // 0x000C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWasCancelled;                                     // 0x000D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E[0x2];                                        // 0x000E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAbilityEndedData) == 0x000008, "Wrong alignment on FAbilityEndedData");
static_assert(sizeof(FAbilityEndedData) == 0x000010, "Wrong size on FAbilityEndedData");
static_assert(offsetof(FAbilityEndedData, AbilityThatEnded) == 0x000000, "Member 'FAbilityEndedData::AbilityThatEnded' has a wrong offset!");
static_assert(offsetof(FAbilityEndedData, AbilitySpecHandle) == 0x000008, "Member 'FAbilityEndedData::AbilitySpecHandle' has a wrong offset!");
static_assert(offsetof(FAbilityEndedData, bReplicateEndAbility) == 0x00000C, "Member 'FAbilityEndedData::bReplicateEndAbility' has a wrong offset!");
static_assert(offsetof(FAbilityEndedData, bWasCancelled) == 0x00000D, "Member 'FAbilityEndedData::bWasCancelled' has a wrong offset!");

// ScriptStruct GameplayAbilities.GameplayCueNotifyActorArray
// 0x0010 (0x0010 - 0x0000)
struct FGameplayCueNotifyActorArray final
{
public:
	TArray<class AGameplayCueNotify_Actor*>       Actors;                                            // 0x0000(0x0010)(ZeroConstructor, Transient, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
};
static_assert(alignof(FGameplayCueNotifyActorArray) == 0x000008, "Wrong alignment on FGameplayCueNotifyActorArray");
static_assert(sizeof(FGameplayCueNotifyActorArray) == 0x000010, "Wrong size on FGameplayCueNotifyActorArray");
static_assert(offsetof(FGameplayCueNotifyActorArray, Actors) == 0x000000, "Member 'FGameplayCueNotifyActorArray::Actors' has a wrong offset!");

// ScriptStruct GameplayAbilities.GameplayCueClassRecycleInfo
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x04) FGameplayCueClassRecycleInfo final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayCueClassRecycleInfo) == 0x000004, "Wrong alignment on FGameplayCueClassRecycleInfo");
static_assert(sizeof(FGameplayCueClassRecycleInfo) == 0x000008, "Wrong size on FGameplayCueClassRecycleInfo");

// ScriptStruct GameplayAbilities.CueObjectKey
// 0x000C (0x000C - 0x0000)
struct alignas(0x04) FCueObjectKey final
{
public:
	uint8                                         Pad_0[0xC];                                        // 0x0000(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCueObjectKey) == 0x000004, "Wrong alignment on FCueObjectKey");
static_assert(sizeof(FCueObjectKey) == 0x00000C, "Wrong size on FCueObjectKey");

// ScriptStruct GameplayAbilities.PreallocationInfo
// 0x0110 (0x0110 - 0x0000)
struct FPreallocationInfo final
{
public:
	TMap<TSubclassOf<class UObject>, struct FGameplayCueNotifyActorArray> PreallocatedInstances;     // 0x0000(0x0050)(Transient, NativeAccessSpecifierPublic)
	TMap<int32, struct FGameplayCueNotifyActorClassArray> HeroSkinPreallocatedActorClasses;          // 0x0050(0x0050)(Transient, NativeAccessSpecifierPublic)
	TMap<int32, struct FGameplayCueClassRecycleInfo> GameplayCueClassRecycleInfos;                   // 0x00A0(0x0050)(Transient, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class AGameplayCueNotify_Actor>> ClassesNeedingPreallocation;                 // 0x00F0(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_100[0x10];                                     // 0x0100(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPreallocationInfo) == 0x000008, "Wrong alignment on FPreallocationInfo");
static_assert(sizeof(FPreallocationInfo) == 0x000110, "Wrong size on FPreallocationInfo");
static_assert(offsetof(FPreallocationInfo, PreallocatedInstances) == 0x000000, "Member 'FPreallocationInfo::PreallocatedInstances' has a wrong offset!");
static_assert(offsetof(FPreallocationInfo, HeroSkinPreallocatedActorClasses) == 0x000050, "Member 'FPreallocationInfo::HeroSkinPreallocatedActorClasses' has a wrong offset!");
static_assert(offsetof(FPreallocationInfo, GameplayCueClassRecycleInfos) == 0x0000A0, "Member 'FPreallocationInfo::GameplayCueClassRecycleInfos' has a wrong offset!");
static_assert(offsetof(FPreallocationInfo, ClassesNeedingPreallocation) == 0x0000F0, "Member 'FPreallocationInfo::ClassesNeedingPreallocation' has a wrong offset!");

// ScriptStruct GameplayAbilities.MinimalGameplayCueReplicationProxyForNetSerializer
// 0x0020 (0x0020 - 0x0000)
struct FMinimalGameplayCueReplicationProxyForNetSerializer final
{
public:
	TArray<struct FGameplayTag>                   Tags;                                              // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FVector_NetQuantize>            Locations;                                         // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FMinimalGameplayCueReplicationProxyForNetSerializer) == 0x000008, "Wrong alignment on FMinimalGameplayCueReplicationProxyForNetSerializer");
static_assert(sizeof(FMinimalGameplayCueReplicationProxyForNetSerializer) == 0x000020, "Wrong size on FMinimalGameplayCueReplicationProxyForNetSerializer");
static_assert(offsetof(FMinimalGameplayCueReplicationProxyForNetSerializer, Tags) == 0x000000, "Member 'FMinimalGameplayCueReplicationProxyForNetSerializer::Tags' has a wrong offset!");
static_assert(offsetof(FMinimalGameplayCueReplicationProxyForNetSerializer, Locations) == 0x000010, "Member 'FMinimalGameplayCueReplicationProxyForNetSerializer::Locations' has a wrong offset!");

// ScriptStruct GameplayAbilities.MinimalReplicationTagCountMapForNetSerializer
// 0x0010 (0x0010 - 0x0000)
struct FMinimalReplicationTagCountMapForNetSerializer final
{
public:
	TArray<struct FGameplayTag>                   Tags;                                              // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FMinimalReplicationTagCountMapForNetSerializer) == 0x000008, "Wrong alignment on FMinimalReplicationTagCountMapForNetSerializer");
static_assert(sizeof(FMinimalReplicationTagCountMapForNetSerializer) == 0x000010, "Wrong size on FMinimalReplicationTagCountMapForNetSerializer");
static_assert(offsetof(FMinimalReplicationTagCountMapForNetSerializer, Tags) == 0x000000, "Member 'FMinimalReplicationTagCountMapForNetSerializer::Tags' has a wrong offset!");

// ScriptStruct GameplayAbilities.AbilityReconnectParams
// 0x00D0 (0x00D0 - 0x0000)
struct alignas(0x08) FAbilityReconnectParams final
{
public:
	uint8                                         Pad_0[0xD0];                                       // 0x0000(0x00D0)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAbilityReconnectParams) == 0x000008, "Wrong alignment on FAbilityReconnectParams");
static_assert(sizeof(FAbilityReconnectParams) == 0x0000D0, "Wrong size on FAbilityReconnectParams");

// ScriptStruct GameplayAbilities.GameplayAbilityBindInfo
// 0x0010 (0x0010 - 0x0000)
struct FGameplayAbilityBindInfo final
{
public:
	EGameplayAbilityInputBinds                    Command;                                           // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGameplayAbility>           GameplayAbilityClass;                              // 0x0008(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameplayAbilityBindInfo) == 0x000008, "Wrong alignment on FGameplayAbilityBindInfo");
static_assert(sizeof(FGameplayAbilityBindInfo) == 0x000010, "Wrong size on FGameplayAbilityBindInfo");
static_assert(offsetof(FGameplayAbilityBindInfo, Command) == 0x000000, "Member 'FGameplayAbilityBindInfo::Command' has a wrong offset!");
static_assert(offsetof(FGameplayAbilityBindInfo, GameplayAbilityClass) == 0x000008, "Member 'FGameplayAbilityBindInfo::GameplayAbilityClass' has a wrong offset!");

// ScriptStruct GameplayAbilities.GameplayTargetDataFilter
// 0x0020 (0x0020 - 0x0000)
struct FGameplayTargetDataFilter final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 SelfActor;                                         // 0x0008(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     RequiredActorClass;                                // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, ExposeOnSpawn, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETargetDataFilterSelf                         SelfFilter;                                        // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReverseFilter;                                    // 0x0019(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x6];                                       // 0x001A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayTargetDataFilter) == 0x000008, "Wrong alignment on FGameplayTargetDataFilter");
static_assert(sizeof(FGameplayTargetDataFilter) == 0x000020, "Wrong size on FGameplayTargetDataFilter");
static_assert(offsetof(FGameplayTargetDataFilter, SelfActor) == 0x000008, "Member 'FGameplayTargetDataFilter::SelfActor' has a wrong offset!");
static_assert(offsetof(FGameplayTargetDataFilter, RequiredActorClass) == 0x000010, "Member 'FGameplayTargetDataFilter::RequiredActorClass' has a wrong offset!");
static_assert(offsetof(FGameplayTargetDataFilter, SelfFilter) == 0x000018, "Member 'FGameplayTargetDataFilter::SelfFilter' has a wrong offset!");
static_assert(offsetof(FGameplayTargetDataFilter, bReverseFilter) == 0x000019, "Member 'FGameplayTargetDataFilter::bReverseFilter' has a wrong offset!");

// ScriptStruct GameplayAbilities.WorldReticleParameters
// 0x0018 (0x0018 - 0x0000)
struct FWorldReticleParameters final
{
public:
	struct FVector                                AOEScale;                                          // 0x0000(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWorldReticleParameters) == 0x000008, "Wrong alignment on FWorldReticleParameters");
static_assert(sizeof(FWorldReticleParameters) == 0x000018, "Wrong size on FWorldReticleParameters");
static_assert(offsetof(FWorldReticleParameters, AOEScale) == 0x000000, "Member 'FWorldReticleParameters::AOEScale' has a wrong offset!");

// ScriptStruct GameplayAbilities.GameplayAttributeData
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FGameplayAttributeData final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BaseValue;                                         // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CurrentValue;                                      // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
};
static_assert(alignof(FGameplayAttributeData) == 0x000008, "Wrong alignment on FGameplayAttributeData");
static_assert(sizeof(FGameplayAttributeData) == 0x000010, "Wrong size on FGameplayAttributeData");
static_assert(offsetof(FGameplayAttributeData, BaseValue) == 0x000008, "Member 'FGameplayAttributeData::BaseValue' has a wrong offset!");
static_assert(offsetof(FGameplayAttributeData, CurrentValue) == 0x00000C, "Member 'FGameplayAttributeData::CurrentValue' has a wrong offset!");

// ScriptStruct GameplayAbilities.AttributeMetaData
// 0x0028 (0x0038 - 0x0010)
struct FAttributeMetaData final : public FTableRowBase
{
public:
	float                                         BaseValue;                                         // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinValue;                                          // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxValue;                                          // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DerivedAttributeInfo;                              // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanStack;                                         // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAttributeMetaData) == 0x000008, "Wrong alignment on FAttributeMetaData");
static_assert(sizeof(FAttributeMetaData) == 0x000038, "Wrong size on FAttributeMetaData");
static_assert(offsetof(FAttributeMetaData, BaseValue) == 0x000010, "Member 'FAttributeMetaData::BaseValue' has a wrong offset!");
static_assert(offsetof(FAttributeMetaData, MinValue) == 0x000014, "Member 'FAttributeMetaData::MinValue' has a wrong offset!");
static_assert(offsetof(FAttributeMetaData, MaxValue) == 0x000018, "Member 'FAttributeMetaData::MaxValue' has a wrong offset!");
static_assert(offsetof(FAttributeMetaData, DerivedAttributeInfo) == 0x000020, "Member 'FAttributeMetaData::DerivedAttributeInfo' has a wrong offset!");
static_assert(offsetof(FAttributeMetaData, bCanStack) == 0x000030, "Member 'FAttributeMetaData::bCanStack' has a wrong offset!");

// ScriptStruct GameplayAbilities.GameplayAbilityTargetData_LocationInfo
// 0x0168 (0x0170 - 0x0008)
struct FGameplayAbilityTargetData_LocationInfo final : public FGameplayAbilityTargetData
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayAbilityTargetingLocationInfo  SourceLocation;                                    // 0x0010(0x00B0)(Edit, BlueprintVisible, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FGameplayAbilityTargetingLocationInfo  TargetLocation;                                    // 0x00C0(0x00B0)(Edit, BlueprintVisible, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameplayAbilityTargetData_LocationInfo) == 0x000010, "Wrong alignment on FGameplayAbilityTargetData_LocationInfo");
static_assert(sizeof(FGameplayAbilityTargetData_LocationInfo) == 0x000170, "Wrong size on FGameplayAbilityTargetData_LocationInfo");
static_assert(offsetof(FGameplayAbilityTargetData_LocationInfo, SourceLocation) == 0x000010, "Member 'FGameplayAbilityTargetData_LocationInfo::SourceLocation' has a wrong offset!");
static_assert(offsetof(FGameplayAbilityTargetData_LocationInfo, TargetLocation) == 0x0000C0, "Member 'FGameplayAbilityTargetData_LocationInfo::TargetLocation' has a wrong offset!");

// ScriptStruct GameplayAbilities.GameplayAbilityTargetData_Float
// 0x0008 (0x0010 - 0x0008)
struct FGameplayAbilityTargetData_Float final : public FGameplayAbilityTargetData
{
public:
	float                                         Value;                                             // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayAbilityTargetData_Float) == 0x000008, "Wrong alignment on FGameplayAbilityTargetData_Float");
static_assert(sizeof(FGameplayAbilityTargetData_Float) == 0x000010, "Wrong size on FGameplayAbilityTargetData_Float");
static_assert(offsetof(FGameplayAbilityTargetData_Float, Value) == 0x000008, "Member 'FGameplayAbilityTargetData_Float::Value' has a wrong offset!");

// ScriptStruct GameplayAbilities.GameplayAbilityTargetData_Vector
// 0x0018 (0x0020 - 0x0008)
struct FGameplayAbilityTargetData_Vector final : public FGameplayAbilityTargetData
{
public:
	struct FVector                                Value;                                             // 0x0008(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameplayAbilityTargetData_Vector) == 0x000008, "Wrong alignment on FGameplayAbilityTargetData_Vector");
static_assert(sizeof(FGameplayAbilityTargetData_Vector) == 0x000020, "Wrong size on FGameplayAbilityTargetData_Vector");
static_assert(offsetof(FGameplayAbilityTargetData_Vector, Value) == 0x000008, "Member 'FGameplayAbilityTargetData_Vector::Value' has a wrong offset!");

// ScriptStruct GameplayAbilities.GameplayAbilityTargetData_Transform
// 0x0068 (0x0070 - 0x0008)
struct FGameplayAbilityTargetData_Transform final : public FGameplayAbilityTargetData
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Value;                                             // 0x0010(0x0060)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameplayAbilityTargetData_Transform) == 0x000010, "Wrong alignment on FGameplayAbilityTargetData_Transform");
static_assert(sizeof(FGameplayAbilityTargetData_Transform) == 0x000070, "Wrong size on FGameplayAbilityTargetData_Transform");
static_assert(offsetof(FGameplayAbilityTargetData_Transform, Value) == 0x000010, "Member 'FGameplayAbilityTargetData_Transform::Value' has a wrong offset!");

// ScriptStruct GameplayAbilities.GameplayAbilityTargetData_ActorArray
// 0x00C8 (0x00D0 - 0x0008)
struct FGameplayAbilityTargetData_ActorArray : public FGameplayAbilityTargetData
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayAbilityTargetingLocationInfo  SourceLocation;                                    // 0x0010(0x00B0)(Edit, BlueprintVisible, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<TWeakObjectPtr<class AActor>>          TargetActorArray;                                  // 0x00C0(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameplayAbilityTargetData_ActorArray) == 0x000010, "Wrong alignment on FGameplayAbilityTargetData_ActorArray");
static_assert(sizeof(FGameplayAbilityTargetData_ActorArray) == 0x0000D0, "Wrong size on FGameplayAbilityTargetData_ActorArray");
static_assert(offsetof(FGameplayAbilityTargetData_ActorArray, SourceLocation) == 0x000010, "Member 'FGameplayAbilityTargetData_ActorArray::SourceLocation' has a wrong offset!");
static_assert(offsetof(FGameplayAbilityTargetData_ActorArray, TargetActorArray) == 0x0000C0, "Member 'FGameplayAbilityTargetData_ActorArray::TargetActorArray' has a wrong offset!");

// ScriptStruct GameplayAbilities.GameplayAbilityTargetData_SingleTargetHit
// 0x01F8 (0x0200 - 0x0008)
struct FGameplayAbilityTargetData_SingleTargetHit : public FGameplayAbilityTargetData
{
public:
	struct FHitResult                             HitResult;                                         // 0x0008(0x01F0)(ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bHitReplaced;                                      // 0x01F8(0x0001)(ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F9[0x7];                                      // 0x01F9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayAbilityTargetData_SingleTargetHit) == 0x000008, "Wrong alignment on FGameplayAbilityTargetData_SingleTargetHit");
static_assert(sizeof(FGameplayAbilityTargetData_SingleTargetHit) == 0x000200, "Wrong size on FGameplayAbilityTargetData_SingleTargetHit");
static_assert(offsetof(FGameplayAbilityTargetData_SingleTargetHit, HitResult) == 0x000008, "Member 'FGameplayAbilityTargetData_SingleTargetHit::HitResult' has a wrong offset!");
static_assert(offsetof(FGameplayAbilityTargetData_SingleTargetHit, bHitReplaced) == 0x0001F8, "Member 'FGameplayAbilityTargetData_SingleTargetHit::bHitReplaced' has a wrong offset!");

// ScriptStruct GameplayAbilities.GameplayAbilityTargetData_MultiTargetHit
// 0x0010 (0x0018 - 0x0008)
struct FGameplayAbilityTargetData_MultiTargetHit final : public FGameplayAbilityTargetData
{
public:
	TArray<struct FHitResult>                     HitResults;                                        // 0x0008(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameplayAbilityTargetData_MultiTargetHit) == 0x000008, "Wrong alignment on FGameplayAbilityTargetData_MultiTargetHit");
static_assert(sizeof(FGameplayAbilityTargetData_MultiTargetHit) == 0x000018, "Wrong size on FGameplayAbilityTargetData_MultiTargetHit");
static_assert(offsetof(FGameplayAbilityTargetData_MultiTargetHit, HitResults) == 0x000008, "Member 'FGameplayAbilityTargetData_MultiTargetHit::HitResults' has a wrong offset!");

// ScriptStruct GameplayAbilities.AbilityTaskDebugMessage
// 0x0018 (0x0018 - 0x0000)
struct FAbilityTaskDebugMessage final
{
public:
	class UGameplayTask*                          FromTask;                                          // 0x0000(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Message;                                           // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAbilityTaskDebugMessage) == 0x000008, "Wrong alignment on FAbilityTaskDebugMessage");
static_assert(sizeof(FAbilityTaskDebugMessage) == 0x000018, "Wrong size on FAbilityTaskDebugMessage");
static_assert(offsetof(FAbilityTaskDebugMessage, FromTask) == 0x000000, "Member 'FAbilityTaskDebugMessage::FromTask' has a wrong offset!");
static_assert(offsetof(FAbilityTaskDebugMessage, Message) == 0x000008, "Member 'FAbilityTaskDebugMessage::Message' has a wrong offset!");

// ScriptStruct GameplayAbilities.ServerAbilityRPCBatch
// 0x01E8 (0x01E8 - 0x0000)
struct FServerAbilityRPCBatch final
{
public:
	struct FGameplayAbilitySpecHandle             AbilitySpecHandle;                                 // 0x0000(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPredictionKey                         PredictionKey;                                     // 0x0008(0x0070)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAbilityTargetDataHandle       TargetData;                                        // 0x0078(0x0168)(NativeAccessSpecifierPublic)
	bool                                          InputPressed;                                      // 0x01E0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Ended;                                             // 0x01E1(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Started;                                           // 0x01E2(0x0001)(ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E3[0x5];                                      // 0x01E3(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FServerAbilityRPCBatch) == 0x000008, "Wrong alignment on FServerAbilityRPCBatch");
static_assert(sizeof(FServerAbilityRPCBatch) == 0x0001E8, "Wrong size on FServerAbilityRPCBatch");
static_assert(offsetof(FServerAbilityRPCBatch, AbilitySpecHandle) == 0x000000, "Member 'FServerAbilityRPCBatch::AbilitySpecHandle' has a wrong offset!");
static_assert(offsetof(FServerAbilityRPCBatch, PredictionKey) == 0x000008, "Member 'FServerAbilityRPCBatch::PredictionKey' has a wrong offset!");
static_assert(offsetof(FServerAbilityRPCBatch, TargetData) == 0x000078, "Member 'FServerAbilityRPCBatch::TargetData' has a wrong offset!");
static_assert(offsetof(FServerAbilityRPCBatch, InputPressed) == 0x0001E0, "Member 'FServerAbilityRPCBatch::InputPressed' has a wrong offset!");
static_assert(offsetof(FServerAbilityRPCBatch, Ended) == 0x0001E1, "Member 'FServerAbilityRPCBatch::Ended' has a wrong offset!");
static_assert(offsetof(FServerAbilityRPCBatch, Started) == 0x0001E2, "Member 'FServerAbilityRPCBatch::Started' has a wrong offset!");

// ScriptStruct GameplayAbilities.MinimalGameplayCueReplicationProxy
// 0x03D0 (0x03D0 - 0x0000)
struct alignas(0x10) FMinimalGameplayCueReplicationProxy final
{
public:
	uint8                                         Pad_0[0x3C0];                                      // 0x0000(0x03C0)(Fixing Size After Last Property [ Dumper-7 ])
	class UAbilitySystemComponent*                Owner;                                             // 0x03C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3C8[0x8];                                      // 0x03C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMinimalGameplayCueReplicationProxy) == 0x000010, "Wrong alignment on FMinimalGameplayCueReplicationProxy");
static_assert(sizeof(FMinimalGameplayCueReplicationProxy) == 0x0003D0, "Wrong size on FMinimalGameplayCueReplicationProxy");
static_assert(offsetof(FMinimalGameplayCueReplicationProxy, Owner) == 0x0003C0, "Member 'FMinimalGameplayCueReplicationProxy::Owner' has a wrong offset!");

// ScriptStruct GameplayAbilities.GameplayCueObjectLibrary
// 0x0050 (0x0050 - 0x0000)
struct FGameplayCueObjectLibrary final
{
public:
	TArray<class FString>                         Paths;                                             // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x20];                                      // 0x0010(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UObjectLibrary*                         ActorObjectLibrary;                                // 0x0030(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObjectLibrary*                         StaticObjectLibrary;                               // 0x0038(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameplayCueSet*                        CueSet;                                            // 0x0040(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x4];                                       // 0x0048(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bShouldSyncScan;                                   // 0x004C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldAsyncLoad;                                  // 0x004D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldSyncLoad;                                   // 0x004E(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasBeenInitialized;                               // 0x004F(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameplayCueObjectLibrary) == 0x000008, "Wrong alignment on FGameplayCueObjectLibrary");
static_assert(sizeof(FGameplayCueObjectLibrary) == 0x000050, "Wrong size on FGameplayCueObjectLibrary");
static_assert(offsetof(FGameplayCueObjectLibrary, Paths) == 0x000000, "Member 'FGameplayCueObjectLibrary::Paths' has a wrong offset!");
static_assert(offsetof(FGameplayCueObjectLibrary, ActorObjectLibrary) == 0x000030, "Member 'FGameplayCueObjectLibrary::ActorObjectLibrary' has a wrong offset!");
static_assert(offsetof(FGameplayCueObjectLibrary, StaticObjectLibrary) == 0x000038, "Member 'FGameplayCueObjectLibrary::StaticObjectLibrary' has a wrong offset!");
static_assert(offsetof(FGameplayCueObjectLibrary, CueSet) == 0x000040, "Member 'FGameplayCueObjectLibrary::CueSet' has a wrong offset!");
static_assert(offsetof(FGameplayCueObjectLibrary, bShouldSyncScan) == 0x00004C, "Member 'FGameplayCueObjectLibrary::bShouldSyncScan' has a wrong offset!");
static_assert(offsetof(FGameplayCueObjectLibrary, bShouldAsyncLoad) == 0x00004D, "Member 'FGameplayCueObjectLibrary::bShouldAsyncLoad' has a wrong offset!");
static_assert(offsetof(FGameplayCueObjectLibrary, bShouldSyncLoad) == 0x00004E, "Member 'FGameplayCueObjectLibrary::bShouldSyncLoad' has a wrong offset!");
static_assert(offsetof(FGameplayCueObjectLibrary, bHasBeenInitialized) == 0x00004F, "Member 'FGameplayCueObjectLibrary::bHasBeenInitialized' has a wrong offset!");

// ScriptStruct GameplayAbilities.GameplayCueNotify_SpawnResult
// 0x0058 (0x0058 - 0x0000)
struct FGameplayCueNotify_SpawnResult final
{
public:
	TArray<class UFXSystemComponent*>             FxSystemComponents;                                // 0x0000(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class UAudioComponent*>                AudioComponents;                                   // 0x0010(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class UCameraShakeBase*>               CameraShakes;                                      // 0x0020(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TScriptInterface<class ICameraLensEffectInterface>> CameraLensEffects;                    // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPublic)
	class UForceFeedbackComponent*                ForceFeedbackComponent;                            // 0x0040(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APlayerController*                      ForceFeedbackTargetPC;                             // 0x0048(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDecalComponent*                        DecalComponent;                                    // 0x0050(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameplayCueNotify_SpawnResult) == 0x000008, "Wrong alignment on FGameplayCueNotify_SpawnResult");
static_assert(sizeof(FGameplayCueNotify_SpawnResult) == 0x000058, "Wrong size on FGameplayCueNotify_SpawnResult");
static_assert(offsetof(FGameplayCueNotify_SpawnResult, FxSystemComponents) == 0x000000, "Member 'FGameplayCueNotify_SpawnResult::FxSystemComponents' has a wrong offset!");
static_assert(offsetof(FGameplayCueNotify_SpawnResult, AudioComponents) == 0x000010, "Member 'FGameplayCueNotify_SpawnResult::AudioComponents' has a wrong offset!");
static_assert(offsetof(FGameplayCueNotify_SpawnResult, CameraShakes) == 0x000020, "Member 'FGameplayCueNotify_SpawnResult::CameraShakes' has a wrong offset!");
static_assert(offsetof(FGameplayCueNotify_SpawnResult, CameraLensEffects) == 0x000030, "Member 'FGameplayCueNotify_SpawnResult::CameraLensEffects' has a wrong offset!");
static_assert(offsetof(FGameplayCueNotify_SpawnResult, ForceFeedbackComponent) == 0x000040, "Member 'FGameplayCueNotify_SpawnResult::ForceFeedbackComponent' has a wrong offset!");
static_assert(offsetof(FGameplayCueNotify_SpawnResult, ForceFeedbackTargetPC) == 0x000048, "Member 'FGameplayCueNotify_SpawnResult::ForceFeedbackTargetPC' has a wrong offset!");
static_assert(offsetof(FGameplayCueNotify_SpawnResult, DecalComponent) == 0x000050, "Member 'FGameplayCueNotify_SpawnResult::DecalComponent' has a wrong offset!");

// ScriptStruct GameplayAbilities.GameplayCueNotify_DecalInfo
// 0x00B0 (0x00B0 - 0x0000)
struct FGameplayCueNotify_DecalInfo final
{
public:
	struct FGameplayCueNotify_SpawnCondition      SpawnConditionOverride;                            // 0x0000(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayCueNotify_PlacementInfo       PlacementInfoOverride;                             // 0x0038(0x0048)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     DecalMaterial;                                     // 0x0080(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DecalSize;                                         // 0x0088(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverrideSpawnCondition : 1;                       // 0x00A0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverridePlacementInfo : 1;                        // 0x00A0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverrideFadeOut : 1;                              // 0x00A0(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_A1[0x3];                                       // 0x00A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FadeOutStartDelay;                                 // 0x00A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeOutDuration;                                   // 0x00A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayCueNotify_DecalInfo) == 0x000008, "Wrong alignment on FGameplayCueNotify_DecalInfo");
static_assert(sizeof(FGameplayCueNotify_DecalInfo) == 0x0000B0, "Wrong size on FGameplayCueNotify_DecalInfo");
static_assert(offsetof(FGameplayCueNotify_DecalInfo, SpawnConditionOverride) == 0x000000, "Member 'FGameplayCueNotify_DecalInfo::SpawnConditionOverride' has a wrong offset!");
static_assert(offsetof(FGameplayCueNotify_DecalInfo, PlacementInfoOverride) == 0x000038, "Member 'FGameplayCueNotify_DecalInfo::PlacementInfoOverride' has a wrong offset!");
static_assert(offsetof(FGameplayCueNotify_DecalInfo, DecalMaterial) == 0x000080, "Member 'FGameplayCueNotify_DecalInfo::DecalMaterial' has a wrong offset!");
static_assert(offsetof(FGameplayCueNotify_DecalInfo, DecalSize) == 0x000088, "Member 'FGameplayCueNotify_DecalInfo::DecalSize' has a wrong offset!");
static_assert(offsetof(FGameplayCueNotify_DecalInfo, FadeOutStartDelay) == 0x0000A4, "Member 'FGameplayCueNotify_DecalInfo::FadeOutStartDelay' has a wrong offset!");
static_assert(offsetof(FGameplayCueNotify_DecalInfo, FadeOutDuration) == 0x0000A8, "Member 'FGameplayCueNotify_DecalInfo::FadeOutDuration' has a wrong offset!");

// ScriptStruct GameplayAbilities.GameplayCueNotify_BurstEffects
// 0x02C0 (0x02C0 - 0x0000)
struct FGameplayCueNotify_BurstEffects final
{
public:
	TArray<struct FGameplayCueNotify_ParticleInfo> BurstParticles;                                   // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FGameplayCueNotify_SoundInfo>   BurstSounds;                                       // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayCueNotify_CameraShakeInfo     BurstCameraShake;                                  // 0x0020(0x00A0)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayCueNotify_CameraLensEffectInfo BurstCameraLensEffect;                            // 0x00C0(0x0098)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayCueNotify_ForceFeedbackInfo   BurstForceFeedback;                                // 0x0158(0x00A8)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayCueNotify_InputDevicePropertyInfo BurstDevicePropertyEffect;                     // 0x0200(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FGameplayCueNotify_DecalInfo           BurstDecal;                                        // 0x0210(0x00B0)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FGameplayCueNotify_BurstEffects) == 0x000008, "Wrong alignment on FGameplayCueNotify_BurstEffects");
static_assert(sizeof(FGameplayCueNotify_BurstEffects) == 0x0002C0, "Wrong size on FGameplayCueNotify_BurstEffects");
static_assert(offsetof(FGameplayCueNotify_BurstEffects, BurstParticles) == 0x000000, "Member 'FGameplayCueNotify_BurstEffects::BurstParticles' has a wrong offset!");
static_assert(offsetof(FGameplayCueNotify_BurstEffects, BurstSounds) == 0x000010, "Member 'FGameplayCueNotify_BurstEffects::BurstSounds' has a wrong offset!");
static_assert(offsetof(FGameplayCueNotify_BurstEffects, BurstCameraShake) == 0x000020, "Member 'FGameplayCueNotify_BurstEffects::BurstCameraShake' has a wrong offset!");
static_assert(offsetof(FGameplayCueNotify_BurstEffects, BurstCameraLensEffect) == 0x0000C0, "Member 'FGameplayCueNotify_BurstEffects::BurstCameraLensEffect' has a wrong offset!");
static_assert(offsetof(FGameplayCueNotify_BurstEffects, BurstForceFeedback) == 0x000158, "Member 'FGameplayCueNotify_BurstEffects::BurstForceFeedback' has a wrong offset!");
static_assert(offsetof(FGameplayCueNotify_BurstEffects, BurstDevicePropertyEffect) == 0x000200, "Member 'FGameplayCueNotify_BurstEffects::BurstDevicePropertyEffect' has a wrong offset!");
static_assert(offsetof(FGameplayCueNotify_BurstEffects, BurstDecal) == 0x000210, "Member 'FGameplayCueNotify_BurstEffects::BurstDecal' has a wrong offset!");

// ScriptStruct GameplayAbilities.GameplayCueNotifyData
// 0x0050 (0x0050 - 0x0000)
struct FGameplayCueNotifyData final
{
public:
	struct FGameplayTag                           GameplayCueTag;                                    // 0x0000(0x000C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        GameplayCueNotifyObj;                              // 0x0010(0x0028)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UObject>                    LoadedGameplayCueClass;                            // 0x0038(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x10];                                      // 0x0040(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayCueNotifyData) == 0x000008, "Wrong alignment on FGameplayCueNotifyData");
static_assert(sizeof(FGameplayCueNotifyData) == 0x000050, "Wrong size on FGameplayCueNotifyData");
static_assert(offsetof(FGameplayCueNotifyData, GameplayCueTag) == 0x000000, "Member 'FGameplayCueNotifyData::GameplayCueTag' has a wrong offset!");
static_assert(offsetof(FGameplayCueNotifyData, GameplayCueNotifyObj) == 0x000010, "Member 'FGameplayCueNotifyData::GameplayCueNotifyObj' has a wrong offset!");
static_assert(offsetof(FGameplayCueNotifyData, LoadedGameplayCueClass) == 0x000038, "Member 'FGameplayCueNotifyData::LoadedGameplayCueClass' has a wrong offset!");

// ScriptStruct GameplayAbilities.GameplayCueTranslationManager
// 0x0080 (0x0080 - 0x0000)
struct FGameplayCueTranslationManager final
{
public:
	TArray<struct FGameplayCueTranslatorNode>     TranslationLUT;                                    // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TMap<class FName, struct FGameplayCueTranslatorNodeIndex> TranslationNameToIndexMap;             // 0x0010(0x0050)(NativeAccessSpecifierPrivate)
	class UGameplayTagsManager*                   TagManager;                                        // 0x0060(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_68[0x18];                                      // 0x0068(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayCueTranslationManager) == 0x000008, "Wrong alignment on FGameplayCueTranslationManager");
static_assert(sizeof(FGameplayCueTranslationManager) == 0x000080, "Wrong size on FGameplayCueTranslationManager");
static_assert(offsetof(FGameplayCueTranslationManager, TranslationLUT) == 0x000000, "Member 'FGameplayCueTranslationManager::TranslationLUT' has a wrong offset!");
static_assert(offsetof(FGameplayCueTranslationManager, TranslationNameToIndexMap) == 0x000010, "Member 'FGameplayCueTranslationManager::TranslationNameToIndexMap' has a wrong offset!");
static_assert(offsetof(FGameplayCueTranslationManager, TagManager) == 0x000060, "Member 'FGameplayCueTranslationManager::TagManager' has a wrong offset!");

// ScriptStruct GameplayAbilities.ConditionalGameplayEffect
// 0x0070 (0x0070 - 0x0000)
struct FConditionalGameplayEffect final
{
public:
	TSubclassOf<class UGameplayEffect>            EffectClass;                                       // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  RequiredSourceTags;                                // 0x0008(0x0068)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FConditionalGameplayEffect) == 0x000008, "Wrong alignment on FConditionalGameplayEffect");
static_assert(sizeof(FConditionalGameplayEffect) == 0x000070, "Wrong size on FConditionalGameplayEffect");
static_assert(offsetof(FConditionalGameplayEffect, EffectClass) == 0x000000, "Member 'FConditionalGameplayEffect::EffectClass' has a wrong offset!");
static_assert(offsetof(FConditionalGameplayEffect, RequiredSourceTags) == 0x000008, "Member 'FConditionalGameplayEffect::RequiredSourceTags' has a wrong offset!");

// ScriptStruct GameplayAbilities.GameplayEffectExecutionDefinition
// 0x0090 (0x0090 - 0x0000)
struct FGameplayEffectExecutionDefinition final
{
public:
	TSubclassOf<class UGameplayEffectExecutionCalculation> CalculationClass;                         // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  PassedInTags;                                      // 0x0008(0x0068)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FGameplayEffectExecutionScopedModifierInfo> CalculationModifiers;                  // 0x0070(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FConditionalGameplayEffect>     ConditionalGameplayEffects;                        // 0x0080(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameplayEffectExecutionDefinition) == 0x000008, "Wrong alignment on FGameplayEffectExecutionDefinition");
static_assert(sizeof(FGameplayEffectExecutionDefinition) == 0x000090, "Wrong size on FGameplayEffectExecutionDefinition");
static_assert(offsetof(FGameplayEffectExecutionDefinition, CalculationClass) == 0x000000, "Member 'FGameplayEffectExecutionDefinition::CalculationClass' has a wrong offset!");
static_assert(offsetof(FGameplayEffectExecutionDefinition, PassedInTags) == 0x000008, "Member 'FGameplayEffectExecutionDefinition::PassedInTags' has a wrong offset!");
static_assert(offsetof(FGameplayEffectExecutionDefinition, CalculationModifiers) == 0x000070, "Member 'FGameplayEffectExecutionDefinition::CalculationModifiers' has a wrong offset!");
static_assert(offsetof(FGameplayEffectExecutionDefinition, ConditionalGameplayEffects) == 0x000080, "Member 'FGameplayEffectExecutionDefinition::ConditionalGameplayEffects' has a wrong offset!");

// ScriptStruct GameplayAbilities.GameplayModifierInfo
// 0x0580 (0x0580 - 0x0000)
struct FGameplayModifierInfo final
{
public:
	struct FGameplayAttribute                     Attribute;                                         // 0x0000(0x0040)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGameplayModOp                                ModifierOp;                                        // 0x0040(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayEffectModifierMagnitude       ModifierMagnitude;                                 // 0x0048(0x0300)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayModEvaluationChannelSettings  EvaluationChannelSettings;                         // 0x0348(0x0001)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_349[0x7];                                      // 0x0349(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagRequirements               SourceTags;                                        // 0x0350(0x0118)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTagRequirements               TargetTags;                                        // 0x0468(0x0118)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameplayModifierInfo) == 0x000008, "Wrong alignment on FGameplayModifierInfo");
static_assert(sizeof(FGameplayModifierInfo) == 0x000580, "Wrong size on FGameplayModifierInfo");
static_assert(offsetof(FGameplayModifierInfo, Attribute) == 0x000000, "Member 'FGameplayModifierInfo::Attribute' has a wrong offset!");
static_assert(offsetof(FGameplayModifierInfo, ModifierOp) == 0x000040, "Member 'FGameplayModifierInfo::ModifierOp' has a wrong offset!");
static_assert(offsetof(FGameplayModifierInfo, ModifierMagnitude) == 0x000048, "Member 'FGameplayModifierInfo::ModifierMagnitude' has a wrong offset!");
static_assert(offsetof(FGameplayModifierInfo, EvaluationChannelSettings) == 0x000348, "Member 'FGameplayModifierInfo::EvaluationChannelSettings' has a wrong offset!");
static_assert(offsetof(FGameplayModifierInfo, SourceTags) == 0x000350, "Member 'FGameplayModifierInfo::SourceTags' has a wrong offset!");
static_assert(offsetof(FGameplayModifierInfo, TargetTags) == 0x000468, "Member 'FGameplayModifierInfo::TargetTags' has a wrong offset!");

// ScriptStruct GameplayAbilities.InheritedTagContainer
// 0x0138 (0x0138 - 0x0000)
struct FInheritedTagContainer final
{
public:
	struct FGameplayTagContainer                  CombinedTags;                                      // 0x0000(0x0068)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  Added;                                             // 0x0068(0x0068)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  Removed;                                           // 0x00D0(0x0068)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInheritedTagContainer) == 0x000008, "Wrong alignment on FInheritedTagContainer");
static_assert(sizeof(FInheritedTagContainer) == 0x000138, "Wrong size on FInheritedTagContainer");
static_assert(offsetof(FInheritedTagContainer, CombinedTags) == 0x000000, "Member 'FInheritedTagContainer::CombinedTags' has a wrong offset!");
static_assert(offsetof(FInheritedTagContainer, Added) == 0x000068, "Member 'FInheritedTagContainer::Added' has a wrong offset!");
static_assert(offsetof(FInheritedTagContainer, Removed) == 0x0000D0, "Member 'FInheritedTagContainer::Removed' has a wrong offset!");

// ScriptStruct GameplayAbilities.ActiveGameplayEffectQuery
// 0x0090 (0x0090 - 0x0000)
struct alignas(0x08) FActiveGameplayEffectQuery final
{
public:
	uint8                                         Pad_0[0x90];                                       // 0x0000(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FActiveGameplayEffectQuery) == 0x000008, "Wrong alignment on FActiveGameplayEffectQuery");
static_assert(sizeof(FActiveGameplayEffectQuery) == 0x000090, "Wrong size on FActiveGameplayEffectQuery");

// ScriptStruct GameplayAbilities.GameplayEffectVersion
// 0x0001 (0x0001 - 0x0000)
struct FGameplayEffectVersion final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayEffectVersion) == 0x000001, "Wrong alignment on FGameplayEffectVersion");
static_assert(sizeof(FGameplayEffectVersion) == 0x000001, "Wrong size on FGameplayEffectVersion");

// ScriptStruct GameplayAbilities.GameplayEffectCustomExecutionParameters
// 0x0198 (0x0198 - 0x0000)
struct alignas(0x08) FGameplayEffectCustomExecutionParameters final
{
public:
	uint8                                         Pad_0[0x198];                                      // 0x0000(0x0198)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayEffectCustomExecutionParameters) == 0x000008, "Wrong alignment on FGameplayEffectCustomExecutionParameters");
static_assert(sizeof(FGameplayEffectCustomExecutionParameters) == 0x000198, "Wrong size on FGameplayEffectCustomExecutionParameters");

// ScriptStruct GameplayAbilities.GameplayEffectCustomExecutionOutput
// 0x0018 (0x0018 - 0x0000)
struct FGameplayEffectCustomExecutionOutput final
{
public:
	TArray<struct FGameplayModifierEvaluatedData> OutputModifiers;                                   // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         bTriggerConditionalGameplayEffects : 1;            // 0x0010(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bHandledStackCountManually : 1;                    // 0x0010(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bHandledGameplayCuesManually : 1;                  // 0x0010(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayEffectCustomExecutionOutput) == 0x000008, "Wrong alignment on FGameplayEffectCustomExecutionOutput");
static_assert(sizeof(FGameplayEffectCustomExecutionOutput) == 0x000018, "Wrong size on FGameplayEffectCustomExecutionOutput");
static_assert(offsetof(FGameplayEffectCustomExecutionOutput, OutputModifiers) == 0x000000, "Member 'FGameplayEffectCustomExecutionOutput::OutputModifiers' has a wrong offset!");

// ScriptStruct GameplayAbilities.GameplayEffectContext
// 0x00A8 (0x00A8 - 0x0000)
struct FGameplayEffectContext
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AActor>                  Instigator;                                        // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AActor>                  EffectCauser;                                      // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UGameplayAbility>        AbilityCDO;                                        // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UGameplayAbility>        AbilityInstanceNotReplicated;                      // 0x0020(0x0008)(ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         AbilityLevel;                                      // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UObject>                 SourceObject;                                      // 0x002C(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UAbilitySystemComponent> InstigatorAbilitySystemComponent;                  // 0x0034(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, RepSkip, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TWeakObjectPtr<class AActor>>          Actors;                                            // 0x0040(0x0010)(ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_50[0x38];                                      // 0x0050(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                WorldOrigin;                                       // 0x0088(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bHasWorldOrigin : 1;                               // 0x00A0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bReplicateSourceObject : 1;                        // 0x00A0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (RepSkip, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bReplicateInstigator : 1;                          // 0x00A0(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (RepSkip, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bReplicateEffectCauser : 1;                        // 0x00A0(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (RepSkip, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bRemoveOtherActiveEffects : 1;                     // 0x00A0(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayEffectContext) == 0x000008, "Wrong alignment on FGameplayEffectContext");
static_assert(sizeof(FGameplayEffectContext) == 0x0000A8, "Wrong size on FGameplayEffectContext");
static_assert(offsetof(FGameplayEffectContext, Instigator) == 0x000008, "Member 'FGameplayEffectContext::Instigator' has a wrong offset!");
static_assert(offsetof(FGameplayEffectContext, EffectCauser) == 0x000010, "Member 'FGameplayEffectContext::EffectCauser' has a wrong offset!");
static_assert(offsetof(FGameplayEffectContext, AbilityCDO) == 0x000018, "Member 'FGameplayEffectContext::AbilityCDO' has a wrong offset!");
static_assert(offsetof(FGameplayEffectContext, AbilityInstanceNotReplicated) == 0x000020, "Member 'FGameplayEffectContext::AbilityInstanceNotReplicated' has a wrong offset!");
static_assert(offsetof(FGameplayEffectContext, AbilityLevel) == 0x000028, "Member 'FGameplayEffectContext::AbilityLevel' has a wrong offset!");
static_assert(offsetof(FGameplayEffectContext, SourceObject) == 0x00002C, "Member 'FGameplayEffectContext::SourceObject' has a wrong offset!");
static_assert(offsetof(FGameplayEffectContext, InstigatorAbilitySystemComponent) == 0x000034, "Member 'FGameplayEffectContext::InstigatorAbilitySystemComponent' has a wrong offset!");
static_assert(offsetof(FGameplayEffectContext, Actors) == 0x000040, "Member 'FGameplayEffectContext::Actors' has a wrong offset!");
static_assert(offsetof(FGameplayEffectContext, WorldOrigin) == 0x000088, "Member 'FGameplayEffectContext::WorldOrigin' has a wrong offset!");

// ScriptStruct GameplayAbilities.PredictionKeyDebugInfo
// 0x01A0 (0x01A0 - 0x0000)
struct alignas(0x08) FPredictionKeyDebugInfo final
{
public:
	uint8                                         Pad_0[0x1A0];                                      // 0x0000(0x01A0)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPredictionKeyDebugInfo) == 0x000008, "Wrong alignment on FPredictionKeyDebugInfo");
static_assert(sizeof(FPredictionKeyDebugInfo) == 0x0001A0, "Wrong size on FPredictionKeyDebugInfo");

// ScriptStruct GameplayAbilities.PredictionKeyHandle
// 0x0020 (0x0020 - 0x0000)
struct FPredictionKeyHandle final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Current;                                           // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPredictionKeyHandle) == 0x000008, "Wrong alignment on FPredictionKeyHandle");
static_assert(sizeof(FPredictionKeyHandle) == 0x000020, "Wrong size on FPredictionKeyHandle");
static_assert(offsetof(FPredictionKeyHandle, Current) == 0x000010, "Member 'FPredictionKeyHandle::Current' has a wrong offset!");

// ScriptStruct GameplayAbilities.ScopedPredictionWindowHandle
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FScopedPredictionWindowHandle final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FScopedPredictionWindowHandle) == 0x000008, "Wrong alignment on FScopedPredictionWindowHandle");
static_assert(sizeof(FScopedPredictionWindowHandle) == 0x000010, "Wrong size on FScopedPredictionWindowHandle");

// ScriptStruct GameplayAbilities.GameplayTagReponsePair
// 0x0030 (0x0030 - 0x0000)
struct FGameplayTagReponsePair final
{
public:
	struct FGameplayTag                           Tag;                                               // 0x0000(0x000C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGameplayEffect>            ResponseGameplayEffect;                            // 0x0010(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UGameplayEffect>>    ResponseGameplayEffects;                           // 0x0018(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	int32                                         SoftCountCap;                                      // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayTagReponsePair) == 0x000008, "Wrong alignment on FGameplayTagReponsePair");
static_assert(sizeof(FGameplayTagReponsePair) == 0x000030, "Wrong size on FGameplayTagReponsePair");
static_assert(offsetof(FGameplayTagReponsePair, Tag) == 0x000000, "Member 'FGameplayTagReponsePair::Tag' has a wrong offset!");
static_assert(offsetof(FGameplayTagReponsePair, ResponseGameplayEffect) == 0x000010, "Member 'FGameplayTagReponsePair::ResponseGameplayEffect' has a wrong offset!");
static_assert(offsetof(FGameplayTagReponsePair, ResponseGameplayEffects) == 0x000018, "Member 'FGameplayTagReponsePair::ResponseGameplayEffects' has a wrong offset!");
static_assert(offsetof(FGameplayTagReponsePair, SoftCountCap) == 0x000028, "Member 'FGameplayTagReponsePair::SoftCountCap' has a wrong offset!");

// ScriptStruct GameplayAbilities.GameplayTagResponseTableEntry
// 0x0060 (0x0060 - 0x0000)
struct FGameplayTagResponseTableEntry final
{
public:
	struct FGameplayTagReponsePair                Positive;                                          // 0x0000(0x0030)(Edit, NativeAccessSpecifierPublic)
	struct FGameplayTagReponsePair                Negative;                                          // 0x0030(0x0030)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameplayTagResponseTableEntry) == 0x000008, "Wrong alignment on FGameplayTagResponseTableEntry");
static_assert(sizeof(FGameplayTagResponseTableEntry) == 0x000060, "Wrong size on FGameplayTagResponseTableEntry");
static_assert(offsetof(FGameplayTagResponseTableEntry, Positive) == 0x000000, "Member 'FGameplayTagResponseTableEntry::Positive' has a wrong offset!");
static_assert(offsetof(FGameplayTagResponseTableEntry, Negative) == 0x000030, "Member 'FGameplayTagResponseTableEntry::Negative' has a wrong offset!");

// ScriptStruct GameplayAbilities.MovieSceneGameplayCueKey
// 0x0098 (0x0098 - 0x0000)
struct FMovieSceneGameplayCueKey final
{
public:
	struct FGameplayCueTag                        Cue;                                               // 0x0000(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Location;                                          // 0x0010(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Normal;                                            // 0x0028(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AttachSocketName;                                  // 0x0040(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NormalizedMagnitude;                               // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMovieSceneObjectBindingID             Instigator;                                        // 0x0050(0x0018)(Edit, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMovieSceneObjectBindingID             EffectCauser;                                      // 0x0068(0x0018)(Edit, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPhysicalMaterial*                      PhysicalMaterial;                                  // 0x0080(0x0008)(Edit, ZeroConstructor, NoDestructor, AdvancedDisplay, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GameplayEffectLevel;                               // 0x0088(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AbilityLevel;                                      // 0x008C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAttachToBinding;                                  // 0x0090(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x7];                                       // 0x0091(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMovieSceneGameplayCueKey) == 0x000008, "Wrong alignment on FMovieSceneGameplayCueKey");
static_assert(sizeof(FMovieSceneGameplayCueKey) == 0x000098, "Wrong size on FMovieSceneGameplayCueKey");
static_assert(offsetof(FMovieSceneGameplayCueKey, Cue) == 0x000000, "Member 'FMovieSceneGameplayCueKey::Cue' has a wrong offset!");
static_assert(offsetof(FMovieSceneGameplayCueKey, Location) == 0x000010, "Member 'FMovieSceneGameplayCueKey::Location' has a wrong offset!");
static_assert(offsetof(FMovieSceneGameplayCueKey, Normal) == 0x000028, "Member 'FMovieSceneGameplayCueKey::Normal' has a wrong offset!");
static_assert(offsetof(FMovieSceneGameplayCueKey, AttachSocketName) == 0x000040, "Member 'FMovieSceneGameplayCueKey::AttachSocketName' has a wrong offset!");
static_assert(offsetof(FMovieSceneGameplayCueKey, NormalizedMagnitude) == 0x00004C, "Member 'FMovieSceneGameplayCueKey::NormalizedMagnitude' has a wrong offset!");
static_assert(offsetof(FMovieSceneGameplayCueKey, Instigator) == 0x000050, "Member 'FMovieSceneGameplayCueKey::Instigator' has a wrong offset!");
static_assert(offsetof(FMovieSceneGameplayCueKey, EffectCauser) == 0x000068, "Member 'FMovieSceneGameplayCueKey::EffectCauser' has a wrong offset!");
static_assert(offsetof(FMovieSceneGameplayCueKey, PhysicalMaterial) == 0x000080, "Member 'FMovieSceneGameplayCueKey::PhysicalMaterial' has a wrong offset!");
static_assert(offsetof(FMovieSceneGameplayCueKey, GameplayEffectLevel) == 0x000088, "Member 'FMovieSceneGameplayCueKey::GameplayEffectLevel' has a wrong offset!");
static_assert(offsetof(FMovieSceneGameplayCueKey, AbilityLevel) == 0x00008C, "Member 'FMovieSceneGameplayCueKey::AbilityLevel' has a wrong offset!");
static_assert(offsetof(FMovieSceneGameplayCueKey, bAttachToBinding) == 0x000090, "Member 'FMovieSceneGameplayCueKey::bAttachToBinding' has a wrong offset!");

// ScriptStruct GameplayAbilities.MovieSceneGameplayCueChannel
// 0x00A8 (0x00F8 - 0x0050)
struct FMovieSceneGameplayCueChannel final : public FMovieSceneChannel
{
public:
	TArray<struct FFrameNumber>                   KeyTimes;                                          // 0x0050(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FMovieSceneGameplayCueKey>      KeyValues;                                         // 0x0060(0x0010)(ZeroConstructor, AssetRegistrySearchable, NativeAccessSpecifierPrivate)
	uint8                                         Pad_70[0x88];                                      // 0x0070(0x0088)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMovieSceneGameplayCueChannel) == 0x000008, "Wrong alignment on FMovieSceneGameplayCueChannel");
static_assert(sizeof(FMovieSceneGameplayCueChannel) == 0x0000F8, "Wrong size on FMovieSceneGameplayCueChannel");
static_assert(offsetof(FMovieSceneGameplayCueChannel, KeyTimes) == 0x000050, "Member 'FMovieSceneGameplayCueChannel::KeyTimes' has a wrong offset!");
static_assert(offsetof(FMovieSceneGameplayCueChannel, KeyValues) == 0x000060, "Member 'FMovieSceneGameplayCueChannel::KeyValues' has a wrong offset!");

// ScriptStruct GameplayAbilities.GameplayAbilityRepAnimMontageNetSerializerConfig
// 0x0001 (0x0001 - 0x0000)
struct FGameplayAbilityRepAnimMontageNetSerializerConfig final : public FNetSerializerConfig
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayAbilityRepAnimMontageNetSerializerConfig) == 0x000001, "Wrong alignment on FGameplayAbilityRepAnimMontageNetSerializerConfig");
static_assert(sizeof(FGameplayAbilityRepAnimMontageNetSerializerConfig) == 0x000001, "Wrong size on FGameplayAbilityRepAnimMontageNetSerializerConfig");

// ScriptStruct GameplayAbilities.GameplayEffectContextHandleNetSerializerConfig
// 0x0000 (0x0001 - 0x0001)
struct FGameplayEffectContextHandleNetSerializerConfig final : public FPolymorphicStructNetSerializerConfig
{
};
static_assert(alignof(FGameplayEffectContextHandleNetSerializerConfig) == 0x000001, "Wrong alignment on FGameplayEffectContextHandleNetSerializerConfig");
static_assert(sizeof(FGameplayEffectContextHandleNetSerializerConfig) == 0x000001, "Wrong size on FGameplayEffectContextHandleNetSerializerConfig");

// ScriptStruct GameplayAbilities.GameplayEffectContextNetSerializerConfig
// 0x0001 (0x0001 - 0x0000)
struct FGameplayEffectContextNetSerializerConfig final : public FNetSerializerConfig
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayEffectContextNetSerializerConfig) == 0x000001, "Wrong alignment on FGameplayEffectContextNetSerializerConfig");
static_assert(sizeof(FGameplayEffectContextNetSerializerConfig) == 0x000001, "Wrong size on FGameplayEffectContextNetSerializerConfig");

// ScriptStruct GameplayAbilities.MinimalGameplayCueReplicationProxyNetSerializerConfig
// 0x0001 (0x0001 - 0x0000)
struct FMinimalGameplayCueReplicationProxyNetSerializerConfig final : public FNetSerializerConfig
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMinimalGameplayCueReplicationProxyNetSerializerConfig) == 0x000001, "Wrong alignment on FMinimalGameplayCueReplicationProxyNetSerializerConfig");
static_assert(sizeof(FMinimalGameplayCueReplicationProxyNetSerializerConfig) == 0x000001, "Wrong size on FMinimalGameplayCueReplicationProxyNetSerializerConfig");

// ScriptStruct GameplayAbilities.MinimalReplicationTagCountMapNetSerializerConfig
// 0x0001 (0x0001 - 0x0000)
struct FMinimalReplicationTagCountMapNetSerializerConfig final : public FNetSerializerConfig
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMinimalReplicationTagCountMapNetSerializerConfig) == 0x000001, "Wrong alignment on FMinimalReplicationTagCountMapNetSerializerConfig");
static_assert(sizeof(FMinimalReplicationTagCountMapNetSerializerConfig) == 0x000001, "Wrong size on FMinimalReplicationTagCountMapNetSerializerConfig");

// ScriptStruct GameplayAbilities.PredictionKeyNetSerializerConfig
// 0x0001 (0x0001 - 0x0000)
struct FPredictionKeyNetSerializerConfig final : public FNetSerializerConfig
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPredictionKeyNetSerializerConfig) == 0x000001, "Wrong alignment on FPredictionKeyNetSerializerConfig");
static_assert(sizeof(FPredictionKeyNetSerializerConfig) == 0x000001, "Wrong size on FPredictionKeyNetSerializerConfig");

}

