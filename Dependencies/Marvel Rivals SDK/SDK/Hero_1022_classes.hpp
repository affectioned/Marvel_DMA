#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Hero_1022

#include "Basic.hpp"

#include "Marvel_structs.hpp"
#include "Marvel_classes.hpp"
#include "CoreUObject_structs.hpp"
#include "GameplayTags_structs.hpp"
#include "Hero_1022_structs.hpp"
#include "Engine_structs.hpp"
#include "DeclarativeUnreal_structs.hpp"


namespace SDK
{

// Class Hero_1022.Cue_Projectile_Loop_10223301
// 0x0080 (0x11B0 - 0x1130)
class ACue_Projectile_Loop_10223301 final : public AMarvelCueNotify_Projectile
{
public:
	class UNiagaraComponent*                      NS_Loop1;                                          // 0x1128(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      NS_Loop2;                                          // 0x1130(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DelayTime;                                         // 0x1138(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TraceTime;                                         // 0x113C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndDistance;                                       // 0x1140(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   HomingAttachMeshComName;                           // 0x1144(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               ThreeEffectOffset;                                 // 0x1150(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               FourEffectOffset;                                  // 0x1168(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1180[0x20];                                    // 0x1180(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        HomingAttachMeshCom;                               // 0x11A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNiagaraComponent*                      CurrentNiagara;                                    // 0x11A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void DelayShowFX();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Projectile_Loop_10223301">();
	}
	static class ACue_Projectile_Loop_10223301* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Projectile_Loop_10223301>();
	}
};
static_assert(alignof(ACue_Projectile_Loop_10223301) == 0x000010, "Wrong alignment on ACue_Projectile_Loop_10223301");
static_assert(sizeof(ACue_Projectile_Loop_10223301) == 0x0011B0, "Wrong size on ACue_Projectile_Loop_10223301");
static_assert(offsetof(ACue_Projectile_Loop_10223301, NS_Loop1) == 0x001128, "Member 'ACue_Projectile_Loop_10223301::NS_Loop1' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10223301, NS_Loop2) == 0x001130, "Member 'ACue_Projectile_Loop_10223301::NS_Loop2' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10223301, DelayTime) == 0x001138, "Member 'ACue_Projectile_Loop_10223301::DelayTime' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10223301, TraceTime) == 0x00113C, "Member 'ACue_Projectile_Loop_10223301::TraceTime' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10223301, EndDistance) == 0x001140, "Member 'ACue_Projectile_Loop_10223301::EndDistance' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10223301, HomingAttachMeshComName) == 0x001144, "Member 'ACue_Projectile_Loop_10223301::HomingAttachMeshComName' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10223301, ThreeEffectOffset) == 0x001150, "Member 'ACue_Projectile_Loop_10223301::ThreeEffectOffset' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10223301, FourEffectOffset) == 0x001168, "Member 'ACue_Projectile_Loop_10223301::FourEffectOffset' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10223301, HomingAttachMeshCom) == 0x0011A0, "Member 'ACue_Projectile_Loop_10223301::HomingAttachMeshCom' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10223301, CurrentNiagara) == 0x0011A8, "Member 'ACue_Projectile_Loop_10223301::CurrentNiagara' has a wrong offset!");

// Class Hero_1022.Config_102261
// 0x16F8 (0x1790 - 0x0098)
class UConfig_102261 : public UMarvelAbilityConfig
{
public:
	float                                         DamageReductionPerBounce1;                         // 0x0098(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageReductionPerBounce2;                         // 0x009C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageReductionPerBounce3;                         // 0x00A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A4[0xC];                                       // 0x00A4(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FProjectileBounceInfo                  BounceInfo;                                        // 0x00B0(0x16E0)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_102261">();
	}
	static class UConfig_102261* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_102261>();
	}
};
static_assert(alignof(UConfig_102261) == 0x000010, "Wrong alignment on UConfig_102261");
static_assert(sizeof(UConfig_102261) == 0x001790, "Wrong size on UConfig_102261");
static_assert(offsetof(UConfig_102261, DamageReductionPerBounce1) == 0x000098, "Member 'UConfig_102261::DamageReductionPerBounce1' has a wrong offset!");
static_assert(offsetof(UConfig_102261, DamageReductionPerBounce2) == 0x00009C, "Member 'UConfig_102261::DamageReductionPerBounce2' has a wrong offset!");
static_assert(offsetof(UConfig_102261, DamageReductionPerBounce3) == 0x0000A0, "Member 'UConfig_102261::DamageReductionPerBounce3' has a wrong offset!");
static_assert(offsetof(UConfig_102261, BounceInfo) == 0x0000B0, "Member 'UConfig_102261::BounceInfo' has a wrong offset!");

// Class Hero_1022.Config_102235
// 0x1660 (0x2DF0 - 0x1790)
class UConfig_102235 : public UConfig_102261
{
public:
	struct FMarvelAbilityTraceContext             BeginTraceContext;                                 // 0x1790(0x1660)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_102235">();
	}
	static class UConfig_102235* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_102235>();
	}
};
static_assert(alignof(UConfig_102235) == 0x000010, "Wrong alignment on UConfig_102235");
static_assert(sizeof(UConfig_102235) == 0x002DF0, "Wrong size on UConfig_102235");
static_assert(offsetof(UConfig_102235, BeginTraceContext) == 0x001790, "Member 'UConfig_102235::BeginTraceContext' has a wrong offset!");

// Class Hero_1022.Projectile_10226101
// 0x0000 (0x5360 - 0x5360)
class AProjectile_10226101 : public AMarvelBounceProjectile
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Projectile_10226101">();
	}
	static class AProjectile_10226101* GetDefaultObj()
	{
		return GetDefaultObjImpl<AProjectile_10226101>();
	}
};
static_assert(alignof(AProjectile_10226101) == 0x000010, "Wrong alignment on AProjectile_10226101");
static_assert(sizeof(AProjectile_10226101) == 0x005360, "Wrong size on AProjectile_10226101");

// Class Hero_1022.Projectile_10223101
// 0x0000 (0x5360 - 0x5360)
class AProjectile_10223101 : public AProjectile_10226101
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Projectile_10223101">();
	}
	static class AProjectile_10223101* GetDefaultObj()
	{
		return GetDefaultObjImpl<AProjectile_10223101>();
	}
};
static_assert(alignof(AProjectile_10223101) == 0x000010, "Wrong alignment on AProjectile_10223101");
static_assert(sizeof(AProjectile_10223101) == 0x005360, "Wrong size on AProjectile_10223101");

// Class Hero_1022.Projectile_10223105
// 0x0000 (0x5360 - 0x5360)
class AProjectile_10223105 final : public AProjectile_10223101
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Projectile_10223105">();
	}
	static class AProjectile_10223105* GetDefaultObj()
	{
		return GetDefaultObjImpl<AProjectile_10223105>();
	}
};
static_assert(alignof(AProjectile_10223105) == 0x000010, "Wrong alignment on AProjectile_10223105");
static_assert(sizeof(AProjectile_10223105) == 0x005360, "Wrong size on AProjectile_10223105");

// Class Hero_1022.UIC_Controller_102235
// 0x0028 (0x0F38 - 0x0F10)
class UUIC_Controller_102235 : public UUIC_Ability
{
public:
	struct FGameplayTag                           AbilityCountTag;                                   // 0x0F10(0x000C)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           BuffTag;                                           // 0x0F1C(0x000C)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F28[0x10];                                     // 0x0F28(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAbilityCountUpdate(const struct FGameplayTag& Tag, int32 NewCount);
	void OnBuffTagUpdate(const struct FGameplayTag& Tag, int32 NewCount);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIC_Controller_102235">();
	}
	static class UUIC_Controller_102235* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIC_Controller_102235>();
	}
};
static_assert(alignof(UUIC_Controller_102235) == 0x000008, "Wrong alignment on UUIC_Controller_102235");
static_assert(sizeof(UUIC_Controller_102235) == 0x000F38, "Wrong size on UUIC_Controller_102235");
static_assert(offsetof(UUIC_Controller_102235, AbilityCountTag) == 0x000F10, "Member 'UUIC_Controller_102235::AbilityCountTag' has a wrong offset!");
static_assert(offsetof(UUIC_Controller_102235, BuffTag) == 0x000F1C, "Member 'UUIC_Controller_102235::BuffTag' has a wrong offset!");

// Class Hero_1022.Config_102241
// 0x0018 (0x00B0 - 0x0098)
class UConfig_102241 : public UMarvelAbilityConfig
{
public:
	bool                                          bEnableAttachSocket;                               // 0x0098(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x3];                                       // 0x0099(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BackwardWalkSpeedRatio;                            // 0x009C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 BuffList;                                          // 0x00A0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_102241">();
	}
	static class UConfig_102241* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_102241>();
	}
};
static_assert(alignof(UConfig_102241) == 0x000008, "Wrong alignment on UConfig_102241");
static_assert(sizeof(UConfig_102241) == 0x0000B0, "Wrong size on UConfig_102241");
static_assert(offsetof(UConfig_102241, bEnableAttachSocket) == 0x000098, "Member 'UConfig_102241::bEnableAttachSocket' has a wrong offset!");
static_assert(offsetof(UConfig_102241, BackwardWalkSpeedRatio) == 0x00009C, "Member 'UConfig_102241::BackwardWalkSpeedRatio' has a wrong offset!");
static_assert(offsetof(UConfig_102241, BuffList) == 0x0000A0, "Member 'UConfig_102241::BuffList' has a wrong offset!");

// Class Hero_1022.ReflexReceiverComponent_102241
// 0x0000 (0x0478 - 0x0478)
class UReflexReceiverComponent_102241 final : public UMarvelReflexReceiverComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReflexReceiverComponent_102241">();
	}
	static class UReflexReceiverComponent_102241* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReflexReceiverComponent_102241>();
	}
};
static_assert(alignof(UReflexReceiverComponent_102241) == 0x000008, "Wrong alignment on UReflexReceiverComponent_102241");
static_assert(sizeof(UReflexReceiverComponent_102241) == 0x000478, "Wrong size on UReflexReceiverComponent_102241");

// Class Hero_1022.SummonedComp_102241
// 0x0000 (0x0DB0 - 0x0DB0)
class USummonedComp_102241 : public UMarvelSummonedComponent
{
public:
	void OnApplyBuff(class UAbilitySystemComponent* Source, class UAbilitySystemComponent* Target, const struct FGameplayEffectSpecStackHandle& EffectSpecHandle, const struct FActiveGameplayEffectHandle& EffectHandle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SummonedComp_102241">();
	}
	static class USummonedComp_102241* GetDefaultObj()
	{
		return GetDefaultObjImpl<USummonedComp_102241>();
	}
};
static_assert(alignof(USummonedComp_102241) == 0x000008, "Wrong alignment on USummonedComp_102241");
static_assert(sizeof(USummonedComp_102241) == 0x000DB0, "Wrong size on USummonedComp_102241");

// Class Hero_1022.Summoned_102241
// 0x0070 (0x0BB0 - 0x0B40)
class ASummoned_102241 : public AMarvelSummonerBase
{
public:
	class UReflexReceiverComponent_102241*        ReflexReceiverComponent;                           // 0x0B40(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsShieldActive;                                   // 0x0B48(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B49[0x7];                                      // 0x0B49(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                BodyOffset;                                        // 0x0B50(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                BodyRotation;                                      // 0x0B68(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LocalOriginCoordinates;                            // 0x0B80(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Length;                                            // 0x0B98(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxPitch;                                          // 0x0B9C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinPitch;                                          // 0x0BA0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BA4[0x4];                                      // 0x0BA4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UConfig_102241*                         AbilityConfig;                                     // 0x0BA8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	class UConfig_102241* GetConfig();
	void K2_SetAlive(bool bInAlive);
	void OnRep_IsShieldActive();
	void OnSummonedCompBeginAgentTask();
	void OnSummonedCompEndAgentTask();
	void ResetHealth();
	void SetShieldActive(bool bIsActive);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Summoned_102241">();
	}
	static class ASummoned_102241* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASummoned_102241>();
	}
};
static_assert(alignof(ASummoned_102241) == 0x000010, "Wrong alignment on ASummoned_102241");
static_assert(sizeof(ASummoned_102241) == 0x000BB0, "Wrong size on ASummoned_102241");
static_assert(offsetof(ASummoned_102241, ReflexReceiverComponent) == 0x000B40, "Member 'ASummoned_102241::ReflexReceiverComponent' has a wrong offset!");
static_assert(offsetof(ASummoned_102241, bIsShieldActive) == 0x000B48, "Member 'ASummoned_102241::bIsShieldActive' has a wrong offset!");
static_assert(offsetof(ASummoned_102241, BodyOffset) == 0x000B50, "Member 'ASummoned_102241::BodyOffset' has a wrong offset!");
static_assert(offsetof(ASummoned_102241, BodyRotation) == 0x000B68, "Member 'ASummoned_102241::BodyRotation' has a wrong offset!");
static_assert(offsetof(ASummoned_102241, LocalOriginCoordinates) == 0x000B80, "Member 'ASummoned_102241::LocalOriginCoordinates' has a wrong offset!");
static_assert(offsetof(ASummoned_102241, Length) == 0x000B98, "Member 'ASummoned_102241::Length' has a wrong offset!");
static_assert(offsetof(ASummoned_102241, MaxPitch) == 0x000B9C, "Member 'ASummoned_102241::MaxPitch' has a wrong offset!");
static_assert(offsetof(ASummoned_102241, MinPitch) == 0x000BA0, "Member 'ASummoned_102241::MinPitch' has a wrong offset!");
static_assert(offsetof(ASummoned_102241, AbilityConfig) == 0x000BA8, "Member 'ASummoned_102241::AbilityConfig' has a wrong offset!");

// Class Hero_1022.Cue_Summoner_Damaged_10224102
// 0x0020 (0x05E8 - 0x05C8)
class UCue_Summoner_Damaged_10224102 final : public UMarvelCueNotify_HitImpact
{
public:
	TArray<struct FAmplitudeRange>                AmplitudeRangeArray;                               // 0x05C8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 IgnoreScopeID;                                     // 0x05D8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Summoner_Damaged_10224102">();
	}
	static class UCue_Summoner_Damaged_10224102* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCue_Summoner_Damaged_10224102>();
	}
};
static_assert(alignof(UCue_Summoner_Damaged_10224102) == 0x000008, "Wrong alignment on UCue_Summoner_Damaged_10224102");
static_assert(sizeof(UCue_Summoner_Damaged_10224102) == 0x0005E8, "Wrong size on UCue_Summoner_Damaged_10224102");
static_assert(offsetof(UCue_Summoner_Damaged_10224102, AmplitudeRangeArray) == 0x0005C8, "Member 'UCue_Summoner_Damaged_10224102::AmplitudeRangeArray' has a wrong offset!");
static_assert(offsetof(UCue_Summoner_Damaged_10224102, IgnoreScopeID) == 0x0005D8, "Member 'UCue_Summoner_Damaged_10224102::IgnoreScopeID' has a wrong offset!");

// Class Hero_1022.Config_102251
// 0x0010 (0x00A8 - 0x0098)
class UConfig_102251 final : public UMarvelAbilityConfig
{
public:
	class UCurveFloat*                            SpeedCurve;                                        // 0x0098(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BuffId;                                            // 0x00A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_102251">();
	}
	static class UConfig_102251* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_102251>();
	}
};
static_assert(alignof(UConfig_102251) == 0x000008, "Wrong alignment on UConfig_102251");
static_assert(sizeof(UConfig_102251) == 0x0000A8, "Wrong size on UConfig_102251");
static_assert(offsetof(UConfig_102251, SpeedCurve) == 0x000098, "Member 'UConfig_102251::SpeedCurve' has a wrong offset!");
static_assert(offsetof(UConfig_102251, BuffId) == 0x0000A0, "Member 'UConfig_102251::BuffId' has a wrong offset!");

// Class Hero_1022.Ability_102251
// 0x0008 (0x29F8 - 0x29F0)
class UAbility_102251 : public UMarvelGameplayAbility
{
public:
	class UConfig_102251*                         Config102251;                                      // 0x29F0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void OnGameplayEvent(const struct FGameplayEventData& EventData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_102251">();
	}
	static class UAbility_102251* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_102251>();
	}
};
static_assert(alignof(UAbility_102251) == 0x000008, "Wrong alignment on UAbility_102251");
static_assert(sizeof(UAbility_102251) == 0x0029F8, "Wrong size on UAbility_102251");
static_assert(offsetof(UAbility_102251, Config102251) == 0x0029F0, "Member 'UAbility_102251::Config102251' has a wrong offset!");

// Class Hero_1022.MarvelCueNotify_CaptainShadow
// 0x02B0 (0x1460 - 0x11B0)
class AMarvelCueNotify_CaptainShadow : public AMarvelCueNotify_Ability
{
public:
	class UPoseableMeshComponent*                 Mesh1;                                             // 0x11B0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPoseableMeshComponent*                 Mesh2;                                             // 0x11B8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPoseableMeshComponent*                 Mesh3;                                             // 0x11C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPoseableMeshComponent*                 Mesh4;                                             // 0x11C8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPoseableMeshComponent*                 Mesh5;                                             // 0x11D0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FShadowMeshInfo                        MeshInfo;                                          // 0x11D8(0x00B8)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FShadowMeshInfo>                ChildsMeshInfo;                                    // 0x1290(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         ShadowMeshLOD;                                     // 0x12A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SimulateShadowMeshLOD;                             // 0x12A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 ShadowShowTime;                                    // 0x12A8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UCurveVector*                           ShadowScaleCurve;                                  // 0x12B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            ShadowOpacityCurve;                                // 0x12C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   OpacityName;                                       // 0x12C8(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MovePositionName;                                  // 0x12D4(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveOffset;                                        // 0x12E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseDyeingMethod;                                   // 0x12E4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12E5[0x3];                                     // 0x12E5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     CommonDyeingMaterial;                              // 0x12E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<int32, class UMaterialInterface*>        CustomDyeingMaterialDict;                          // 0x12F0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FMaterialParamCopyInfo                 BaseCopyParam;                                     // 0x1340(0x0058)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FMaterialParamCopyInfo                 DyeingCopyParam;                                   // 0x1398(0x0058)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<class UPoseableMeshComponent*>         ShadowMeshComponents;                              // 0x13F0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1400[0x30];                                    // 0x1400(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDeclarationHolder                     ViewTargetHolder;                                  // 0x1430(0x0010)(NativeAccessSpecifierPrivate)
	TDelegate<void(class AActor* InActor)>        ViewTargetDelegate;                                // 0x1440(0x0014)(ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1454[0xC];                                     // 0x1454(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnViewTargetChange(class AActor* ViewingTarget);
	void RecordCharacterSprintInfo(float DeltaSeconds);
	void ResetParameter();
	void SetCharacterMeshHidden(class UPoseableMeshComponent* Mesh, bool NewHidden);
	void SetCharacterMeshMovePosition(class UPoseableMeshComponent* Mesh, const struct FVector& MoveDir);
	void SetCharacterMeshOpacity(class UPoseableMeshComponent* Mesh, float Opacity);
	void SetShadowMeshMaterial(struct FShadowMeshInfo* ShadowMeshInfo, TArray<struct FShadowMeshInfo>* ChildShadowMeshInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelCueNotify_CaptainShadow">();
	}
	static class AMarvelCueNotify_CaptainShadow* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMarvelCueNotify_CaptainShadow>();
	}
};
static_assert(alignof(AMarvelCueNotify_CaptainShadow) == 0x000010, "Wrong alignment on AMarvelCueNotify_CaptainShadow");
static_assert(sizeof(AMarvelCueNotify_CaptainShadow) == 0x001460, "Wrong size on AMarvelCueNotify_CaptainShadow");
static_assert(offsetof(AMarvelCueNotify_CaptainShadow, Mesh1) == 0x0011B0, "Member 'AMarvelCueNotify_CaptainShadow::Mesh1' has a wrong offset!");
static_assert(offsetof(AMarvelCueNotify_CaptainShadow, Mesh2) == 0x0011B8, "Member 'AMarvelCueNotify_CaptainShadow::Mesh2' has a wrong offset!");
static_assert(offsetof(AMarvelCueNotify_CaptainShadow, Mesh3) == 0x0011C0, "Member 'AMarvelCueNotify_CaptainShadow::Mesh3' has a wrong offset!");
static_assert(offsetof(AMarvelCueNotify_CaptainShadow, Mesh4) == 0x0011C8, "Member 'AMarvelCueNotify_CaptainShadow::Mesh4' has a wrong offset!");
static_assert(offsetof(AMarvelCueNotify_CaptainShadow, Mesh5) == 0x0011D0, "Member 'AMarvelCueNotify_CaptainShadow::Mesh5' has a wrong offset!");
static_assert(offsetof(AMarvelCueNotify_CaptainShadow, MeshInfo) == 0x0011D8, "Member 'AMarvelCueNotify_CaptainShadow::MeshInfo' has a wrong offset!");
static_assert(offsetof(AMarvelCueNotify_CaptainShadow, ChildsMeshInfo) == 0x001290, "Member 'AMarvelCueNotify_CaptainShadow::ChildsMeshInfo' has a wrong offset!");
static_assert(offsetof(AMarvelCueNotify_CaptainShadow, ShadowMeshLOD) == 0x0012A0, "Member 'AMarvelCueNotify_CaptainShadow::ShadowMeshLOD' has a wrong offset!");
static_assert(offsetof(AMarvelCueNotify_CaptainShadow, SimulateShadowMeshLOD) == 0x0012A4, "Member 'AMarvelCueNotify_CaptainShadow::SimulateShadowMeshLOD' has a wrong offset!");
static_assert(offsetof(AMarvelCueNotify_CaptainShadow, ShadowShowTime) == 0x0012A8, "Member 'AMarvelCueNotify_CaptainShadow::ShadowShowTime' has a wrong offset!");
static_assert(offsetof(AMarvelCueNotify_CaptainShadow, ShadowScaleCurve) == 0x0012B8, "Member 'AMarvelCueNotify_CaptainShadow::ShadowScaleCurve' has a wrong offset!");
static_assert(offsetof(AMarvelCueNotify_CaptainShadow, ShadowOpacityCurve) == 0x0012C0, "Member 'AMarvelCueNotify_CaptainShadow::ShadowOpacityCurve' has a wrong offset!");
static_assert(offsetof(AMarvelCueNotify_CaptainShadow, OpacityName) == 0x0012C8, "Member 'AMarvelCueNotify_CaptainShadow::OpacityName' has a wrong offset!");
static_assert(offsetof(AMarvelCueNotify_CaptainShadow, MovePositionName) == 0x0012D4, "Member 'AMarvelCueNotify_CaptainShadow::MovePositionName' has a wrong offset!");
static_assert(offsetof(AMarvelCueNotify_CaptainShadow, MoveOffset) == 0x0012E0, "Member 'AMarvelCueNotify_CaptainShadow::MoveOffset' has a wrong offset!");
static_assert(offsetof(AMarvelCueNotify_CaptainShadow, UseDyeingMethod) == 0x0012E4, "Member 'AMarvelCueNotify_CaptainShadow::UseDyeingMethod' has a wrong offset!");
static_assert(offsetof(AMarvelCueNotify_CaptainShadow, CommonDyeingMaterial) == 0x0012E8, "Member 'AMarvelCueNotify_CaptainShadow::CommonDyeingMaterial' has a wrong offset!");
static_assert(offsetof(AMarvelCueNotify_CaptainShadow, CustomDyeingMaterialDict) == 0x0012F0, "Member 'AMarvelCueNotify_CaptainShadow::CustomDyeingMaterialDict' has a wrong offset!");
static_assert(offsetof(AMarvelCueNotify_CaptainShadow, BaseCopyParam) == 0x001340, "Member 'AMarvelCueNotify_CaptainShadow::BaseCopyParam' has a wrong offset!");
static_assert(offsetof(AMarvelCueNotify_CaptainShadow, DyeingCopyParam) == 0x001398, "Member 'AMarvelCueNotify_CaptainShadow::DyeingCopyParam' has a wrong offset!");
static_assert(offsetof(AMarvelCueNotify_CaptainShadow, ShadowMeshComponents) == 0x0013F0, "Member 'AMarvelCueNotify_CaptainShadow::ShadowMeshComponents' has a wrong offset!");
static_assert(offsetof(AMarvelCueNotify_CaptainShadow, ViewTargetHolder) == 0x001430, "Member 'AMarvelCueNotify_CaptainShadow::ViewTargetHolder' has a wrong offset!");
static_assert(offsetof(AMarvelCueNotify_CaptainShadow, ViewTargetDelegate) == 0x001440, "Member 'AMarvelCueNotify_CaptainShadow::ViewTargetDelegate' has a wrong offset!");

// Class Hero_1022.Cue_Ability_Loop_10225101
// 0x00C0 (0x1270 - 0x11B0)
class ACue_Ability_Loop_10225101 final : public AMarvelCueNotify_Ability
{
public:
	uint8                                         Pad_11B0[0x18];                                    // 0x11B0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraComponent*                      VelocityLineFX;                                    // 0x11C8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartFXDelayTime;                                  // 0x11D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11D4[0xC];                                     // 0x11D4(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             StartFXRelativeTransform;                          // 0x11E0(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFXSystemAsset*                         DelayStartFX;                                      // 0x1240(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     PostProcessingMaterial;                            // 0x1248(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1250[0x20];                                    // 0x1250(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnTagChanged(const struct FGameplayTag& TagUpdated, bool TagExists);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Ability_Loop_10225101">();
	}
	static class ACue_Ability_Loop_10225101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Ability_Loop_10225101>();
	}
};
static_assert(alignof(ACue_Ability_Loop_10225101) == 0x000010, "Wrong alignment on ACue_Ability_Loop_10225101");
static_assert(sizeof(ACue_Ability_Loop_10225101) == 0x001270, "Wrong size on ACue_Ability_Loop_10225101");
static_assert(offsetof(ACue_Ability_Loop_10225101, VelocityLineFX) == 0x0011C8, "Member 'ACue_Ability_Loop_10225101::VelocityLineFX' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10225101, StartFXDelayTime) == 0x0011D0, "Member 'ACue_Ability_Loop_10225101::StartFXDelayTime' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10225101, StartFXRelativeTransform) == 0x0011E0, "Member 'ACue_Ability_Loop_10225101::StartFXRelativeTransform' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10225101, DelayStartFX) == 0x001240, "Member 'ACue_Ability_Loop_10225101::DelayStartFX' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10225101, PostProcessingMaterial) == 0x001248, "Member 'ACue_Ability_Loop_10225101::PostProcessingMaterial' has a wrong offset!");

// Class Hero_1022.Config_102252
// 0x0008 (0x00A0 - 0x0098)
class UConfig_102252 final : public UMarvelAbilityConfig
{
public:
	float                                         JumpUpSpeedExtra;                                  // 0x0098(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_102252">();
	}
	static class UConfig_102252* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_102252>();
	}
};
static_assert(alignof(UConfig_102252) == 0x000008, "Wrong alignment on UConfig_102252");
static_assert(sizeof(UConfig_102252) == 0x0000A0, "Wrong size on UConfig_102252");
static_assert(offsetof(UConfig_102252, JumpUpSpeedExtra) == 0x000098, "Member 'UConfig_102252::JumpUpSpeedExtra' has a wrong offset!");

// Class Hero_1022.Ability_102252
// 0x0040 (0x2A30 - 0x29F0)
class UAbility_102252 final : public UMarvelGameplayAbility
{
public:
	class UConfig_102252*                         Config;                                            // 0x29F0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29F8[0x38];                                    // 0x29F8(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_102252">();
	}
	static class UAbility_102252* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_102252>();
	}
};
static_assert(alignof(UAbility_102252) == 0x000008, "Wrong alignment on UAbility_102252");
static_assert(sizeof(UAbility_102252) == 0x002A30, "Wrong size on UAbility_102252");
static_assert(offsetof(UAbility_102252, Config) == 0x0029F0, "Member 'UAbility_102252::Config' has a wrong offset!");

// Class Hero_1022.Config_102254
// 0x2CF8 (0x2D90 - 0x0098)
class UConfig_102254 final : public UMarvelAbilityConfig
{
public:
	float                                         MaxCharacterHeightToActivate;                      // 0x0098(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinCharacterHeightToActivate;                      // 0x009C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinAimHeightToActivate;                            // 0x00A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSmashRadius;                                    // 0x00A4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GroundCheckAngle;                                  // 0x00A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SmashPermissionBuffID;                             // 0x00AC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           SmashCooldownTag;                                  // 0x00B0(0x000C)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TraceRate;                                         // 0x00BC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BackTraceDistance;                                 // 0x00C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C4[0xC];                                       // 0x00C4(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMarvelAbilityTraceContext             TraceDownContext;                                  // 0x00D0(0x1660)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FMarvelAbilityTraceContext             TraceAimContext;                                   // 0x1730(0x1660)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_102254">();
	}
	static class UConfig_102254* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_102254>();
	}
};
static_assert(alignof(UConfig_102254) == 0x000010, "Wrong alignment on UConfig_102254");
static_assert(sizeof(UConfig_102254) == 0x002D90, "Wrong size on UConfig_102254");
static_assert(offsetof(UConfig_102254, MaxCharacterHeightToActivate) == 0x000098, "Member 'UConfig_102254::MaxCharacterHeightToActivate' has a wrong offset!");
static_assert(offsetof(UConfig_102254, MinCharacterHeightToActivate) == 0x00009C, "Member 'UConfig_102254::MinCharacterHeightToActivate' has a wrong offset!");
static_assert(offsetof(UConfig_102254, MinAimHeightToActivate) == 0x0000A0, "Member 'UConfig_102254::MinAimHeightToActivate' has a wrong offset!");
static_assert(offsetof(UConfig_102254, MaxSmashRadius) == 0x0000A4, "Member 'UConfig_102254::MaxSmashRadius' has a wrong offset!");
static_assert(offsetof(UConfig_102254, GroundCheckAngle) == 0x0000A8, "Member 'UConfig_102254::GroundCheckAngle' has a wrong offset!");
static_assert(offsetof(UConfig_102254, SmashPermissionBuffID) == 0x0000AC, "Member 'UConfig_102254::SmashPermissionBuffID' has a wrong offset!");
static_assert(offsetof(UConfig_102254, SmashCooldownTag) == 0x0000B0, "Member 'UConfig_102254::SmashCooldownTag' has a wrong offset!");
static_assert(offsetof(UConfig_102254, TraceRate) == 0x0000BC, "Member 'UConfig_102254::TraceRate' has a wrong offset!");
static_assert(offsetof(UConfig_102254, BackTraceDistance) == 0x0000C0, "Member 'UConfig_102254::BackTraceDistance' has a wrong offset!");
static_assert(offsetof(UConfig_102254, TraceDownContext) == 0x0000D0, "Member 'UConfig_102254::TraceDownContext' has a wrong offset!");
static_assert(offsetof(UConfig_102254, TraceAimContext) == 0x001730, "Member 'UConfig_102254::TraceAimContext' has a wrong offset!");

// Class Hero_1022.Ability_102254
// 0x0060 (0x2A50 - 0x29F0)
class UAbility_102254 : public UMarvelGameplayAbility
{
public:
	uint8                                         Pad_29F0[0x60];                                    // 0x29F0(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FVector GetCurrentAimImpactPoint();
	TArray<struct FHitResult> GetTraceResults();
	void UpdateState();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_102254">();
	}
	static class UAbility_102254* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_102254>();
	}
};
static_assert(alignof(UAbility_102254) == 0x000008, "Wrong alignment on UAbility_102254");
static_assert(sizeof(UAbility_102254) == 0x002A50, "Wrong size on UAbility_102254");

// Class Hero_1022.Cue_Ability_Loop_10225401
// 0x0020 (0x11D0 - 0x11B0)
class ACue_Ability_Loop_10225401 final : public AMarvelCueNotify_Ability
{
public:
	class UDecalComponent*                        DecalComponent;                                    // 0x11B0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDistToSmooth;                                   // 0x11B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LerpMaxSpeed;                                      // 0x11BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LerpMinSpeed;                                      // 0x11C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UpdateRate;                                        // 0x11C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11C8[0x8];                                     // 0x11C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnOwnerBuffApplied(class UAbilitySystemComponent* InASC, const struct FGameplayEffectSpecStackHandle& EffectSpecHandle, const struct FActiveGameplayEffectHandle& Handle);
	void OnOwnerBuffRemove(const class UAbilitySystemComponent* ASC, const struct FActiveGameplayEffect& AGE);
	void OnViewingCharChanged(class AMarvelBaseCharacter* ViewingChar);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Ability_Loop_10225401">();
	}
	static class ACue_Ability_Loop_10225401* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Ability_Loop_10225401>();
	}
};
static_assert(alignof(ACue_Ability_Loop_10225401) == 0x000010, "Wrong alignment on ACue_Ability_Loop_10225401");
static_assert(sizeof(ACue_Ability_Loop_10225401) == 0x0011D0, "Wrong size on ACue_Ability_Loop_10225401");
static_assert(offsetof(ACue_Ability_Loop_10225401, DecalComponent) == 0x0011B0, "Member 'ACue_Ability_Loop_10225401::DecalComponent' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10225401, MaxDistToSmooth) == 0x0011B8, "Member 'ACue_Ability_Loop_10225401::MaxDistToSmooth' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10225401, LerpMaxSpeed) == 0x0011BC, "Member 'ACue_Ability_Loop_10225401::LerpMaxSpeed' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10225401, LerpMinSpeed) == 0x0011C0, "Member 'ACue_Ability_Loop_10225401::LerpMinSpeed' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10225401, UpdateRate) == 0x0011C4, "Member 'ACue_Ability_Loop_10225401::UpdateRate' has a wrong offset!");

// Class Hero_1022.Config_102255
// 0x0040 (0x00D8 - 0x0098)
class UConfig_102255 final : public UMarvelAbilityConfig
{
public:
	bool                                          bIsWaitStateChanged;                               // 0x0098(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x3];                                       // 0x0099(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FStateChangedTaskParam                 TaskParam;                                         // 0x009C(0x0028)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_C4[0x4];                                       // 0x00C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 AIAbilityID;                                       // 0x00C8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_102255">();
	}
	static class UConfig_102255* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_102255>();
	}
};
static_assert(alignof(UConfig_102255) == 0x000008, "Wrong alignment on UConfig_102255");
static_assert(sizeof(UConfig_102255) == 0x0000D8, "Wrong size on UConfig_102255");
static_assert(offsetof(UConfig_102255, bIsWaitStateChanged) == 0x000098, "Member 'UConfig_102255::bIsWaitStateChanged' has a wrong offset!");
static_assert(offsetof(UConfig_102255, TaskParam) == 0x00009C, "Member 'UConfig_102255::TaskParam' has a wrong offset!");
static_assert(offsetof(UConfig_102255, AIAbilityID) == 0x0000C8, "Member 'UConfig_102255::AIAbilityID' has a wrong offset!");

// Class Hero_1022.Ability_102255
// 0x0010 (0x2A00 - 0x29F0)
class UAbility_102255 : public UMarvelGameplayAbility
{
public:
	uint8                                         Pad_29F0[0x8];                                     // 0x29F0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UMarvelAbilityTask_WaitInputStateChanged* WaitActivationInputStateTask;                    // 0x29F8(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnActivatePress(float TimeWaited);
	void OnActivateRelease(float TimeWaited);
	void OnKey102235Press(float TimeWaited);
	void OnKey102235Release(float TimeWaited);
	void OnKeyVPress(float TimeWaited);
	void OnKeyVRelease(float TimeWaited);
	void OnMoveForwardInput(uint8 InMovementInputs, float DeltaTime);
	void SetActivatePressing(bool bIsPressing);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_102255">();
	}
	static class UAbility_102255* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_102255>();
	}
};
static_assert(alignof(UAbility_102255) == 0x000008, "Wrong alignment on UAbility_102255");
static_assert(sizeof(UAbility_102255) == 0x002A00, "Wrong size on UAbility_102255");
static_assert(offsetof(UAbility_102255, WaitActivationInputStateTask) == 0x0029F8, "Member 'UAbility_102255::WaitActivationInputStateTask' has a wrong offset!");

// Class Hero_1022.Cue_Ability_Loop_10225501
// 0x0080 (0x14E0 - 0x1460)
class ACue_Ability_Loop_10225501 final : public AMarvelCueNotify_CaptainShadow
{
public:
	uint8                                         Pad_1460[0x10];                                    // 0x1460(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  RemoveTags;                                        // 0x1470(0x0068)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         Pad_14D8[0x8];                                     // 0x14D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnTagChanged(const struct FGameplayTag& TagUpdated, bool TagExists);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Ability_Loop_10225501">();
	}
	static class ACue_Ability_Loop_10225501* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Ability_Loop_10225501>();
	}
};
static_assert(alignof(ACue_Ability_Loop_10225501) == 0x000010, "Wrong alignment on ACue_Ability_Loop_10225501");
static_assert(sizeof(ACue_Ability_Loop_10225501) == 0x0014E0, "Wrong size on ACue_Ability_Loop_10225501");
static_assert(offsetof(ACue_Ability_Loop_10225501, RemoveTags) == 0x001470, "Member 'ACue_Ability_Loop_10225501::RemoveTags' has a wrong offset!");

// Class Hero_1022.Ability_102261
// 0x0008 (0x2A00 - 0x29F8)
class UAbility_102261 : public UAbility_108
{
public:
	uint8                                         Pad_29F8[0x8];                                     // 0x29F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_102261">();
	}
	static class UAbility_102261* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_102261>();
	}
};
static_assert(alignof(UAbility_102261) == 0x000008, "Wrong alignment on UAbility_102261");
static_assert(sizeof(UAbility_102261) == 0x002A00, "Wrong size on UAbility_102261");

// Class Hero_1022.Config_102271
// 0x0028 (0x00C0 - 0x0098)
class UConfig_102271 final : public UMarvelAbilityConfig
{
public:
	float                                         ScopeDuration;                                     // 0x0098(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ArmorBuffID;                                       // 0x009C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DisposableTeammateArmorBuffValue;                  // 0x00A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DisposableSelfArmorBuffValue;                      // 0x00A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TeammateArmorBuffValue;                            // 0x00A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SelfArmorBuffValue;                                // 0x00AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ArmorTimeGap;                                      // 0x00B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TeammateSpeedBuffID;                               // 0x00B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SelfSpeedBuffID;                                   // 0x00B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_102271">();
	}
	static class UConfig_102271* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_102271>();
	}
};
static_assert(alignof(UConfig_102271) == 0x000008, "Wrong alignment on UConfig_102271");
static_assert(sizeof(UConfig_102271) == 0x0000C0, "Wrong size on UConfig_102271");
static_assert(offsetof(UConfig_102271, ScopeDuration) == 0x000098, "Member 'UConfig_102271::ScopeDuration' has a wrong offset!");
static_assert(offsetof(UConfig_102271, ArmorBuffID) == 0x00009C, "Member 'UConfig_102271::ArmorBuffID' has a wrong offset!");
static_assert(offsetof(UConfig_102271, DisposableTeammateArmorBuffValue) == 0x0000A0, "Member 'UConfig_102271::DisposableTeammateArmorBuffValue' has a wrong offset!");
static_assert(offsetof(UConfig_102271, DisposableSelfArmorBuffValue) == 0x0000A4, "Member 'UConfig_102271::DisposableSelfArmorBuffValue' has a wrong offset!");
static_assert(offsetof(UConfig_102271, TeammateArmorBuffValue) == 0x0000A8, "Member 'UConfig_102271::TeammateArmorBuffValue' has a wrong offset!");
static_assert(offsetof(UConfig_102271, SelfArmorBuffValue) == 0x0000AC, "Member 'UConfig_102271::SelfArmorBuffValue' has a wrong offset!");
static_assert(offsetof(UConfig_102271, ArmorTimeGap) == 0x0000B0, "Member 'UConfig_102271::ArmorTimeGap' has a wrong offset!");
static_assert(offsetof(UConfig_102271, TeammateSpeedBuffID) == 0x0000B4, "Member 'UConfig_102271::TeammateSpeedBuffID' has a wrong offset!");
static_assert(offsetof(UConfig_102271, SelfSpeedBuffID) == 0x0000B8, "Member 'UConfig_102271::SelfSpeedBuffID' has a wrong offset!");

// Class Hero_1022.Ability_102271
// 0x0020 (0x2A10 - 0x29F0)
class UAbility_102271 : public UMarvelGameplayAbility
{
public:
	class AScope_10227101*                        Scope;                                             // 0x29F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29F8[0x18];                                    // 0x29F8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_102271">();
	}
	static class UAbility_102271* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_102271>();
	}
};
static_assert(alignof(UAbility_102271) == 0x000008, "Wrong alignment on UAbility_102271");
static_assert(sizeof(UAbility_102271) == 0x002A10, "Wrong size on UAbility_102271");
static_assert(offsetof(UAbility_102271, Scope) == 0x0029F0, "Member 'UAbility_102271::Scope' has a wrong offset!");

// Class Hero_1022.Scope_10227101
// 0x0110 (0x1BB0 - 0x1AA0)
class AScope_10227101 final : public AMarvelAbilityTargetActor_Scope
{
public:
	TMap<class AMarvelBaseCharacter*, class UArmorAttenuation_102271*> CachedAttenuationAbility;     // 0x1AA0(0x0050)(NativeAccessSpecifierPublic)
	uint8                                         Pad_1AF0[0x8];                                     // 0x1AF0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        Path;                                              // 0x1AF8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<float>                                 PathTime;                                          // 0x1B08(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class AMarvelBaseCharacter*>           Teammates;                                         // 0x1B18(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class AMarvelBaseCharacter*>           TeammatesOnPath;                                   // 0x1B28(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class AMarvelBaseCharacter*>           TeammatesOffPath;                                  // 0x1B38(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TMap<class AMarvelBaseCharacter*, struct FTimerHandle> AddArmorTimerMap;                         // 0x1B48(0x0050)(Protected, NativeAccessSpecifierProtected)
	int32                                         MaxPathLength;                                     // 0x1B98(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DistanceBetweenPointsSquared;                      // 0x1B9C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1BA0[0x10];                                    // 0x1BA0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyArmorToTarget(class AMarvelBaseCharacter* Target);
	const TArray<struct FVector> GetQPath();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Scope_10227101">();
	}
	static class AScope_10227101* GetDefaultObj()
	{
		return GetDefaultObjImpl<AScope_10227101>();
	}
};
static_assert(alignof(AScope_10227101) == 0x000010, "Wrong alignment on AScope_10227101");
static_assert(sizeof(AScope_10227101) == 0x001BB0, "Wrong size on AScope_10227101");
static_assert(offsetof(AScope_10227101, CachedAttenuationAbility) == 0x001AA0, "Member 'AScope_10227101::CachedAttenuationAbility' has a wrong offset!");
static_assert(offsetof(AScope_10227101, Path) == 0x001AF8, "Member 'AScope_10227101::Path' has a wrong offset!");
static_assert(offsetof(AScope_10227101, PathTime) == 0x001B08, "Member 'AScope_10227101::PathTime' has a wrong offset!");
static_assert(offsetof(AScope_10227101, Teammates) == 0x001B18, "Member 'AScope_10227101::Teammates' has a wrong offset!");
static_assert(offsetof(AScope_10227101, TeammatesOnPath) == 0x001B28, "Member 'AScope_10227101::TeammatesOnPath' has a wrong offset!");
static_assert(offsetof(AScope_10227101, TeammatesOffPath) == 0x001B38, "Member 'AScope_10227101::TeammatesOffPath' has a wrong offset!");
static_assert(offsetof(AScope_10227101, AddArmorTimerMap) == 0x001B48, "Member 'AScope_10227101::AddArmorTimerMap' has a wrong offset!");
static_assert(offsetof(AScope_10227101, MaxPathLength) == 0x001B98, "Member 'AScope_10227101::MaxPathLength' has a wrong offset!");
static_assert(offsetof(AScope_10227101, DistanceBetweenPointsSquared) == 0x001B9C, "Member 'AScope_10227101::DistanceBetweenPointsSquared' has a wrong offset!");

// Class Hero_1022.Scope_10227102
// 0x0000 (0x1AA0 - 0x1AA0)
class AScope_10227102 final : public AMarvelAbilityTargetActor_Scope
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Scope_10227102">();
	}
	static class AScope_10227102* GetDefaultObj()
	{
		return GetDefaultObjImpl<AScope_10227102>();
	}
};
static_assert(alignof(AScope_10227102) == 0x000010, "Wrong alignment on AScope_10227102");
static_assert(sizeof(AScope_10227102) == 0x001AA0, "Wrong size on AScope_10227102");

// Class Hero_1022.ArmorAttenuation_102271
// 0x0000 (0x1540 - 0x1540)
class UArmorAttenuation_102271 : public UMarvelNotTreatFallAbility
{
public:
	void AddArmor(float DeltaValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArmorAttenuation_102271">();
	}
	static class UArmorAttenuation_102271* GetDefaultObj()
	{
		return GetDefaultObjImpl<UArmorAttenuation_102271>();
	}
};
static_assert(alignof(UArmorAttenuation_102271) == 0x000008, "Wrong alignment on UArmorAttenuation_102271");
static_assert(sizeof(UArmorAttenuation_102271) == 0x001540, "Wrong size on UArmorAttenuation_102271");

// Class Hero_1022.Cue_Ability_Loop_10227101
// 0x0070 (0x1220 - 0x11B0)
class ACue_Ability_Loop_10227101 final : public AMarvelCueNotify_Ability
{
public:
	uint8                                         Pad_11B0[0x18];                                    // 0x11B0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraComponent*                      CueNiagara;                                        // 0x11C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      ReleaseNiagara;                                    // 0x11D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            DisCurve;                                          // 0x11D8(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ShieldMaterialName;                                // 0x11E0(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11EC[0x4];                                     // 0x11EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            ShieldMaterialShowCurve;                           // 0x11F0(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            ShieldMaterialHideCurve;                           // 0x11F8(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SprintShieldRaiseID;                               // 0x1200(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SprintShieldReleaseID;                             // 0x1204(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SprintShieldRaiseLoopID;                           // 0x1208(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_120C[0x14];                                    // 0x120C(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnTagChanged(const struct FGameplayTag& TagUpdated, bool TagExists);
	void SetShieldMaterial(float Value);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Ability_Loop_10227101">();
	}
	static class ACue_Ability_Loop_10227101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Ability_Loop_10227101>();
	}
};
static_assert(alignof(ACue_Ability_Loop_10227101) == 0x000010, "Wrong alignment on ACue_Ability_Loop_10227101");
static_assert(sizeof(ACue_Ability_Loop_10227101) == 0x001220, "Wrong size on ACue_Ability_Loop_10227101");
static_assert(offsetof(ACue_Ability_Loop_10227101, CueNiagara) == 0x0011C8, "Member 'ACue_Ability_Loop_10227101::CueNiagara' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10227101, ReleaseNiagara) == 0x0011D0, "Member 'ACue_Ability_Loop_10227101::ReleaseNiagara' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10227101, DisCurve) == 0x0011D8, "Member 'ACue_Ability_Loop_10227101::DisCurve' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10227101, ShieldMaterialName) == 0x0011E0, "Member 'ACue_Ability_Loop_10227101::ShieldMaterialName' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10227101, ShieldMaterialShowCurve) == 0x0011F0, "Member 'ACue_Ability_Loop_10227101::ShieldMaterialShowCurve' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10227101, ShieldMaterialHideCurve) == 0x0011F8, "Member 'ACue_Ability_Loop_10227101::ShieldMaterialHideCurve' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10227101, SprintShieldRaiseID) == 0x001200, "Member 'ACue_Ability_Loop_10227101::SprintShieldRaiseID' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10227101, SprintShieldReleaseID) == 0x001204, "Member 'ACue_Ability_Loop_10227101::SprintShieldReleaseID' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10227101, SprintShieldRaiseLoopID) == 0x001208, "Member 'ACue_Ability_Loop_10227101::SprintShieldRaiseLoopID' has a wrong offset!");

// Class Hero_1022.Cue_Ability_Loop_10227102
// 0x0000 (0x1460 - 0x1460)
class ACue_Ability_Loop_10227102 final : public AMarvelCueNotify_CaptainShadow
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Ability_Loop_10227102">();
	}
	static class ACue_Ability_Loop_10227102* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Ability_Loop_10227102>();
	}
};
static_assert(alignof(ACue_Ability_Loop_10227102) == 0x000010, "Wrong alignment on ACue_Ability_Loop_10227102");
static_assert(sizeof(ACue_Ability_Loop_10227102) == 0x001460, "Wrong size on ACue_Ability_Loop_10227102");

// Class Hero_1022.CaptainAmericaAnimInstance
// 0x0050 (0x0A70 - 0x0A20)
class UCaptainAmericaAnimInstance final : public UMarvelAnimInstance
{
public:
	class FString                                 ShieldMontageName;                                 // 0x0A20(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   ShieldMontageLoopSectionName;                      // 0x0A30(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   ShieldMontageLoopRunSectionName;                   // 0x0A3C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SmoothDirSpeed;                                    // 0x0A48(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsSprint;                                         // 0x0A4C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A4D[0x3];                                      // 0x0A4D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SprintDir;                                         // 0x0A50(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsSpecialJump;                                    // 0x0A54(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsSprintAndShieldRaised;                          // 0x0A55(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUpInAir;                                          // 0x0A56(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsJumping;                                        // 0x0A57(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bFalling;                                          // 0x0A58(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bFlash;                                            // 0x0A59(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsFallingInPlace;                                 // 0x0A5A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bOnGround;                                         // 0x0A5B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSprintToGround;                                   // 0x0A5C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bBackOnGround;                                     // 0x0A5D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A5E[0x2];                                      // 0x0A5E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SynergyAOPitch_102292;                             // 0x0A60(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldUseSynergyAOParam_102292;                   // 0x0A64(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A65[0xB];                                      // 0x0A65(0x000B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CaptainAmericaAnimInstance">();
	}
	static class UCaptainAmericaAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCaptainAmericaAnimInstance>();
	}
};
static_assert(alignof(UCaptainAmericaAnimInstance) == 0x000010, "Wrong alignment on UCaptainAmericaAnimInstance");
static_assert(sizeof(UCaptainAmericaAnimInstance) == 0x000A70, "Wrong size on UCaptainAmericaAnimInstance");
static_assert(offsetof(UCaptainAmericaAnimInstance, ShieldMontageName) == 0x000A20, "Member 'UCaptainAmericaAnimInstance::ShieldMontageName' has a wrong offset!");
static_assert(offsetof(UCaptainAmericaAnimInstance, ShieldMontageLoopSectionName) == 0x000A30, "Member 'UCaptainAmericaAnimInstance::ShieldMontageLoopSectionName' has a wrong offset!");
static_assert(offsetof(UCaptainAmericaAnimInstance, ShieldMontageLoopRunSectionName) == 0x000A3C, "Member 'UCaptainAmericaAnimInstance::ShieldMontageLoopRunSectionName' has a wrong offset!");
static_assert(offsetof(UCaptainAmericaAnimInstance, SmoothDirSpeed) == 0x000A48, "Member 'UCaptainAmericaAnimInstance::SmoothDirSpeed' has a wrong offset!");
static_assert(offsetof(UCaptainAmericaAnimInstance, bIsSprint) == 0x000A4C, "Member 'UCaptainAmericaAnimInstance::bIsSprint' has a wrong offset!");
static_assert(offsetof(UCaptainAmericaAnimInstance, SprintDir) == 0x000A50, "Member 'UCaptainAmericaAnimInstance::SprintDir' has a wrong offset!");
static_assert(offsetof(UCaptainAmericaAnimInstance, bIsSpecialJump) == 0x000A54, "Member 'UCaptainAmericaAnimInstance::bIsSpecialJump' has a wrong offset!");
static_assert(offsetof(UCaptainAmericaAnimInstance, bIsSprintAndShieldRaised) == 0x000A55, "Member 'UCaptainAmericaAnimInstance::bIsSprintAndShieldRaised' has a wrong offset!");
static_assert(offsetof(UCaptainAmericaAnimInstance, bUpInAir) == 0x000A56, "Member 'UCaptainAmericaAnimInstance::bUpInAir' has a wrong offset!");
static_assert(offsetof(UCaptainAmericaAnimInstance, bIsJumping) == 0x000A57, "Member 'UCaptainAmericaAnimInstance::bIsJumping' has a wrong offset!");
static_assert(offsetof(UCaptainAmericaAnimInstance, bFalling) == 0x000A58, "Member 'UCaptainAmericaAnimInstance::bFalling' has a wrong offset!");
static_assert(offsetof(UCaptainAmericaAnimInstance, bFlash) == 0x000A59, "Member 'UCaptainAmericaAnimInstance::bFlash' has a wrong offset!");
static_assert(offsetof(UCaptainAmericaAnimInstance, bIsFallingInPlace) == 0x000A5A, "Member 'UCaptainAmericaAnimInstance::bIsFallingInPlace' has a wrong offset!");
static_assert(offsetof(UCaptainAmericaAnimInstance, bOnGround) == 0x000A5B, "Member 'UCaptainAmericaAnimInstance::bOnGround' has a wrong offset!");
static_assert(offsetof(UCaptainAmericaAnimInstance, bSprintToGround) == 0x000A5C, "Member 'UCaptainAmericaAnimInstance::bSprintToGround' has a wrong offset!");
static_assert(offsetof(UCaptainAmericaAnimInstance, bBackOnGround) == 0x000A5D, "Member 'UCaptainAmericaAnimInstance::bBackOnGround' has a wrong offset!");
static_assert(offsetof(UCaptainAmericaAnimInstance, SynergyAOPitch_102292) == 0x000A60, "Member 'UCaptainAmericaAnimInstance::SynergyAOPitch_102292' has a wrong offset!");
static_assert(offsetof(UCaptainAmericaAnimInstance, bShouldUseSynergyAOParam_102292) == 0x000A64, "Member 'UCaptainAmericaAnimInstance::bShouldUseSynergyAOParam_102292' has a wrong offset!");

// Class Hero_1022.CaptainAmericaChildActor
// 0x0050 (0x0E70 - 0x0E20)
class ACaptainAmericaChildActor final : public AMarvelCharacterChildActor
{
public:
	bool                                          bSprint;                                           // 0x0E18(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSpecialJump;                                      // 0x0E19(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNormalJump;                                       // 0x0E1A(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFlash;                                            // 0x0E1B(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ShieldSocket;                                      // 0x0E1C(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     NormalShieldMaterial;                              // 0x0E28(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     SpecialShieldMaterial;                             // 0x0E30(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 Shield;                                            // 0x0E38(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      ThunderBuffFX;                                     // 0x0E40(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      RightHandArmorFX;                                  // 0x0E48(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      ChestBackArmorFX;                                  // 0x0E50(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E58[0x18];                                     // 0x0E58(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class USkeletalMeshComponent* GetShieldMesh();
	void OnTagChanged(const struct FGameplayTag& TagUpdated, bool TagExists);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CaptainAmericaChildActor">();
	}
	static class ACaptainAmericaChildActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACaptainAmericaChildActor>();
	}
};
static_assert(alignof(ACaptainAmericaChildActor) == 0x000010, "Wrong alignment on ACaptainAmericaChildActor");
static_assert(sizeof(ACaptainAmericaChildActor) == 0x000E70, "Wrong size on ACaptainAmericaChildActor");
static_assert(offsetof(ACaptainAmericaChildActor, bSprint) == 0x000E18, "Member 'ACaptainAmericaChildActor::bSprint' has a wrong offset!");
static_assert(offsetof(ACaptainAmericaChildActor, bSpecialJump) == 0x000E19, "Member 'ACaptainAmericaChildActor::bSpecialJump' has a wrong offset!");
static_assert(offsetof(ACaptainAmericaChildActor, bNormalJump) == 0x000E1A, "Member 'ACaptainAmericaChildActor::bNormalJump' has a wrong offset!");
static_assert(offsetof(ACaptainAmericaChildActor, bFlash) == 0x000E1B, "Member 'ACaptainAmericaChildActor::bFlash' has a wrong offset!");
static_assert(offsetof(ACaptainAmericaChildActor, ShieldSocket) == 0x000E1C, "Member 'ACaptainAmericaChildActor::ShieldSocket' has a wrong offset!");
static_assert(offsetof(ACaptainAmericaChildActor, NormalShieldMaterial) == 0x000E28, "Member 'ACaptainAmericaChildActor::NormalShieldMaterial' has a wrong offset!");
static_assert(offsetof(ACaptainAmericaChildActor, SpecialShieldMaterial) == 0x000E30, "Member 'ACaptainAmericaChildActor::SpecialShieldMaterial' has a wrong offset!");
static_assert(offsetof(ACaptainAmericaChildActor, Shield) == 0x000E38, "Member 'ACaptainAmericaChildActor::Shield' has a wrong offset!");
static_assert(offsetof(ACaptainAmericaChildActor, ThunderBuffFX) == 0x000E40, "Member 'ACaptainAmericaChildActor::ThunderBuffFX' has a wrong offset!");
static_assert(offsetof(ACaptainAmericaChildActor, RightHandArmorFX) == 0x000E48, "Member 'ACaptainAmericaChildActor::RightHandArmorFX' has a wrong offset!");
static_assert(offsetof(ACaptainAmericaChildActor, ChestBackArmorFX) == 0x000E50, "Member 'ACaptainAmericaChildActor::ChestBackArmorFX' has a wrong offset!");

// Class Hero_1022.CaptainAmericaCharacter
// 0x0030 (0x21D0 - 0x21A0)
class ACaptainAmericaCharacter : public AMarvelBaseCharacter
{
public:
	class UCaptainAmericaMoveLogicBaseComponent*  CaptainAmericaMoveLogic;                           // 0x21A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsShieldActive;                                   // 0x21A8(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21A9[0x27];                                    // 0x21A9(0x0027)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ForceSetActorAndMeshRotation();
	int32 GetShareComboState();
	class USkeletalMeshComponent* GetShieldMesh();
	void ResetShareComboState();
	void SetShareComboState(int32 NewState, int32 ComboSectionNum, float ComboTimeout);
	void SetShieldActive(bool NewState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CaptainAmericaCharacter">();
	}
	static class ACaptainAmericaCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACaptainAmericaCharacter>();
	}
};
static_assert(alignof(ACaptainAmericaCharacter) == 0x000010, "Wrong alignment on ACaptainAmericaCharacter");
static_assert(sizeof(ACaptainAmericaCharacter) == 0x0021D0, "Wrong size on ACaptainAmericaCharacter");
static_assert(offsetof(ACaptainAmericaCharacter, CaptainAmericaMoveLogic) == 0x0021A0, "Member 'ACaptainAmericaCharacter::CaptainAmericaMoveLogic' has a wrong offset!");
static_assert(offsetof(ACaptainAmericaCharacter, bIsShieldActive) == 0x0021A8, "Member 'ACaptainAmericaCharacter::bIsShieldActive' has a wrong offset!");

// Class Hero_1022.CaptainAmericaMoveLogicBaseComponent
// 0x0000 (0x0400 - 0x0400)
class UCaptainAmericaMoveLogicBaseComponent final : public UMarvelMoveLogicBaseComponent
{
public:
	void ResetBackwardWalkSpeedRatio();
	void SetBackwardWalkSpeedRatio(float NewBackwardWalkSpeedRatio);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CaptainAmericaMoveLogicBaseComponent">();
	}
	static class UCaptainAmericaMoveLogicBaseComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCaptainAmericaMoveLogicBaseComponent>();
	}
};
static_assert(alignof(UCaptainAmericaMoveLogicBaseComponent) == 0x000008, "Wrong alignment on UCaptainAmericaMoveLogicBaseComponent");
static_assert(sizeof(UCaptainAmericaMoveLogicBaseComponent) == 0x000400, "Wrong size on UCaptainAmericaMoveLogicBaseComponent");

// Class Hero_1022.CaptainAmericaMovementComponent
// 0x0000 (0x2360 - 0x2360)
class UCaptainAmericaMovementComponent final : public UMarvelCharacterMovementComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CaptainAmericaMovementComponent">();
	}
	static class UCaptainAmericaMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCaptainAmericaMovementComponent>();
	}
};
static_assert(alignof(UCaptainAmericaMovementComponent) == 0x000010, "Wrong alignment on UCaptainAmericaMovementComponent");
static_assert(sizeof(UCaptainAmericaMovementComponent) == 0x002360, "Wrong size on UCaptainAmericaMovementComponent");

// Class Hero_1022.EpicMomentAction_1022
// 0x0010 (0x0130 - 0x0120)
class UEpicMomentAction_1022 : public UEpicMomentBaseAction
{
public:
	struct FEpicMomentNodeInfo                    ShieldConfig;                                      // 0x0120(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_12C[0x4];                                      // 0x012C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EpicMomentAction_1022">();
	}
	static class UEpicMomentAction_1022* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEpicMomentAction_1022>();
	}
};
static_assert(alignof(UEpicMomentAction_1022) == 0x000008, "Wrong alignment on UEpicMomentAction_1022");
static_assert(sizeof(UEpicMomentAction_1022) == 0x000130, "Wrong size on UEpicMomentAction_1022");
static_assert(offsetof(UEpicMomentAction_1022, ShieldConfig) == 0x000120, "Member 'UEpicMomentAction_1022::ShieldConfig' has a wrong offset!");

}

