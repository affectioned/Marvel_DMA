#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Hero_1028

#include "Basic.hpp"

#include "Hero_1028_structs.hpp"
#include "GameplayTags_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "Marvel_structs.hpp"
#include "Marvel_classes.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"


namespace SDK
{

// Class Hero_1028.Config_102811
// 0x00E8 (0x01E0 - 0x00F8)
class UConfig_102811 final : public UConfig_AeroBase
{
public:
	struct FGameplayTagContainer                  FlyAbilityTag;                                     // 0x00F8(0x0068)(Edit, BlueprintVisible, AdvancedDisplay, NativeAccessSpecifierPublic)
	struct FGameplayTag                           GlideAbilityTag;                                   // 0x0160(0x000C)(Edit, BlueprintVisible, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16C[0x4];                                      // 0x016C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  MoveAbilityTag;                                    // 0x0170(0x0068)(Edit, BlueprintVisible, AdvancedDisplay, NativeAccessSpecifierPublic)
	int32                                         FlyAbilityID;                                      // 0x01D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GlideAbilityID;                                    // 0x01DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_102811">();
	}
	static class UConfig_102811* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_102811>();
	}
};
static_assert(alignof(UConfig_102811) == 0x000008, "Wrong alignment on UConfig_102811");
static_assert(sizeof(UConfig_102811) == 0x0001E0, "Wrong size on UConfig_102811");
static_assert(offsetof(UConfig_102811, FlyAbilityTag) == 0x0000F8, "Member 'UConfig_102811::FlyAbilityTag' has a wrong offset!");
static_assert(offsetof(UConfig_102811, GlideAbilityTag) == 0x000160, "Member 'UConfig_102811::GlideAbilityTag' has a wrong offset!");
static_assert(offsetof(UConfig_102811, MoveAbilityTag) == 0x000170, "Member 'UConfig_102811::MoveAbilityTag' has a wrong offset!");
static_assert(offsetof(UConfig_102811, FlyAbilityID) == 0x0001D8, "Member 'UConfig_102811::FlyAbilityID' has a wrong offset!");
static_assert(offsetof(UConfig_102811, GlideAbilityID) == 0x0001DC, "Member 'UConfig_102811::GlideAbilityID' has a wrong offset!");

// Class Hero_1028.Ability_102811
// 0x0028 (0x2B38 - 0x2B10)
class UAbility_102811 : public UMarvelAeroBaseAbility
{
public:
	uint8                                         Pad_2B10[0x28];                                    // 0x2B10(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnGameTagUpdate(const struct FGameplayTag& Tag, bool TagExists);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_102811">();
	}
	static class UAbility_102811* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_102811>();
	}
};
static_assert(alignof(UAbility_102811) == 0x000008, "Wrong alignment on UAbility_102811");
static_assert(sizeof(UAbility_102811) == 0x002B38, "Wrong size on UAbility_102811");

// Class Hero_1028.Cue_Ability_Loop_10281101
// 0x00A0 (0x1250 - 0x11B0)
class ACue_Ability_Loop_10281101 final : public AMarvelCueNotify_Ability
{
public:
	class UAbility_102811*                        OwningAbility;                                     // 0x11B0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AMarvelBaseCharacter*                   OwnerCharacter;                                    // 0x11B8(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAeroState                                    LastCueState;                                      // 0x11C0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAeroState                                    CurrentCueState;                                   // 0x11C1(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11C2[0x6];                                     // 0x11C2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 LoopAudioIDs;                                      // 0x11C8(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bUpdateGroundAudio;                                // 0x11D8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11D9[0x7];                                     // 0x11D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraComponent*                      NS_DefaultRight;                                   // 0x11E0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      NS_DefaultLeft;                                    // 0x11E8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      NS_FlyingRight;                                    // 0x11F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      NS_FlyingLeft;                                     // 0x11F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      NS_GlideRight;                                     // 0x1200(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      NS_GlideLeft;                                      // 0x1208(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FlyingStartAudioID;                                // 0x1210(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FlyingLoopAudioID;                                 // 0x1214(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FlyingEndAudioID;                                  // 0x1218(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GlideStartAudioID;                                 // 0x121C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GlideLoopAudioID;                                  // 0x1220(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GlideEndAudioID;                                   // 0x1224(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DefaultLoopAudioID;                                // 0x1228(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_122C[0x24];                                    // 0x122C(0x0024)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnOwnerCharBorn102811(class AActor* TargetActor, const struct FCharacterRebornParam& Param);
	void OnOwnerCharDeath102811(class AActor* DamageCauser, class AActor* TargetActor, const struct FAttributeModifierHandle& ModifierParameterHandle);
	void PlayAudio(int32 AudioID, bool bIsLoop);
	void StopCueAudio(int32 AudioID);
	void UpdateCurrentAeroState();
	void UpdateGroundAudio();
	void UpdateOwningAbility();
	void UpdateSwitchAudio();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Ability_Loop_10281101">();
	}
	static class ACue_Ability_Loop_10281101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Ability_Loop_10281101>();
	}
};
static_assert(alignof(ACue_Ability_Loop_10281101) == 0x000010, "Wrong alignment on ACue_Ability_Loop_10281101");
static_assert(sizeof(ACue_Ability_Loop_10281101) == 0x001250, "Wrong size on ACue_Ability_Loop_10281101");
static_assert(offsetof(ACue_Ability_Loop_10281101, OwningAbility) == 0x0011B0, "Member 'ACue_Ability_Loop_10281101::OwningAbility' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10281101, OwnerCharacter) == 0x0011B8, "Member 'ACue_Ability_Loop_10281101::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10281101, LastCueState) == 0x0011C0, "Member 'ACue_Ability_Loop_10281101::LastCueState' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10281101, CurrentCueState) == 0x0011C1, "Member 'ACue_Ability_Loop_10281101::CurrentCueState' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10281101, LoopAudioIDs) == 0x0011C8, "Member 'ACue_Ability_Loop_10281101::LoopAudioIDs' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10281101, bUpdateGroundAudio) == 0x0011D8, "Member 'ACue_Ability_Loop_10281101::bUpdateGroundAudio' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10281101, NS_DefaultRight) == 0x0011E0, "Member 'ACue_Ability_Loop_10281101::NS_DefaultRight' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10281101, NS_DefaultLeft) == 0x0011E8, "Member 'ACue_Ability_Loop_10281101::NS_DefaultLeft' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10281101, NS_FlyingRight) == 0x0011F0, "Member 'ACue_Ability_Loop_10281101::NS_FlyingRight' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10281101, NS_FlyingLeft) == 0x0011F8, "Member 'ACue_Ability_Loop_10281101::NS_FlyingLeft' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10281101, NS_GlideRight) == 0x001200, "Member 'ACue_Ability_Loop_10281101::NS_GlideRight' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10281101, NS_GlideLeft) == 0x001208, "Member 'ACue_Ability_Loop_10281101::NS_GlideLeft' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10281101, FlyingStartAudioID) == 0x001210, "Member 'ACue_Ability_Loop_10281101::FlyingStartAudioID' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10281101, FlyingLoopAudioID) == 0x001214, "Member 'ACue_Ability_Loop_10281101::FlyingLoopAudioID' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10281101, FlyingEndAudioID) == 0x001218, "Member 'ACue_Ability_Loop_10281101::FlyingEndAudioID' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10281101, GlideStartAudioID) == 0x00121C, "Member 'ACue_Ability_Loop_10281101::GlideStartAudioID' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10281101, GlideLoopAudioID) == 0x001220, "Member 'ACue_Ability_Loop_10281101::GlideLoopAudioID' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10281101, GlideEndAudioID) == 0x001224, "Member 'ACue_Ability_Loop_10281101::GlideEndAudioID' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10281101, DefaultLoopAudioID) == 0x001228, "Member 'ACue_Ability_Loop_10281101::DefaultLoopAudioID' has a wrong offset!");

// Class Hero_1028.CueScopeLoop_10283101
// 0x0030 (0x2A00 - 0x29D0)
class ACueScopeLoop_10283101 : public AMarvelCueNotify_Laser
{
public:
	class FName                                   FXLevelName;                                       // 0x29C8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29D4[0x4];                                     // 0x29D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            FXLevelCurve;                                      // 0x29D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FirstHitAudioID;                                   // 0x29E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29E4[0x4];                                     // 0x29E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AMarvelBaseCharacter*                   MyOwnerCharacter;                                  // 0x29E8(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AMarvelAbilityTargetActor_Scope*        MyScope;                                           // 0x29F0(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29F8[0x8];                                     // 0x29F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CueScopeLoop_10283101">();
	}
	static class ACueScopeLoop_10283101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACueScopeLoop_10283101>();
	}
};
static_assert(alignof(ACueScopeLoop_10283101) == 0x000010, "Wrong alignment on ACueScopeLoop_10283101");
static_assert(sizeof(ACueScopeLoop_10283101) == 0x002A00, "Wrong size on ACueScopeLoop_10283101");
static_assert(offsetof(ACueScopeLoop_10283101, FXLevelName) == 0x0029C8, "Member 'ACueScopeLoop_10283101::FXLevelName' has a wrong offset!");
static_assert(offsetof(ACueScopeLoop_10283101, FXLevelCurve) == 0x0029D8, "Member 'ACueScopeLoop_10283101::FXLevelCurve' has a wrong offset!");
static_assert(offsetof(ACueScopeLoop_10283101, FirstHitAudioID) == 0x0029E0, "Member 'ACueScopeLoop_10283101::FirstHitAudioID' has a wrong offset!");
static_assert(offsetof(ACueScopeLoop_10283101, MyOwnerCharacter) == 0x0029E8, "Member 'ACueScopeLoop_10283101::MyOwnerCharacter' has a wrong offset!");
static_assert(offsetof(ACueScopeLoop_10283101, MyScope) == 0x0029F0, "Member 'ACueScopeLoop_10283101::MyScope' has a wrong offset!");

// Class Hero_1028.CueScopeLoop_10283102
// 0x0000 (0x2A00 - 0x2A00)
class ACueScopeLoop_10283102 final : public ACueScopeLoop_10283101
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CueScopeLoop_10283102">();
	}
	static class ACueScopeLoop_10283102* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACueScopeLoop_10283102>();
	}
};
static_assert(alignof(ACueScopeLoop_10283102) == 0x000010, "Wrong alignment on ACueScopeLoop_10283102");
static_assert(sizeof(ACueScopeLoop_10283102) == 0x002A00, "Wrong size on ACueScopeLoop_10283102");

// Class Hero_1028.CueProjectileLoop_10284101
// 0x0070 (0x11A0 - 0x1130)
class ACueProjectileLoop_10284101 : public AMarvelCueNotify_Projectile
{
public:
	float                                         SizeProportion;                                    // 0x1128(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   GlowSize;                                          // 0x112C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SparkSize;                                         // 0x1138(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SphereRadius;                                      // 0x1144(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GlowSizeProportion;                                // 0x1150(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SparkSizeProportion;                               // 0x1154(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SphereRadiusProportion;                            // 0x1158(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_115C[0x4];                                     // 0x115C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UFXSystemAsset*                         RefreshFX;                                         // 0x1160(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AttachBone;                                        // 0x1168(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1174[0x4];                                     // 0x1174(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveVector*                           OffsetCurve;                                       // 0x1178(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFXSystemComponent*                     OwnerFXComp;                                       // 0x1180(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ACharacter*                             HitCharacter;                                      // 0x1188(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1190[0x10];                                    // 0x1190(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnMyProjectileHit(const struct FHitResult& Hit);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CueProjectileLoop_10284101">();
	}
	static class ACueProjectileLoop_10284101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACueProjectileLoop_10284101>();
	}
};
static_assert(alignof(ACueProjectileLoop_10284101) == 0x000010, "Wrong alignment on ACueProjectileLoop_10284101");
static_assert(sizeof(ACueProjectileLoop_10284101) == 0x0011A0, "Wrong size on ACueProjectileLoop_10284101");
static_assert(offsetof(ACueProjectileLoop_10284101, SizeProportion) == 0x001128, "Member 'ACueProjectileLoop_10284101::SizeProportion' has a wrong offset!");
static_assert(offsetof(ACueProjectileLoop_10284101, GlowSize) == 0x00112C, "Member 'ACueProjectileLoop_10284101::GlowSize' has a wrong offset!");
static_assert(offsetof(ACueProjectileLoop_10284101, SparkSize) == 0x001138, "Member 'ACueProjectileLoop_10284101::SparkSize' has a wrong offset!");
static_assert(offsetof(ACueProjectileLoop_10284101, SphereRadius) == 0x001144, "Member 'ACueProjectileLoop_10284101::SphereRadius' has a wrong offset!");
static_assert(offsetof(ACueProjectileLoop_10284101, GlowSizeProportion) == 0x001150, "Member 'ACueProjectileLoop_10284101::GlowSizeProportion' has a wrong offset!");
static_assert(offsetof(ACueProjectileLoop_10284101, SparkSizeProportion) == 0x001154, "Member 'ACueProjectileLoop_10284101::SparkSizeProportion' has a wrong offset!");
static_assert(offsetof(ACueProjectileLoop_10284101, SphereRadiusProportion) == 0x001158, "Member 'ACueProjectileLoop_10284101::SphereRadiusProportion' has a wrong offset!");
static_assert(offsetof(ACueProjectileLoop_10284101, RefreshFX) == 0x001160, "Member 'ACueProjectileLoop_10284101::RefreshFX' has a wrong offset!");
static_assert(offsetof(ACueProjectileLoop_10284101, AttachBone) == 0x001168, "Member 'ACueProjectileLoop_10284101::AttachBone' has a wrong offset!");
static_assert(offsetof(ACueProjectileLoop_10284101, OffsetCurve) == 0x001178, "Member 'ACueProjectileLoop_10284101::OffsetCurve' has a wrong offset!");
static_assert(offsetof(ACueProjectileLoop_10284101, OwnerFXComp) == 0x001180, "Member 'ACueProjectileLoop_10284101::OwnerFXComp' has a wrong offset!");
static_assert(offsetof(ACueProjectileLoop_10284101, HitCharacter) == 0x001188, "Member 'ACueProjectileLoop_10284101::HitCharacter' has a wrong offset!");

// Class Hero_1028.CueAbilityLoop_10286101
// 0x0030 (0x11E0 - 0x11B0)
class ACueAbilityLoop_10286101 : public AMarvelCueNotify_Ability
{
public:
	class UCurveFloat*                            MaterialCurve;                                     // 0x11B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MaterialName;                                      // 0x11B8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11C4[0x4];                                     // 0x11C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AMarvelBaseCharacter*                   OwnerCharacter;                                    // 0x11C8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11D0[0x10];                                    // 0x11D0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CueAbilityLoop_10286101">();
	}
	static class ACueAbilityLoop_10286101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACueAbilityLoop_10286101>();
	}
};
static_assert(alignof(ACueAbilityLoop_10286101) == 0x000010, "Wrong alignment on ACueAbilityLoop_10286101");
static_assert(sizeof(ACueAbilityLoop_10286101) == 0x0011E0, "Wrong size on ACueAbilityLoop_10286101");
static_assert(offsetof(ACueAbilityLoop_10286101, MaterialCurve) == 0x0011B0, "Member 'ACueAbilityLoop_10286101::MaterialCurve' has a wrong offset!");
static_assert(offsetof(ACueAbilityLoop_10286101, MaterialName) == 0x0011B8, "Member 'ACueAbilityLoop_10286101::MaterialName' has a wrong offset!");
static_assert(offsetof(ACueAbilityLoop_10286101, OwnerCharacter) == 0x0011C8, "Member 'ACueAbilityLoop_10286101::OwnerCharacter' has a wrong offset!");

// Class Hero_1028.Config_102871
// 0x0168 (0x0200 - 0x0098)
class UConfig_102871 : public UMarvelAbilityConfig
{
public:
	struct FOcclusionParameter                    InViewOcclusionParam;                              // 0x0098(0x0148)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bUnableMaxDistance;                                // 0x01E0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E1[0x3];                                      // 0x01E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InViewMaxDistance;                                 // 0x01E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxTolerateTime;                                   // 0x01E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           InViewOcclusionTag;                                // 0x01EC(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDrawDebugTrace                               InViewOcclusionDebugTrace;                         // 0x01F8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F9[0x7];                                      // 0x01F9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_102871">();
	}
	static class UConfig_102871* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_102871>();
	}
};
static_assert(alignof(UConfig_102871) == 0x000008, "Wrong alignment on UConfig_102871");
static_assert(sizeof(UConfig_102871) == 0x000200, "Wrong size on UConfig_102871");
static_assert(offsetof(UConfig_102871, InViewOcclusionParam) == 0x000098, "Member 'UConfig_102871::InViewOcclusionParam' has a wrong offset!");
static_assert(offsetof(UConfig_102871, bUnableMaxDistance) == 0x0001E0, "Member 'UConfig_102871::bUnableMaxDistance' has a wrong offset!");
static_assert(offsetof(UConfig_102871, InViewMaxDistance) == 0x0001E4, "Member 'UConfig_102871::InViewMaxDistance' has a wrong offset!");
static_assert(offsetof(UConfig_102871, MaxTolerateTime) == 0x0001E8, "Member 'UConfig_102871::MaxTolerateTime' has a wrong offset!");
static_assert(offsetof(UConfig_102871, InViewOcclusionTag) == 0x0001EC, "Member 'UConfig_102871::InViewOcclusionTag' has a wrong offset!");
static_assert(offsetof(UConfig_102871, InViewOcclusionDebugTrace) == 0x0001F8, "Member 'UConfig_102871::InViewOcclusionDebugTrace' has a wrong offset!");

// Class Hero_1028.Ability_102872
// 0x0000 (0x29F0 - 0x29F0)
class UAbility_102872 final : public UMarvelGameplayAbility
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_102872">();
	}
	static class UAbility_102872* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_102872>();
	}
};
static_assert(alignof(UAbility_102872) == 0x000008, "Wrong alignment on UAbility_102872");
static_assert(sizeof(UAbility_102872) == 0x0029F0, "Wrong size on UAbility_102872");

// Class Hero_1028.UltronDroneSpringArmComponent
// 0x0060 (0x0500 - 0x04A0)
class UUltronDroneSpringArmComponent final : public USpringArmComponent
{
public:
	bool                                          bBindOwnerCapsuleChange;                           // 0x04A0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A1[0x7];                                      // 0x04A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                SocketOffsetRatio;                                 // 0x04A8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SocketOffsetAdd;                                   // 0x04C0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TraceRadius;                                       // 0x04D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TraceHalfHeight;                                   // 0x04DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EObjectTypeQuery>                      TraceObjectsType;                                  // 0x04E0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bIsIgnoreSelfBirthDoor;                            // 0x04F0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4F1[0xF];                                      // 0x04F1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FTransform GetSpringArmDesiredWorldTrans();
	void SetSpringArmAlive(bool bNewIsAlive);
	void SetTraceSize(float Radius, float Height);
	void UpdateSocketOffset();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UltronDroneSpringArmComponent">();
	}
	static class UUltronDroneSpringArmComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUltronDroneSpringArmComponent>();
	}
};
static_assert(alignof(UUltronDroneSpringArmComponent) == 0x000010, "Wrong alignment on UUltronDroneSpringArmComponent");
static_assert(sizeof(UUltronDroneSpringArmComponent) == 0x000500, "Wrong size on UUltronDroneSpringArmComponent");
static_assert(offsetof(UUltronDroneSpringArmComponent, bBindOwnerCapsuleChange) == 0x0004A0, "Member 'UUltronDroneSpringArmComponent::bBindOwnerCapsuleChange' has a wrong offset!");
static_assert(offsetof(UUltronDroneSpringArmComponent, SocketOffsetRatio) == 0x0004A8, "Member 'UUltronDroneSpringArmComponent::SocketOffsetRatio' has a wrong offset!");
static_assert(offsetof(UUltronDroneSpringArmComponent, SocketOffsetAdd) == 0x0004C0, "Member 'UUltronDroneSpringArmComponent::SocketOffsetAdd' has a wrong offset!");
static_assert(offsetof(UUltronDroneSpringArmComponent, TraceRadius) == 0x0004D8, "Member 'UUltronDroneSpringArmComponent::TraceRadius' has a wrong offset!");
static_assert(offsetof(UUltronDroneSpringArmComponent, TraceHalfHeight) == 0x0004DC, "Member 'UUltronDroneSpringArmComponent::TraceHalfHeight' has a wrong offset!");
static_assert(offsetof(UUltronDroneSpringArmComponent, TraceObjectsType) == 0x0004E0, "Member 'UUltronDroneSpringArmComponent::TraceObjectsType' has a wrong offset!");
static_assert(offsetof(UUltronDroneSpringArmComponent, bIsIgnoreSelfBirthDoor) == 0x0004F0, "Member 'UUltronDroneSpringArmComponent::bIsIgnoreSelfBirthDoor' has a wrong offset!");

// Class Hero_1028.Summoned_10287101
// 0x0040 (0x0B80 - 0x0B40)
class ASummoned_10287101 : public AMarvelSummonerBase
{
public:
	class UUltronDroneSpringArmComponent*         SpringArmComponent;                                // 0x0B40(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B48[0x18];                                     // 0x0B48(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 SelectedTarget;                                    // 0x0B60(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AMarvelBaseCharacter*                   SummonedInsti;                                     // 0x0B68(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UConfig_102871*                         Config;                                            // 0x0B70(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B78[0x8];                                      // 0x0B78(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class AActor* GetSelectedTarget();
	struct FTransform GetSpringArmDesiredWorldTrans();
	void OnTargetBlocked();
	void ServerUpdateSelectedTargetBinding();
	void SetSelectedTarget(class AActor* InTarget);
	void SetSpringArmCompAlive(bool bNewAlive);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Summoned_10287101">();
	}
	static class ASummoned_10287101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASummoned_10287101>();
	}
};
static_assert(alignof(ASummoned_10287101) == 0x000010, "Wrong alignment on ASummoned_10287101");
static_assert(sizeof(ASummoned_10287101) == 0x000B80, "Wrong size on ASummoned_10287101");
static_assert(offsetof(ASummoned_10287101, SpringArmComponent) == 0x000B40, "Member 'ASummoned_10287101::SpringArmComponent' has a wrong offset!");
static_assert(offsetof(ASummoned_10287101, SelectedTarget) == 0x000B60, "Member 'ASummoned_10287101::SelectedTarget' has a wrong offset!");
static_assert(offsetof(ASummoned_10287101, SummonedInsti) == 0x000B68, "Member 'ASummoned_10287101::SummonedInsti' has a wrong offset!");
static_assert(offsetof(ASummoned_10287101, Config) == 0x000B70, "Member 'ASummoned_10287101::Config' has a wrong offset!");

// Class Hero_1028.TraceComponent_10287101
// 0x0000 (0x2200 - 0x2200)
class UTraceComponent_10287101 final : public UMarvelAgentTraceComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TraceComponent_10287101">();
	}
	static class UTraceComponent_10287101* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTraceComponent_10287101>();
	}
};
static_assert(alignof(UTraceComponent_10287101) == 0x000010, "Wrong alignment on UTraceComponent_10287101");
static_assert(sizeof(UTraceComponent_10287101) == 0x002200, "Wrong size on UTraceComponent_10287101");

// Class Hero_1028.CueBaseLoop_10287101
// 0x0090 (0x12B0 - 0x1220)
class ACueBaseLoop_10287101 : public AMarvelCueNotify_Loop
{
public:
	uint8                                         Pad_1218[0x18];                                    // 0x1218(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGameplayTag>                   InVisibleForEnemyTag;                              // 0x1230(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  InVisibleForEnemyTagContainer;                     // 0x1240(0x0068)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class AActor*                                 OwnerCharacter;                                    // 0x12A8(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void BindTagDelegateOnCharacter(class AActor* InCharacter);
	void K2_OnVisibleUpdate(bool bInVisible, bool bFromEnemyView, const struct FGameplayTag& GameplayTag);
	void OnOwnedTagUpdateDispatcher(const struct FGameplayTag& Tag, bool bTagExists);
	bool OwnerCharacterVisible();
	void UpdateInVisible(const struct FGameplayTag& Tag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CueBaseLoop_10287101">();
	}
	static class ACueBaseLoop_10287101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACueBaseLoop_10287101>();
	}
};
static_assert(alignof(ACueBaseLoop_10287101) == 0x000010, "Wrong alignment on ACueBaseLoop_10287101");
static_assert(sizeof(ACueBaseLoop_10287101) == 0x0012B0, "Wrong size on ACueBaseLoop_10287101");
static_assert(offsetof(ACueBaseLoop_10287101, InVisibleForEnemyTag) == 0x001230, "Member 'ACueBaseLoop_10287101::InVisibleForEnemyTag' has a wrong offset!");
static_assert(offsetof(ACueBaseLoop_10287101, InVisibleForEnemyTagContainer) == 0x001240, "Member 'ACueBaseLoop_10287101::InVisibleForEnemyTagContainer' has a wrong offset!");
static_assert(offsetof(ACueBaseLoop_10287101, OwnerCharacter) == 0x0012A8, "Member 'ACueBaseLoop_10287101::OwnerCharacter' has a wrong offset!");

// Class Hero_1028.CueSummonerLoop_10287101
// 0x00B0 (0x1360 - 0x12B0)
class ACueSummonerLoop_10287101 : public ACueBaseLoop_10287101
{
public:
	TArray<struct FMaterialAnimConfig_102871>     MaterialAnimConfig;                                // 0x12B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FMaterialAnimConfig_102871>     EndMaterialAnimConfig;                             // 0x12C0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  KeepRotationTags;                                  // 0x12D0(0x0068)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 OwnerMesh;                                         // 0x1338(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FMaterialAnimState_102871>      PlayingMaterialAnims;                              // 0x1340(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1350[0x10];                                    // 0x1350(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class USkeletalMeshComponent* K2_GetOwnerMesh();
	void OnOwnedTagUpdate(const struct FGameplayTag& Tag, bool bTagExists);
	void PlayAnimCurve(struct FMaterialAnimConfig_102871* AnimCurve, float BeginTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CueSummonerLoop_10287101">();
	}
	static class ACueSummonerLoop_10287101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACueSummonerLoop_10287101>();
	}
};
static_assert(alignof(ACueSummonerLoop_10287101) == 0x000010, "Wrong alignment on ACueSummonerLoop_10287101");
static_assert(sizeof(ACueSummonerLoop_10287101) == 0x001360, "Wrong size on ACueSummonerLoop_10287101");
static_assert(offsetof(ACueSummonerLoop_10287101, MaterialAnimConfig) == 0x0012B0, "Member 'ACueSummonerLoop_10287101::MaterialAnimConfig' has a wrong offset!");
static_assert(offsetof(ACueSummonerLoop_10287101, EndMaterialAnimConfig) == 0x0012C0, "Member 'ACueSummonerLoop_10287101::EndMaterialAnimConfig' has a wrong offset!");
static_assert(offsetof(ACueSummonerLoop_10287101, KeepRotationTags) == 0x0012D0, "Member 'ACueSummonerLoop_10287101::KeepRotationTags' has a wrong offset!");
static_assert(offsetof(ACueSummonerLoop_10287101, OwnerMesh) == 0x001338, "Member 'ACueSummonerLoop_10287101::OwnerMesh' has a wrong offset!");
static_assert(offsetof(ACueSummonerLoop_10287101, PlayingMaterialAnims) == 0x001340, "Member 'ACueSummonerLoop_10287101::PlayingMaterialAnims' has a wrong offset!");

// Class Hero_1028.CueScopeLoop_10287101
// 0x0020 (0x12D0 - 0x12B0)
class ACueScopeLoop_10287101 final : public ACueBaseLoop_10287101
{
public:
	uint8                                         Pad_12B0[0x18];                                    // 0x12B0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class AMarvelAbilityTargetActor_Scope*        OwnerScope;                                        // 0x12C8(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CueScopeLoop_10287101">();
	}
	static class ACueScopeLoop_10287101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACueScopeLoop_10287101>();
	}
};
static_assert(alignof(ACueScopeLoop_10287101) == 0x000010, "Wrong alignment on ACueScopeLoop_10287101");
static_assert(sizeof(ACueScopeLoop_10287101) == 0x0012D0, "Wrong size on ACueScopeLoop_10287101");
static_assert(offsetof(ACueScopeLoop_10287101, OwnerScope) == 0x0012C8, "Member 'ACueScopeLoop_10287101::OwnerScope' has a wrong offset!");

// Class Hero_1028.Config_102881
// 0x0038 (0x00D0 - 0x0098)
class UConfig_102881 : public UMarvelAbilityConfig
{
public:
	int32                                         SummonerNum;                                       // 0x0098(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DelayToSpawnProjectile;                            // 0x009C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TotalNumberOfRounds;                               // 0x00A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TotalNumberOfPreRound;                             // 0x00A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SummonedDurationPerRotate;                         // 0x00A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LaunchInterval;                                    // 0x00AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        SummonedFireOffset;                                // 0x00B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bShouldAOFire;                                     // 0x00C0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C1[0x3];                                       // 0x00C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         UltronProjectileID;                                // 0x00C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SummonedProjectileID;                              // 0x00C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CC[0x4];                                       // 0x00CC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_102881">();
	}
	static class UConfig_102881* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_102881>();
	}
};
static_assert(alignof(UConfig_102881) == 0x000008, "Wrong alignment on UConfig_102881");
static_assert(sizeof(UConfig_102881) == 0x0000D0, "Wrong size on UConfig_102881");
static_assert(offsetof(UConfig_102881, SummonerNum) == 0x000098, "Member 'UConfig_102881::SummonerNum' has a wrong offset!");
static_assert(offsetof(UConfig_102881, DelayToSpawnProjectile) == 0x00009C, "Member 'UConfig_102881::DelayToSpawnProjectile' has a wrong offset!");
static_assert(offsetof(UConfig_102881, TotalNumberOfRounds) == 0x0000A0, "Member 'UConfig_102881::TotalNumberOfRounds' has a wrong offset!");
static_assert(offsetof(UConfig_102881, TotalNumberOfPreRound) == 0x0000A4, "Member 'UConfig_102881::TotalNumberOfPreRound' has a wrong offset!");
static_assert(offsetof(UConfig_102881, SummonedDurationPerRotate) == 0x0000A8, "Member 'UConfig_102881::SummonedDurationPerRotate' has a wrong offset!");
static_assert(offsetof(UConfig_102881, LaunchInterval) == 0x0000AC, "Member 'UConfig_102881::LaunchInterval' has a wrong offset!");
static_assert(offsetof(UConfig_102881, SummonedFireOffset) == 0x0000B0, "Member 'UConfig_102881::SummonedFireOffset' has a wrong offset!");
static_assert(offsetof(UConfig_102881, bShouldAOFire) == 0x0000C0, "Member 'UConfig_102881::bShouldAOFire' has a wrong offset!");
static_assert(offsetof(UConfig_102881, UltronProjectileID) == 0x0000C4, "Member 'UConfig_102881::UltronProjectileID' has a wrong offset!");
static_assert(offsetof(UConfig_102881, SummonedProjectileID) == 0x0000C8, "Member 'UConfig_102881::SummonedProjectileID' has a wrong offset!");

// Class Hero_1028.Summoned_10288101
// 0x0070 (0x0BB0 - 0x0B40)
class ASummoned_10288101 : public AMarvelSummonerBase
{
public:
	uint8                                         Pad_B40[0x8];                                      // 0x0B40(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UUltronDroneSpringArmComponent*         SpringArmComponent;                                // 0x0B48(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UUltronDroneSpringArmComponent*> ActualSpringArmComponents;                         // 0x0B50(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         TraceSphereRadius;                                 // 0x0B60(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B64[0x4];                                      // 0x0B64(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EObjectTypeQuery>                      TraceObjectsType;                                  // 0x0B68(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class USceneComponent*                        RootAxisComponent;                                 // 0x0B78(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SummonedIndex;                                     // 0x0B80(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EState_102881                                 SummonedState;                                     // 0x0B84(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B85[0x3];                                      // 0x0B85(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SummonedNum;                                       // 0x0B88(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSummonedAnimInfo_10288101             AnimInfo;                                          // 0x0B8C(0x0010)(BlueprintVisible, Net, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_B9C[0x4];                                      // 0x0B9C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              SummonedStateDelegate;                             // 0x0BA0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	class UUltronDroneSpringArmComponent* CreatNewSpringArmComponent();
	class UMarvelGameplayAbility* GetOwningAbility();
	struct FSummonedAnimInfo_10288101 GetSummonedAnimInfo();
	int32 GetSummonedIndex();
	int32 GetSummonedNum();
	EState_102881 GetSummonedState();
	void K2_OnSummonedIndexUpdate();
	void K2_OnSummonedNumUpdate();
	void OnRep_SummonedIndex();
	void OnRep_SummonedNum();
	void SetSummonedIndex(int32 Index_0);
	void SetSummonedNum(int32 Num);
	void SetSummonedState(EState_102881 NewState);

	void OnRep_SummonedState() const;
	void UpdateSummonedState() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Summoned_10288101">();
	}
	static class ASummoned_10288101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASummoned_10288101>();
	}
};
static_assert(alignof(ASummoned_10288101) == 0x000010, "Wrong alignment on ASummoned_10288101");
static_assert(sizeof(ASummoned_10288101) == 0x000BB0, "Wrong size on ASummoned_10288101");
static_assert(offsetof(ASummoned_10288101, SpringArmComponent) == 0x000B48, "Member 'ASummoned_10288101::SpringArmComponent' has a wrong offset!");
static_assert(offsetof(ASummoned_10288101, ActualSpringArmComponents) == 0x000B50, "Member 'ASummoned_10288101::ActualSpringArmComponents' has a wrong offset!");
static_assert(offsetof(ASummoned_10288101, TraceSphereRadius) == 0x000B60, "Member 'ASummoned_10288101::TraceSphereRadius' has a wrong offset!");
static_assert(offsetof(ASummoned_10288101, TraceObjectsType) == 0x000B68, "Member 'ASummoned_10288101::TraceObjectsType' has a wrong offset!");
static_assert(offsetof(ASummoned_10288101, RootAxisComponent) == 0x000B78, "Member 'ASummoned_10288101::RootAxisComponent' has a wrong offset!");
static_assert(offsetof(ASummoned_10288101, SummonedIndex) == 0x000B80, "Member 'ASummoned_10288101::SummonedIndex' has a wrong offset!");
static_assert(offsetof(ASummoned_10288101, SummonedState) == 0x000B84, "Member 'ASummoned_10288101::SummonedState' has a wrong offset!");
static_assert(offsetof(ASummoned_10288101, SummonedNum) == 0x000B88, "Member 'ASummoned_10288101::SummonedNum' has a wrong offset!");
static_assert(offsetof(ASummoned_10288101, AnimInfo) == 0x000B8C, "Member 'ASummoned_10288101::AnimInfo' has a wrong offset!");
static_assert(offsetof(ASummoned_10288101, SummonedStateDelegate) == 0x000BA0, "Member 'ASummoned_10288101::SummonedStateDelegate' has a wrong offset!");

// Class Hero_1028.Ability_102881
// 0x0040 (0x2A30 - 0x29F0)
class UAbility_102881 : public UMarvelGameplayAbility
{
public:
	int32                                         CurrentRoundsCounter;                              // 0x29F0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentProjectileCounter;                          // 0x29F4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        SummonedRootComponent;                             // 0x29F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ASummoned_10288101*>             Summoneds;                                         // 0x2A00(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class ASummoned_10288101*                     Summoned;                                          // 0x2A10(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              ShootEventDispatcher;                              // 0x2A18(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UConfig_102881*                         Config;                                            // 0x2A28(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void FireProjectiles();
	float GetPerFireRoundTime();
	void ReadyEndAbility();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_102881">();
	}
	static class UAbility_102881* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_102881>();
	}
};
static_assert(alignof(UAbility_102881) == 0x000008, "Wrong alignment on UAbility_102881");
static_assert(sizeof(UAbility_102881) == 0x002A30, "Wrong size on UAbility_102881");
static_assert(offsetof(UAbility_102881, CurrentRoundsCounter) == 0x0029F0, "Member 'UAbility_102881::CurrentRoundsCounter' has a wrong offset!");
static_assert(offsetof(UAbility_102881, CurrentProjectileCounter) == 0x0029F4, "Member 'UAbility_102881::CurrentProjectileCounter' has a wrong offset!");
static_assert(offsetof(UAbility_102881, SummonedRootComponent) == 0x0029F8, "Member 'UAbility_102881::SummonedRootComponent' has a wrong offset!");
static_assert(offsetof(UAbility_102881, Summoneds) == 0x002A00, "Member 'UAbility_102881::Summoneds' has a wrong offset!");
static_assert(offsetof(UAbility_102881, Summoned) == 0x002A10, "Member 'UAbility_102881::Summoned' has a wrong offset!");
static_assert(offsetof(UAbility_102881, ShootEventDispatcher) == 0x002A18, "Member 'UAbility_102881::ShootEventDispatcher' has a wrong offset!");
static_assert(offsetof(UAbility_102881, Config) == 0x002A28, "Member 'UAbility_102881::Config' has a wrong offset!");

// Class Hero_1028.SummonerAnimInstance_10288101
// 0x00B0 (0x0500 - 0x0450)
class USummonerAnimInstance_10288101 final : public UAnimInstance
{
public:
	TArray<class UAnimSequence*>                  SpawnAnimations;                                   // 0x0448(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class UAnimSequence*>                  AttackLoopAnimations;                              // 0x0458(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class UAimOffsetBlendSpace*>           AttackAOAnimations;                                // 0x0468(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class UBlendSpace*>                    AttackFlyBlendSpaces;                              // 0x0478(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class UAnimSequence*>                  EndAnimations;                                     // 0x0488(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UAnimSequence*                          SpawnAnim;                                         // 0x0498(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          AttackLoopAnim;                                    // 0x04A0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAimOffsetBlendSpace*                   AttackAOAnim;                                      // 0x04A8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBlendSpace*                            AttackFlyBS;                                       // 0x04B0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          EndAnim;                                           // 0x04B8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSummonedAnimInfo_10288101             AnimInfo;                                          // 0x04C0(0x0010)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FVector                                AimTarget;                                         // 0x04D0(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bLoopToEnd;                                        // 0x04E8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEndToStart;                                       // 0x04E9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsMoving;                                         // 0x04EA(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4EB[0x15];                                     // 0x04EB(0x0015)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SummonerAnimInstance_10288101">();
	}
	static class USummonerAnimInstance_10288101* GetDefaultObj()
	{
		return GetDefaultObjImpl<USummonerAnimInstance_10288101>();
	}
};
static_assert(alignof(USummonerAnimInstance_10288101) == 0x000010, "Wrong alignment on USummonerAnimInstance_10288101");
static_assert(sizeof(USummonerAnimInstance_10288101) == 0x000500, "Wrong size on USummonerAnimInstance_10288101");
static_assert(offsetof(USummonerAnimInstance_10288101, SpawnAnimations) == 0x000448, "Member 'USummonerAnimInstance_10288101::SpawnAnimations' has a wrong offset!");
static_assert(offsetof(USummonerAnimInstance_10288101, AttackLoopAnimations) == 0x000458, "Member 'USummonerAnimInstance_10288101::AttackLoopAnimations' has a wrong offset!");
static_assert(offsetof(USummonerAnimInstance_10288101, AttackAOAnimations) == 0x000468, "Member 'USummonerAnimInstance_10288101::AttackAOAnimations' has a wrong offset!");
static_assert(offsetof(USummonerAnimInstance_10288101, AttackFlyBlendSpaces) == 0x000478, "Member 'USummonerAnimInstance_10288101::AttackFlyBlendSpaces' has a wrong offset!");
static_assert(offsetof(USummonerAnimInstance_10288101, EndAnimations) == 0x000488, "Member 'USummonerAnimInstance_10288101::EndAnimations' has a wrong offset!");
static_assert(offsetof(USummonerAnimInstance_10288101, SpawnAnim) == 0x000498, "Member 'USummonerAnimInstance_10288101::SpawnAnim' has a wrong offset!");
static_assert(offsetof(USummonerAnimInstance_10288101, AttackLoopAnim) == 0x0004A0, "Member 'USummonerAnimInstance_10288101::AttackLoopAnim' has a wrong offset!");
static_assert(offsetof(USummonerAnimInstance_10288101, AttackAOAnim) == 0x0004A8, "Member 'USummonerAnimInstance_10288101::AttackAOAnim' has a wrong offset!");
static_assert(offsetof(USummonerAnimInstance_10288101, AttackFlyBS) == 0x0004B0, "Member 'USummonerAnimInstance_10288101::AttackFlyBS' has a wrong offset!");
static_assert(offsetof(USummonerAnimInstance_10288101, EndAnim) == 0x0004B8, "Member 'USummonerAnimInstance_10288101::EndAnim' has a wrong offset!");
static_assert(offsetof(USummonerAnimInstance_10288101, AnimInfo) == 0x0004C0, "Member 'USummonerAnimInstance_10288101::AnimInfo' has a wrong offset!");
static_assert(offsetof(USummonerAnimInstance_10288101, AimTarget) == 0x0004D0, "Member 'USummonerAnimInstance_10288101::AimTarget' has a wrong offset!");
static_assert(offsetof(USummonerAnimInstance_10288101, bLoopToEnd) == 0x0004E8, "Member 'USummonerAnimInstance_10288101::bLoopToEnd' has a wrong offset!");
static_assert(offsetof(USummonerAnimInstance_10288101, bEndToStart) == 0x0004E9, "Member 'USummonerAnimInstance_10288101::bEndToStart' has a wrong offset!");
static_assert(offsetof(USummonerAnimInstance_10288101, bIsMoving) == 0x0004EA, "Member 'USummonerAnimInstance_10288101::bIsMoving' has a wrong offset!");

// Class Hero_1028.CueSummonerLoop_10288101
// 0x0080 (0x1280 - 0x1200)
class ACueSummonerLoop_10288101 : public AMarvelCueNotify_Summoned
{
public:
	class USkeletalMeshComponent*                 SummonedMesh;                                      // 0x11F8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class USkeletalMeshComponent*>         ActualSummonedMeshes;                              // 0x1200(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<struct FMaterialAnimConfig_102881>     MaterialAnimConfig;                                // 0x1210(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         MaterialAnimEndTime;                               // 0x1220(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1224[0x4];                                     // 0x1224(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, struct FMaterialAnimState_102881> PlayingMaterialAnims;                              // 0x1228(0x0050)(BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         Pad_1278[0x8];                                     // 0x1278(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void JumpAnimCurve(int32 Index_0, float JumpTime);
	void PlayAnimCurve(int32 Index_0, float BeginTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CueSummonerLoop_10288101">();
	}
	static class ACueSummonerLoop_10288101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACueSummonerLoop_10288101>();
	}
};
static_assert(alignof(ACueSummonerLoop_10288101) == 0x000010, "Wrong alignment on ACueSummonerLoop_10288101");
static_assert(sizeof(ACueSummonerLoop_10288101) == 0x001280, "Wrong size on ACueSummonerLoop_10288101");
static_assert(offsetof(ACueSummonerLoop_10288101, SummonedMesh) == 0x0011F8, "Member 'ACueSummonerLoop_10288101::SummonedMesh' has a wrong offset!");
static_assert(offsetof(ACueSummonerLoop_10288101, ActualSummonedMeshes) == 0x001200, "Member 'ACueSummonerLoop_10288101::ActualSummonedMeshes' has a wrong offset!");
static_assert(offsetof(ACueSummonerLoop_10288101, MaterialAnimConfig) == 0x001210, "Member 'ACueSummonerLoop_10288101::MaterialAnimConfig' has a wrong offset!");
static_assert(offsetof(ACueSummonerLoop_10288101, MaterialAnimEndTime) == 0x001220, "Member 'ACueSummonerLoop_10288101::MaterialAnimEndTime' has a wrong offset!");
static_assert(offsetof(ACueSummonerLoop_10288101, PlayingMaterialAnims) == 0x001228, "Member 'ACueSummonerLoop_10288101::PlayingMaterialAnims' has a wrong offset!");

// Class Hero_1028.Cue_Buff_10289101
// 0x0010 (0x1650 - 0x1640)
class ACue_Buff_10289101 final : public AMarvelCueNotify_Buff
{
public:
	class FName                                   AudioRTPCName;                                     // 0x1638(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BuffDuration;                                      // 0x1644(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BuffRemainTime;                                    // 0x1648(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_164C[0x4];                                     // 0x164C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Buff_10289101">();
	}
	static class ACue_Buff_10289101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Buff_10289101>();
	}
};
static_assert(alignof(ACue_Buff_10289101) == 0x000010, "Wrong alignment on ACue_Buff_10289101");
static_assert(sizeof(ACue_Buff_10289101) == 0x001650, "Wrong size on ACue_Buff_10289101");
static_assert(offsetof(ACue_Buff_10289101, AudioRTPCName) == 0x001638, "Member 'ACue_Buff_10289101::AudioRTPCName' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10289101, BuffDuration) == 0x001644, "Member 'ACue_Buff_10289101::BuffDuration' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10289101, BuffRemainTime) == 0x001648, "Member 'ACue_Buff_10289101::BuffRemainTime' has a wrong offset!");

// Class Hero_1028.UltronAnimInstance
// 0x00A0 (0x0AC0 - 0x0A20)
class UUltronAnimInstance final : public UMarvelAnimInstance
{
public:
	struct FGameplayTagContainer                  AimIKTag;                                          // 0x0A20(0x0068)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          bEnableAimIK;                                      // 0x0A88(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A89[0x3];                                      // 0x0A89(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AimLength;                                         // 0x0A8C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsFastSpeedUpFlying;                              // 0x0A90(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsFastFlyPoseActive;                              // 0x0A91(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A92[0x2];                                      // 0x0A92(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FastSpeedUpFlyFrontAxis;                           // 0x0A94(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FastSpeedUpFlyRightAxis;                           // 0x0A98(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A9C[0x4];                                      // 0x0A9C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                AimTarget;                                         // 0x0AA0(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_AB8[0x8];                                      // 0x0AB8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UltronAnimInstance">();
	}
	static class UUltronAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUltronAnimInstance>();
	}
};
static_assert(alignof(UUltronAnimInstance) == 0x000010, "Wrong alignment on UUltronAnimInstance");
static_assert(sizeof(UUltronAnimInstance) == 0x000AC0, "Wrong size on UUltronAnimInstance");
static_assert(offsetof(UUltronAnimInstance, AimIKTag) == 0x000A20, "Member 'UUltronAnimInstance::AimIKTag' has a wrong offset!");
static_assert(offsetof(UUltronAnimInstance, bEnableAimIK) == 0x000A88, "Member 'UUltronAnimInstance::bEnableAimIK' has a wrong offset!");
static_assert(offsetof(UUltronAnimInstance, AimLength) == 0x000A8C, "Member 'UUltronAnimInstance::AimLength' has a wrong offset!");
static_assert(offsetof(UUltronAnimInstance, bIsFastSpeedUpFlying) == 0x000A90, "Member 'UUltronAnimInstance::bIsFastSpeedUpFlying' has a wrong offset!");
static_assert(offsetof(UUltronAnimInstance, bIsFastFlyPoseActive) == 0x000A91, "Member 'UUltronAnimInstance::bIsFastFlyPoseActive' has a wrong offset!");
static_assert(offsetof(UUltronAnimInstance, FastSpeedUpFlyFrontAxis) == 0x000A94, "Member 'UUltronAnimInstance::FastSpeedUpFlyFrontAxis' has a wrong offset!");
static_assert(offsetof(UUltronAnimInstance, FastSpeedUpFlyRightAxis) == 0x000A98, "Member 'UUltronAnimInstance::FastSpeedUpFlyRightAxis' has a wrong offset!");
static_assert(offsetof(UUltronAnimInstance, AimTarget) == 0x000AA0, "Member 'UUltronAnimInstance::AimTarget' has a wrong offset!");

// Class Hero_1028.UltronCharacter
// 0x0020 (0x21C0 - 0x21A0)
class AUltronCharacter : public AMarvelBaseCharacter
{
public:
	uint8                                         Pad_21A0[0x8];                                     // 0x21A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UUltronMoveLogicBaseComponent*          UltronMoveLogic;                                   // 0x21A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        SummonerRootComponent;                             // 0x21B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFastSpeedUpFlyState                          FastSpeedUpFlyState;                               // 0x21B8(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInSpecialFlying;                                  // 0x21B9(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21BA[0x6];                                     // 0x21BA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class USceneComponent* GetSummonerRootComponent();
	void SetFastSpeedUpFlyParams(EFastSpeedUpFlyState NewState, float FrontAxis, float RightAxis);
	void SetFlyingState(bool NewState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UltronCharacter">();
	}
	static class AUltronCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUltronCharacter>();
	}
};
static_assert(alignof(AUltronCharacter) == 0x000010, "Wrong alignment on AUltronCharacter");
static_assert(sizeof(AUltronCharacter) == 0x0021C0, "Wrong size on AUltronCharacter");
static_assert(offsetof(AUltronCharacter, UltronMoveLogic) == 0x0021A8, "Member 'AUltronCharacter::UltronMoveLogic' has a wrong offset!");
static_assert(offsetof(AUltronCharacter, SummonerRootComponent) == 0x0021B0, "Member 'AUltronCharacter::SummonerRootComponent' has a wrong offset!");
static_assert(offsetof(AUltronCharacter, FastSpeedUpFlyState) == 0x0021B8, "Member 'AUltronCharacter::FastSpeedUpFlyState' has a wrong offset!");
static_assert(offsetof(AUltronCharacter, bInSpecialFlying) == 0x0021B9, "Member 'AUltronCharacter::bInSpecialFlying' has a wrong offset!");

// Class Hero_1028.UltronCharacterChildActor
// 0x0010 (0x0E30 - 0x0E20)
class AUltronCharacterChildActor : public AMarvelCharacterChildActor
{
public:
	class USkeletalMeshComponent*                 Weapon_R;                                          // 0x0E18(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 Weapon_L;                                          // 0x0E20(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E28[0x8];                                      // 0x0E28(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UltronCharacterChildActor">();
	}
	static class AUltronCharacterChildActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUltronCharacterChildActor>();
	}
};
static_assert(alignof(AUltronCharacterChildActor) == 0x000010, "Wrong alignment on AUltronCharacterChildActor");
static_assert(sizeof(AUltronCharacterChildActor) == 0x000E30, "Wrong size on AUltronCharacterChildActor");
static_assert(offsetof(AUltronCharacterChildActor, Weapon_R) == 0x000E18, "Member 'AUltronCharacterChildActor::Weapon_R' has a wrong offset!");
static_assert(offsetof(AUltronCharacterChildActor, Weapon_L) == 0x000E20, "Member 'AUltronCharacterChildActor::Weapon_L' has a wrong offset!");

// Class Hero_1028.UltronMoveLogicBaseComponent
// 0x0000 (0x0400 - 0x0400)
class UUltronMoveLogicBaseComponent final : public UMarvelMoveLogicBaseComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UltronMoveLogicBaseComponent">();
	}
	static class UUltronMoveLogicBaseComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUltronMoveLogicBaseComponent>();
	}
};
static_assert(alignof(UUltronMoveLogicBaseComponent) == 0x000008, "Wrong alignment on UUltronMoveLogicBaseComponent");
static_assert(sizeof(UUltronMoveLogicBaseComponent) == 0x000400, "Wrong size on UUltronMoveLogicBaseComponent");

// Class Hero_1028.UltronMovementComponent
// 0x0000 (0x2360 - 0x2360)
class UUltronMovementComponent final : public UMarvelCharacterMovementComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UltronMovementComponent">();
	}
	static class UUltronMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUltronMovementComponent>();
	}
};
static_assert(alignof(UUltronMovementComponent) == 0x000010, "Wrong alignment on UUltronMovementComponent");
static_assert(sizeof(UUltronMovementComponent) == 0x002360, "Wrong size on UUltronMovementComponent");

}

