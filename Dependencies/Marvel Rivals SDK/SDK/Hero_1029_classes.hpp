#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Hero_1029

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "Marvel_structs.hpp"
#include "Marvel_classes.hpp"
#include "GameplayTags_structs.hpp"
#include "Hero_1029_structs.hpp"
#include "Engine_structs.hpp"
#include "GameplayAbilities_structs.hpp"


namespace SDK
{

// Class Hero_1029.Projectile_10292101
// 0x0000 (0x3B90 - 0x3B90)
class AProjectile_10292101 : public AMarvelAbilityTargetActor_Projectile
{
public:
	float GetAccumulateTime();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Projectile_10292101">();
	}
	static class AProjectile_10292101* GetDefaultObj()
	{
		return GetDefaultObjImpl<AProjectile_10292101>();
	}
};
static_assert(alignof(AProjectile_10292101) == 0x000010, "Wrong alignment on AProjectile_10292101");
static_assert(sizeof(AProjectile_10292101) == 0x003B90, "Wrong size on AProjectile_10292101");

// Class Hero_1029.Cue_Ability_Loop_102921_Common
// 0x0050 (0x1200 - 0x11B0)
class ACue_Ability_Loop_102921_Common : public AMarvelCueNotify_Ability
{
public:
	class AMarvelBaseCharacter*                   OwnerChar;                                         // 0x11B0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFXSystemComponent*                     FxComp;                                            // 0x11B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFXSystemAsset*                         FxAsset;                                           // 0x11C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                FxScale;                                           // 0x11C8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FxLocSocketName;                                   // 0x11E0(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OffsetLength;                                      // 0x11EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZOffset;                                           // 0x11F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLookAtAimDir;                                     // 0x11F4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11F5[0xB];                                     // 0x11F5(0x000B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CalculateFxLocRot(struct FVector* OutLoc, struct FRotator* OutRot);
	void UpdateFx();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Ability_Loop_102921_Common">();
	}
	static class ACue_Ability_Loop_102921_Common* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Ability_Loop_102921_Common>();
	}
};
static_assert(alignof(ACue_Ability_Loop_102921_Common) == 0x000010, "Wrong alignment on ACue_Ability_Loop_102921_Common");
static_assert(sizeof(ACue_Ability_Loop_102921_Common) == 0x001200, "Wrong size on ACue_Ability_Loop_102921_Common");
static_assert(offsetof(ACue_Ability_Loop_102921_Common, OwnerChar) == 0x0011B0, "Member 'ACue_Ability_Loop_102921_Common::OwnerChar' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_102921_Common, FxComp) == 0x0011B8, "Member 'ACue_Ability_Loop_102921_Common::FxComp' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_102921_Common, FxAsset) == 0x0011C0, "Member 'ACue_Ability_Loop_102921_Common::FxAsset' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_102921_Common, FxScale) == 0x0011C8, "Member 'ACue_Ability_Loop_102921_Common::FxScale' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_102921_Common, FxLocSocketName) == 0x0011E0, "Member 'ACue_Ability_Loop_102921_Common::FxLocSocketName' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_102921_Common, OffsetLength) == 0x0011EC, "Member 'ACue_Ability_Loop_102921_Common::OffsetLength' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_102921_Common, ZOffset) == 0x0011F0, "Member 'ACue_Ability_Loop_102921_Common::ZOffset' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_102921_Common, bLookAtAimDir) == 0x0011F4, "Member 'ACue_Ability_Loop_102921_Common::bLookAtAimDir' has a wrong offset!");

// Class Hero_1029.Cue_Ability_Loop_10292102
// 0x0000 (0x1200 - 0x1200)
class ACue_Ability_Loop_10292102 final : public ACue_Ability_Loop_102921_Common
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Ability_Loop_10292102">();
	}
	static class ACue_Ability_Loop_10292102* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Ability_Loop_10292102>();
	}
};
static_assert(alignof(ACue_Ability_Loop_10292102) == 0x000010, "Wrong alignment on ACue_Ability_Loop_10292102");
static_assert(sizeof(ACue_Ability_Loop_10292102) == 0x001200, "Wrong size on ACue_Ability_Loop_10292102");

// Class Hero_1029.Cue_Projectile_HitImpact_10292101
// 0x0010 (0x05D8 - 0x05C8)
class UCue_Projectile_HitImpact_10292101 final : public UMarvelCueNotify_HitImpact
{
public:
	class UCurveVector*                           HitImpactFXSizeCurve;                              // 0x05C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            HitImpactDecalSizeCurve;                           // 0x05D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void OnHitNiagaraSpawned(class UNiagaraComponent* SpawnedNiagara, class AActor* MyTarget, const struct FGameplayCueParameters& Parameters) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Projectile_HitImpact_10292101">();
	}
	static class UCue_Projectile_HitImpact_10292101* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCue_Projectile_HitImpact_10292101>();
	}
};
static_assert(alignof(UCue_Projectile_HitImpact_10292101) == 0x000008, "Wrong alignment on UCue_Projectile_HitImpact_10292101");
static_assert(sizeof(UCue_Projectile_HitImpact_10292101) == 0x0005D8, "Wrong size on UCue_Projectile_HitImpact_10292101");
static_assert(offsetof(UCue_Projectile_HitImpact_10292101, HitImpactFXSizeCurve) == 0x0005C8, "Member 'UCue_Projectile_HitImpact_10292101::HitImpactFXSizeCurve' has a wrong offset!");
static_assert(offsetof(UCue_Projectile_HitImpact_10292101, HitImpactDecalSizeCurve) == 0x0005D0, "Member 'UCue_Projectile_HitImpact_10292101::HitImpactDecalSizeCurve' has a wrong offset!");

// Class Hero_1029.UIController_102921
// 0x0010 (0x0F20 - 0x0F10)
class UUIController_102921 : public UUIC_Ability
{
public:
	float                                         ReticleMinRadius;                                  // 0x0F10(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReticleMaxRadius;                                  // 0x0F14(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDuration;                                       // 0x0F18(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F1C[0x4];                                      // 0x0F1C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void UpdateReticle(float Radius);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIController_102921">();
	}
	static class UUIController_102921* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIController_102921>();
	}
};
static_assert(alignof(UUIController_102921) == 0x000008, "Wrong alignment on UUIController_102921");
static_assert(sizeof(UUIController_102921) == 0x000F20, "Wrong size on UUIController_102921");
static_assert(offsetof(UUIController_102921, ReticleMinRadius) == 0x000F10, "Member 'UUIController_102921::ReticleMinRadius' has a wrong offset!");
static_assert(offsetof(UUIController_102921, ReticleMaxRadius) == 0x000F14, "Member 'UUIController_102921::ReticleMaxRadius' has a wrong offset!");
static_assert(offsetof(UUIController_102921, MaxDuration) == 0x000F18, "Member 'UUIController_102921::MaxDuration' has a wrong offset!");

// Class Hero_1029.Summoned_10294101
// 0x00D0 (0x0C10 - 0x0B40)
class ASummoned_10294101 final : public AMarvelSummonerBase
{
public:
	uint8                                         Pad_B40[0x14];                                     // 0x0B40(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TPCD;                                              // 0x0B54(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TPAbilityBuff;                                     // 0x0B58(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B5C[0x4];                                      // 0x0B5C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 TPBuffs;                                           // 0x0B60(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         UpdateInterval;                                    // 0x0B70(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           TargetEnterTag;                                    // 0x0B74(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           TargetLeaveTag;                                    // 0x0B80(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B8C[0x4];                                      // 0x0B8C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(bool Value)>    OnTargetThroughTP;                                 // 0x0B90(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	struct FVector                                FaceDir;                                           // 0x0BA0(0x0018)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ASummoned_10294101*                     TargetTP;                                          // 0x0BB8(0x0008)(Edit, BlueprintVisible, Net, ZeroConstructor, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTPUsageRecord_102941>          TPUsageRecords;                                    // 0x0BC0(0x0010)(BlueprintVisible, Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              NeedRefreshTP;                                     // 0x0BD0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UOverlapHandlerComponent*               OverlapHandlerComponent;                           // 0x0BE0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USphereComponent*                       OverlapCollisionComponent;                         // 0x0BE8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTimerHandle                           UpdateTimer;                                       // 0x0BF0(0x0018)(HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C08[0x8];                                      // 0x0C08(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearUpdateTimer();
	void HandleTargetTPBuff(class AActor* TargetActor, bool bApply);
	bool IsTargetCanBeTP(class AActor* TargetActor);
	void OnASCTagUpdate(const struct FGameplayTag& TagUpdate, bool bTagExist);
	void OnRep_FaceDir();
	void OnRep_TargetTP();
	void OnRep_TPUsageRecords();
	void SetTargetTP(class ASummoned_10294101* InTargetTP);
	void SetTPFaceDir(const struct FVector& InDir);
	void SetUpdateTimer();
	void TryTeleportTarget(class AActor* TargetActor);
	void UpdateTPState(class AActor* TargetActor, bool bStartTP);
	void UpdateUsageRecord(class AActor* TargetActor);

	class ASummoned_10294101* GetTargetTP() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Summoned_10294101">();
	}
	static class ASummoned_10294101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASummoned_10294101>();
	}
};
static_assert(alignof(ASummoned_10294101) == 0x000010, "Wrong alignment on ASummoned_10294101");
static_assert(sizeof(ASummoned_10294101) == 0x000C10, "Wrong size on ASummoned_10294101");
static_assert(offsetof(ASummoned_10294101, TPCD) == 0x000B54, "Member 'ASummoned_10294101::TPCD' has a wrong offset!");
static_assert(offsetof(ASummoned_10294101, TPAbilityBuff) == 0x000B58, "Member 'ASummoned_10294101::TPAbilityBuff' has a wrong offset!");
static_assert(offsetof(ASummoned_10294101, TPBuffs) == 0x000B60, "Member 'ASummoned_10294101::TPBuffs' has a wrong offset!");
static_assert(offsetof(ASummoned_10294101, UpdateInterval) == 0x000B70, "Member 'ASummoned_10294101::UpdateInterval' has a wrong offset!");
static_assert(offsetof(ASummoned_10294101, TargetEnterTag) == 0x000B74, "Member 'ASummoned_10294101::TargetEnterTag' has a wrong offset!");
static_assert(offsetof(ASummoned_10294101, TargetLeaveTag) == 0x000B80, "Member 'ASummoned_10294101::TargetLeaveTag' has a wrong offset!");
static_assert(offsetof(ASummoned_10294101, OnTargetThroughTP) == 0x000B90, "Member 'ASummoned_10294101::OnTargetThroughTP' has a wrong offset!");
static_assert(offsetof(ASummoned_10294101, FaceDir) == 0x000BA0, "Member 'ASummoned_10294101::FaceDir' has a wrong offset!");
static_assert(offsetof(ASummoned_10294101, TargetTP) == 0x000BB8, "Member 'ASummoned_10294101::TargetTP' has a wrong offset!");
static_assert(offsetof(ASummoned_10294101, TPUsageRecords) == 0x000BC0, "Member 'ASummoned_10294101::TPUsageRecords' has a wrong offset!");
static_assert(offsetof(ASummoned_10294101, NeedRefreshTP) == 0x000BD0, "Member 'ASummoned_10294101::NeedRefreshTP' has a wrong offset!");
static_assert(offsetof(ASummoned_10294101, OverlapHandlerComponent) == 0x000BE0, "Member 'ASummoned_10294101::OverlapHandlerComponent' has a wrong offset!");
static_assert(offsetof(ASummoned_10294101, OverlapCollisionComponent) == 0x000BE8, "Member 'ASummoned_10294101::OverlapCollisionComponent' has a wrong offset!");
static_assert(offsetof(ASummoned_10294101, UpdateTimer) == 0x000BF0, "Member 'ASummoned_10294101::UpdateTimer' has a wrong offset!");

// Class Hero_1029.SummonedOverlapComp_10294101
// 0x0008 (0x0D70 - 0x0D68)
class USummonedOverlapComp_10294101 final : public UOverlapHandlerComponent
{
public:
	class ASummoned_10294101*                     OwnerSummoned_10294101;                            // 0x0D68(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	class ASummoned_10294101* GetOwnerSummoned_10294101();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SummonedOverlapComp_10294101">();
	}
	static class USummonedOverlapComp_10294101* GetDefaultObj()
	{
		return GetDefaultObjImpl<USummonedOverlapComp_10294101>();
	}
};
static_assert(alignof(USummonedOverlapComp_10294101) == 0x000008, "Wrong alignment on USummonedOverlapComp_10294101");
static_assert(sizeof(USummonedOverlapComp_10294101) == 0x000D70, "Wrong size on USummonedOverlapComp_10294101");
static_assert(offsetof(USummonedOverlapComp_10294101, OwnerSummoned_10294101) == 0x000D68, "Member 'USummonedOverlapComp_10294101::OwnerSummoned_10294101' has a wrong offset!");

// Class Hero_1029.Cue_Ability_Instant_10294101
// 0x0070 (0x0430 - 0x03C0)
class UCue_Ability_Instant_10294101 : public UMarvelCueNotify_Base
{
public:
	struct FVector                                FXDir;                                             // 0x03C0(0x0018)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OwningAbilityID;                                   // 0x03D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3DC[0x4];                                      // 0x03DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraSystem*                         PortalNiagara;                                     // 0x03E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFXSystemAsset*                         EndTrailFx;                                        // 0x03E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEndTrailFxIsAttach;                               // 0x03F0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3F1[0x7];                                      // 0x03F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               EndTrailRelativeRot;                               // 0x03F8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                EndTrailRelativeLoc;                               // 0x0410(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDrawDebug;                                        // 0x0428(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_429[0x3];                                      // 0x0429(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DebugDrawTime;                                     // 0x042C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void CustomDebugDraw(const struct FRotator& Dir, const struct FVector& Start) const;
	void CustomSpawnFX(class UFXSystemAsset* InFXAsset, bool bIsAttach, class USkeletalMeshComponent* Mesh, class FName Socket, const struct FGameplayCueParameters& Parameters, const struct FVector& Loc, const struct FRotator& Rot, const struct FVector& RelativeLoc, const struct FRotator& RelativeRot) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Ability_Instant_10294101">();
	}
	static class UCue_Ability_Instant_10294101* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCue_Ability_Instant_10294101>();
	}
};
static_assert(alignof(UCue_Ability_Instant_10294101) == 0x000008, "Wrong alignment on UCue_Ability_Instant_10294101");
static_assert(sizeof(UCue_Ability_Instant_10294101) == 0x000430, "Wrong size on UCue_Ability_Instant_10294101");
static_assert(offsetof(UCue_Ability_Instant_10294101, FXDir) == 0x0003C0, "Member 'UCue_Ability_Instant_10294101::FXDir' has a wrong offset!");
static_assert(offsetof(UCue_Ability_Instant_10294101, OwningAbilityID) == 0x0003D8, "Member 'UCue_Ability_Instant_10294101::OwningAbilityID' has a wrong offset!");
static_assert(offsetof(UCue_Ability_Instant_10294101, PortalNiagara) == 0x0003E0, "Member 'UCue_Ability_Instant_10294101::PortalNiagara' has a wrong offset!");
static_assert(offsetof(UCue_Ability_Instant_10294101, EndTrailFx) == 0x0003E8, "Member 'UCue_Ability_Instant_10294101::EndTrailFx' has a wrong offset!");
static_assert(offsetof(UCue_Ability_Instant_10294101, bEndTrailFxIsAttach) == 0x0003F0, "Member 'UCue_Ability_Instant_10294101::bEndTrailFxIsAttach' has a wrong offset!");
static_assert(offsetof(UCue_Ability_Instant_10294101, EndTrailRelativeRot) == 0x0003F8, "Member 'UCue_Ability_Instant_10294101::EndTrailRelativeRot' has a wrong offset!");
static_assert(offsetof(UCue_Ability_Instant_10294101, EndTrailRelativeLoc) == 0x000410, "Member 'UCue_Ability_Instant_10294101::EndTrailRelativeLoc' has a wrong offset!");
static_assert(offsetof(UCue_Ability_Instant_10294101, bDrawDebug) == 0x000428, "Member 'UCue_Ability_Instant_10294101::bDrawDebug' has a wrong offset!");
static_assert(offsetof(UCue_Ability_Instant_10294101, DebugDrawTime) == 0x00042C, "Member 'UCue_Ability_Instant_10294101::DebugDrawTime' has a wrong offset!");

// Class Hero_1029.Cue_Ability_Loop_10294102
// 0x0410 (0x15C0 - 0x11B0)
class ACue_Ability_Loop_10294102 final : public AMarvelCueNotify_Ability
{
public:
	float                                         CueLifeSpan;                                       // 0x11B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxMaterialLastTime;                               // 0x11B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseCommonCurve;                                   // 0x11B8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11B9[0x7];                                     // 0x11B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<int32>                                   CommonMaterialSlots;                               // 0x11C0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<struct FMaterialQuery>                 CommonMaterialSlotsQuery;                          // 0x1210(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FMaterialCurve_102941                  CommonMaterialMap;                                 // 0x1220(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<struct FMaterialQuery, struct FMaterialCurve_102941> MaterialMapQuery;                      // 0x1270(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<int32, struct FMaterialCurve_102941>     MaterialMap;                                       // 0x12C0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         DefaultValCurveTime;                               // 0x1310(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1314[0x4];                                     // 0x1314(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, float>                            BackFresnelPowerDefaultVals;                       // 0x1318(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<struct FMaterialQuery, float>            BackFresnelPowerDefaultValsQuery;                  // 0x1368(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<int32, struct FLinearColor>              BackRimDefaultColors;                              // 0x13B8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<struct FMaterialQuery, struct FLinearColor> BackRimDefaultColorsQuery;                      // 0x1408(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<int32, struct FVector>                   RimLightDirectionDefaultVecs;                      // 0x1458(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<struct FMaterialQuery, struct FVector>   RimLightDirectionDefaultVecsQuery;                 // 0x14A8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         ChargeTime;                                        // 0x14F8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_14FC[0x4];                                     // 0x14FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 TargetMesh;                                        // 0x1500(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<int32, class UMaterialInstanceDynamic*>  CachedMaterialInstances;                           // 0x1508(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	TMap<struct FMaterialQuery, class UMaterialInstanceDynamic*> CachedMaterialInstancesQuery;       // 0x1558(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FTimerHandle                           DelayRecycleCueHandle;                             // 0x15A8(0x0018)(Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void HandleSlotMaterial(float CurveTime, bool bIsReset);
	bool IsMaterialHasCached(int32 SlotIdx);
	bool IsMaterialHasCachedByQuery(const struct FMaterialQuery& InQuery);
	void ResetMaterial();
	void SetMaterialParamInternal(class UCurveBase* CurveBase, float CurveTime, class UMaterialInstanceDynamic* Material, class FName Param, int32 SlotIdx, bool bIsReset);
	void SetMaterialParamInternalByQuery(class UCurveBase* CurveBase, float CurveTime, class UMaterialInstanceDynamic* Material, class FName Param, const struct FMaterialQuery& InQuery, bool bIsReset);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Ability_Loop_10294102">();
	}
	static class ACue_Ability_Loop_10294102* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Ability_Loop_10294102>();
	}
};
static_assert(alignof(ACue_Ability_Loop_10294102) == 0x000010, "Wrong alignment on ACue_Ability_Loop_10294102");
static_assert(sizeof(ACue_Ability_Loop_10294102) == 0x0015C0, "Wrong size on ACue_Ability_Loop_10294102");
static_assert(offsetof(ACue_Ability_Loop_10294102, CueLifeSpan) == 0x0011B0, "Member 'ACue_Ability_Loop_10294102::CueLifeSpan' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10294102, MaxMaterialLastTime) == 0x0011B4, "Member 'ACue_Ability_Loop_10294102::MaxMaterialLastTime' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10294102, bUseCommonCurve) == 0x0011B8, "Member 'ACue_Ability_Loop_10294102::bUseCommonCurve' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10294102, CommonMaterialSlots) == 0x0011C0, "Member 'ACue_Ability_Loop_10294102::CommonMaterialSlots' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10294102, CommonMaterialSlotsQuery) == 0x001210, "Member 'ACue_Ability_Loop_10294102::CommonMaterialSlotsQuery' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10294102, CommonMaterialMap) == 0x001220, "Member 'ACue_Ability_Loop_10294102::CommonMaterialMap' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10294102, MaterialMapQuery) == 0x001270, "Member 'ACue_Ability_Loop_10294102::MaterialMapQuery' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10294102, MaterialMap) == 0x0012C0, "Member 'ACue_Ability_Loop_10294102::MaterialMap' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10294102, DefaultValCurveTime) == 0x001310, "Member 'ACue_Ability_Loop_10294102::DefaultValCurveTime' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10294102, BackFresnelPowerDefaultVals) == 0x001318, "Member 'ACue_Ability_Loop_10294102::BackFresnelPowerDefaultVals' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10294102, BackFresnelPowerDefaultValsQuery) == 0x001368, "Member 'ACue_Ability_Loop_10294102::BackFresnelPowerDefaultValsQuery' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10294102, BackRimDefaultColors) == 0x0013B8, "Member 'ACue_Ability_Loop_10294102::BackRimDefaultColors' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10294102, BackRimDefaultColorsQuery) == 0x001408, "Member 'ACue_Ability_Loop_10294102::BackRimDefaultColorsQuery' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10294102, RimLightDirectionDefaultVecs) == 0x001458, "Member 'ACue_Ability_Loop_10294102::RimLightDirectionDefaultVecs' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10294102, RimLightDirectionDefaultVecsQuery) == 0x0014A8, "Member 'ACue_Ability_Loop_10294102::RimLightDirectionDefaultVecsQuery' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10294102, ChargeTime) == 0x0014F8, "Member 'ACue_Ability_Loop_10294102::ChargeTime' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10294102, TargetMesh) == 0x001500, "Member 'ACue_Ability_Loop_10294102::TargetMesh' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10294102, CachedMaterialInstances) == 0x001508, "Member 'ACue_Ability_Loop_10294102::CachedMaterialInstances' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10294102, CachedMaterialInstancesQuery) == 0x001558, "Member 'ACue_Ability_Loop_10294102::CachedMaterialInstancesQuery' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10294102, DelayRecycleCueHandle) == 0x0015A8, "Member 'ACue_Ability_Loop_10294102::DelayRecycleCueHandle' has a wrong offset!");

// Class Hero_1029.Summoned_102961
// 0x0000 (0x0B40 - 0x0B40)
class ASummoned_102961 : public AMarvelSummonerBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Summoned_102961">();
	}
	static class ASummoned_102961* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASummoned_102961>();
	}
};
static_assert(alignof(ASummoned_102961) == 0x000010, "Wrong alignment on ASummoned_102961");
static_assert(sizeof(ASummoned_102961) == 0x000B40, "Wrong size on ASummoned_102961");

// Class Hero_1029.Config_102972
// 0x0010 (0x00A8 - 0x0098)
class UConfig_102972 final : public UMarvelAbilityConfig
{
public:
	TSubclassOf<class UMarvelKnockUpAbility>      KnockUpAbility;                                    // 0x0098(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNeedMagikLaunch;                                  // 0x00A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_102972">();
	}
	static class UConfig_102972* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_102972>();
	}
};
static_assert(alignof(UConfig_102972) == 0x000008, "Wrong alignment on UConfig_102972");
static_assert(sizeof(UConfig_102972) == 0x0000A8, "Wrong size on UConfig_102972");
static_assert(offsetof(UConfig_102972, KnockUpAbility) == 0x000098, "Member 'UConfig_102972::KnockUpAbility' has a wrong offset!");
static_assert(offsetof(UConfig_102972, bNeedMagikLaunch) == 0x0000A0, "Member 'UConfig_102972::bNeedMagikLaunch' has a wrong offset!");

// Class Hero_1029.Ability_102972
// 0x0028 (0x2A20 - 0x29F8)
class UAbility_102972 : public UAbility_108
{
public:
	TArray<class AActor*>                         TargetActors;                                      // 0x29F8(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FTimerHandle                           TimerHandle;                                       // 0x2A08(0x0018)(HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void SetTarget(class AActor* OutTarget);
	void SetTargets(const TArray<class AActor*>& OutTarget);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_102972">();
	}
	static class UAbility_102972* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_102972>();
	}
};
static_assert(alignof(UAbility_102972) == 0x000008, "Wrong alignment on UAbility_102972");
static_assert(sizeof(UAbility_102972) == 0x002A20, "Wrong size on UAbility_102972");
static_assert(offsetof(UAbility_102972, TargetActors) == 0x0029F8, "Member 'UAbility_102972::TargetActors' has a wrong offset!");
static_assert(offsetof(UAbility_102972, TimerHandle) == 0x002A08, "Member 'UAbility_102972::TimerHandle' has a wrong offset!");

// Class Hero_1029.TraceComponent_10297201
// 0x0000 (0x2200 - 0x2200)
class UTraceComponent_10297201 : public UMarvelAgentTraceComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TraceComponent_10297201">();
	}
	static class UTraceComponent_10297201* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTraceComponent_10297201>();
	}
};
static_assert(alignof(UTraceComponent_10297201) == 0x000010, "Wrong alignment on UTraceComponent_10297201");
static_assert(sizeof(UTraceComponent_10297201) == 0x002200, "Wrong size on UTraceComponent_10297201");

// Class Hero_1029.TraceComponent_10297401
// 0x0000 (0x2200 - 0x2200)
class UTraceComponent_10297401 final : public UTraceComponent_10297201
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TraceComponent_10297401">();
	}
	static class UTraceComponent_10297401* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTraceComponent_10297401>();
	}
};
static_assert(alignof(UTraceComponent_10297401) == 0x000010, "Wrong alignment on UTraceComponent_10297401");
static_assert(sizeof(UTraceComponent_10297401) == 0x002200, "Wrong size on UTraceComponent_10297401");

// Class Hero_1029.Config_102996
// 0x00A8 (0x0140 - 0x0098)
class UConfig_102996 : public UMarvelAbilityConfig
{
public:
	int32                                         StopMoveBuffID;                                    // 0x0098(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SpeedDownBuffID;                                   // 0x009C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SourceLinkBuffID;                                  // 0x00A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TargetLinkBuffID;                                  // 0x00A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 OtherBuffIDs;                                      // 0x00A8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         MaxSpeedDownDistance;                              // 0x00B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DelayCheckDistanceTime;                            // 0x00BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCheckSceneBlock;                                  // 0x00C0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C1[0x3];                                       // 0x00C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CheckSceneInterval;                                // 0x00C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            SpeedDownCurve;                                    // 0x00C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UpdateAttributeInterval;                           // 0x00D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D4[0x4];                                       // 0x00D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  CancelEffectTags;                                  // 0x00D8(0x0068)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_102996">();
	}
	static class UConfig_102996* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_102996>();
	}
};
static_assert(alignof(UConfig_102996) == 0x000008, "Wrong alignment on UConfig_102996");
static_assert(sizeof(UConfig_102996) == 0x000140, "Wrong size on UConfig_102996");
static_assert(offsetof(UConfig_102996, StopMoveBuffID) == 0x000098, "Member 'UConfig_102996::StopMoveBuffID' has a wrong offset!");
static_assert(offsetof(UConfig_102996, SpeedDownBuffID) == 0x00009C, "Member 'UConfig_102996::SpeedDownBuffID' has a wrong offset!");
static_assert(offsetof(UConfig_102996, SourceLinkBuffID) == 0x0000A0, "Member 'UConfig_102996::SourceLinkBuffID' has a wrong offset!");
static_assert(offsetof(UConfig_102996, TargetLinkBuffID) == 0x0000A4, "Member 'UConfig_102996::TargetLinkBuffID' has a wrong offset!");
static_assert(offsetof(UConfig_102996, OtherBuffIDs) == 0x0000A8, "Member 'UConfig_102996::OtherBuffIDs' has a wrong offset!");
static_assert(offsetof(UConfig_102996, MaxSpeedDownDistance) == 0x0000B8, "Member 'UConfig_102996::MaxSpeedDownDistance' has a wrong offset!");
static_assert(offsetof(UConfig_102996, DelayCheckDistanceTime) == 0x0000BC, "Member 'UConfig_102996::DelayCheckDistanceTime' has a wrong offset!");
static_assert(offsetof(UConfig_102996, bCheckSceneBlock) == 0x0000C0, "Member 'UConfig_102996::bCheckSceneBlock' has a wrong offset!");
static_assert(offsetof(UConfig_102996, CheckSceneInterval) == 0x0000C4, "Member 'UConfig_102996::CheckSceneInterval' has a wrong offset!");
static_assert(offsetof(UConfig_102996, SpeedDownCurve) == 0x0000C8, "Member 'UConfig_102996::SpeedDownCurve' has a wrong offset!");
static_assert(offsetof(UConfig_102996, UpdateAttributeInterval) == 0x0000D0, "Member 'UConfig_102996::UpdateAttributeInterval' has a wrong offset!");
static_assert(offsetof(UConfig_102996, CancelEffectTags) == 0x0000D8, "Member 'UConfig_102996::CancelEffectTags' has a wrong offset!");

// Class Hero_1029.BuffAbility_10299603
// 0x0098 (0x1408 - 0x1370)
class UBuffAbility_10299603 : public UMarvelEffectGameplayAbility
{
public:
	class UConfig_102996*                         AbilityConfig;                                     // 0x1370(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AMarvelBaseCharacter*                   InstigatorCharacter;                               // 0x1378(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMarvelBaseAbilitySystemComponent*      EffectCauserASC;                                   // 0x1380(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAttribute                     SpeedAttribute;                                    // 0x1388(0x0040)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13C8[0x40];                                    // 0x13C8(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnEffectTagUpdate(const struct FGameplayTag& TagUpdated, bool TagExists);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuffAbility_10299603">();
	}
	static class UBuffAbility_10299603* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBuffAbility_10299603>();
	}
};
static_assert(alignof(UBuffAbility_10299603) == 0x000008, "Wrong alignment on UBuffAbility_10299603");
static_assert(sizeof(UBuffAbility_10299603) == 0x001408, "Wrong size on UBuffAbility_10299603");
static_assert(offsetof(UBuffAbility_10299603, AbilityConfig) == 0x001370, "Member 'UBuffAbility_10299603::AbilityConfig' has a wrong offset!");
static_assert(offsetof(UBuffAbility_10299603, InstigatorCharacter) == 0x001378, "Member 'UBuffAbility_10299603::InstigatorCharacter' has a wrong offset!");
static_assert(offsetof(UBuffAbility_10299603, EffectCauserASC) == 0x001380, "Member 'UBuffAbility_10299603::EffectCauserASC' has a wrong offset!");
static_assert(offsetof(UBuffAbility_10299603, SpeedAttribute) == 0x001388, "Member 'UBuffAbility_10299603::SpeedAttribute' has a wrong offset!");

// Class Hero_1029.Cue_Buff_102996_Base
// 0x00A0 (0x16E0 - 0x1640)
class ACue_Buff_102996_Base final : public AMarvelCueNotify_Buff
{
public:
	struct FGameplayTagContainer                  ForceRecycleTags;                                  // 0x1638(0x0068)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class UMarvelBaseAbilitySystemComponent*      SourceASC;                                         // 0x16A0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMarvelBaseAbilitySystemComponent*      TargetASC;                                         // 0x16A8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16B0[0x30];                                    // 0x16B0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnLivingStateChanged(EPlayerLivingState LivingState);
	void OnTagUpdate(const struct FGameplayTag& TagUpdated, bool TagExists);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Buff_102996_Base">();
	}
	static class ACue_Buff_102996_Base* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Buff_102996_Base>();
	}
};
static_assert(alignof(ACue_Buff_102996_Base) == 0x000010, "Wrong alignment on ACue_Buff_102996_Base");
static_assert(sizeof(ACue_Buff_102996_Base) == 0x0016E0, "Wrong size on ACue_Buff_102996_Base");
static_assert(offsetof(ACue_Buff_102996_Base, ForceRecycleTags) == 0x001638, "Member 'ACue_Buff_102996_Base::ForceRecycleTags' has a wrong offset!");
static_assert(offsetof(ACue_Buff_102996_Base, SourceASC) == 0x0016A0, "Member 'ACue_Buff_102996_Base::SourceASC' has a wrong offset!");
static_assert(offsetof(ACue_Buff_102996_Base, TargetASC) == 0x0016A8, "Member 'ACue_Buff_102996_Base::TargetASC' has a wrong offset!");

// Class Hero_1029.MagikAnimInstance
// 0x00B0 (0x0AD0 - 0x0A20)
class UMagikAnimInstance final : public UMarvelAnimInstance
{
public:
	struct FGameplayTag                           DashingTag;                                        // 0x0A20(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           TPPlaceingTag;                                     // 0x0A2C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           AssaultTag;                                        // 0x0A38(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           SwirlSlashTag;                                     // 0x0A44(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           DarkchyldeSwirlSlashTag;                           // 0x0A50(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           ForceSwirlSlashTag;                                // 0x0A5C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HellTeleLoopAnimTime;                              // 0x0A68(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsInDash;                                         // 0x0A6C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPendingMove;                                      // 0x0A6D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsTPPlacing;                                      // 0x0A6E(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A6F[0x1];                                      // 0x0A6F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HellTeleportFrontAxis;                             // 0x0A70(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HellTeleportRightAxis;                             // 0x0A74(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          AssaultState;                                      // 0x0A78(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          SwirlSlashState;                                   // 0x0A79(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bForceSwirlSlash;                                  // 0x0A7A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A7B[0x1];                                      // 0x0A7B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SwirlSlashPlayRate;                                // 0x0A7C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAssaultRecovery_To_GroundMotion;                  // 0x0A80(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bGroundMotion_To_SwirlSlash;                       // 0x0A81(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSwirlSlashRecovery_To_GroundMotion;               // 0x0A82(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHellTeleportLoop_To_HellTeleportEnd;              // 0x0A83(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A84[0x4C];                                     // 0x0A84(0x004C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MagikAnimInstance">();
	}
	static class UMagikAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMagikAnimInstance>();
	}
};
static_assert(alignof(UMagikAnimInstance) == 0x000010, "Wrong alignment on UMagikAnimInstance");
static_assert(sizeof(UMagikAnimInstance) == 0x000AD0, "Wrong size on UMagikAnimInstance");
static_assert(offsetof(UMagikAnimInstance, DashingTag) == 0x000A20, "Member 'UMagikAnimInstance::DashingTag' has a wrong offset!");
static_assert(offsetof(UMagikAnimInstance, TPPlaceingTag) == 0x000A2C, "Member 'UMagikAnimInstance::TPPlaceingTag' has a wrong offset!");
static_assert(offsetof(UMagikAnimInstance, AssaultTag) == 0x000A38, "Member 'UMagikAnimInstance::AssaultTag' has a wrong offset!");
static_assert(offsetof(UMagikAnimInstance, SwirlSlashTag) == 0x000A44, "Member 'UMagikAnimInstance::SwirlSlashTag' has a wrong offset!");
static_assert(offsetof(UMagikAnimInstance, DarkchyldeSwirlSlashTag) == 0x000A50, "Member 'UMagikAnimInstance::DarkchyldeSwirlSlashTag' has a wrong offset!");
static_assert(offsetof(UMagikAnimInstance, ForceSwirlSlashTag) == 0x000A5C, "Member 'UMagikAnimInstance::ForceSwirlSlashTag' has a wrong offset!");
static_assert(offsetof(UMagikAnimInstance, HellTeleLoopAnimTime) == 0x000A68, "Member 'UMagikAnimInstance::HellTeleLoopAnimTime' has a wrong offset!");
static_assert(offsetof(UMagikAnimInstance, bIsInDash) == 0x000A6C, "Member 'UMagikAnimInstance::bIsInDash' has a wrong offset!");
static_assert(offsetof(UMagikAnimInstance, bPendingMove) == 0x000A6D, "Member 'UMagikAnimInstance::bPendingMove' has a wrong offset!");
static_assert(offsetof(UMagikAnimInstance, bIsTPPlacing) == 0x000A6E, "Member 'UMagikAnimInstance::bIsTPPlacing' has a wrong offset!");
static_assert(offsetof(UMagikAnimInstance, HellTeleportFrontAxis) == 0x000A70, "Member 'UMagikAnimInstance::HellTeleportFrontAxis' has a wrong offset!");
static_assert(offsetof(UMagikAnimInstance, HellTeleportRightAxis) == 0x000A74, "Member 'UMagikAnimInstance::HellTeleportRightAxis' has a wrong offset!");
static_assert(offsetof(UMagikAnimInstance, AssaultState) == 0x000A78, "Member 'UMagikAnimInstance::AssaultState' has a wrong offset!");
static_assert(offsetof(UMagikAnimInstance, SwirlSlashState) == 0x000A79, "Member 'UMagikAnimInstance::SwirlSlashState' has a wrong offset!");
static_assert(offsetof(UMagikAnimInstance, bForceSwirlSlash) == 0x000A7A, "Member 'UMagikAnimInstance::bForceSwirlSlash' has a wrong offset!");
static_assert(offsetof(UMagikAnimInstance, SwirlSlashPlayRate) == 0x000A7C, "Member 'UMagikAnimInstance::SwirlSlashPlayRate' has a wrong offset!");
static_assert(offsetof(UMagikAnimInstance, bAssaultRecovery_To_GroundMotion) == 0x000A80, "Member 'UMagikAnimInstance::bAssaultRecovery_To_GroundMotion' has a wrong offset!");
static_assert(offsetof(UMagikAnimInstance, bGroundMotion_To_SwirlSlash) == 0x000A81, "Member 'UMagikAnimInstance::bGroundMotion_To_SwirlSlash' has a wrong offset!");
static_assert(offsetof(UMagikAnimInstance, bSwirlSlashRecovery_To_GroundMotion) == 0x000A82, "Member 'UMagikAnimInstance::bSwirlSlashRecovery_To_GroundMotion' has a wrong offset!");
static_assert(offsetof(UMagikAnimInstance, bHellTeleportLoop_To_HellTeleportEnd) == 0x000A83, "Member 'UMagikAnimInstance::bHellTeleportLoop_To_HellTeleportEnd' has a wrong offset!");

// Class Hero_1029.MagikAbilitySystemComponent
// 0x0000 (0x72D0 - 0x72D0)
class UMagikAbilitySystemComponent final : public UMarvelAbilitySystemCom
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MagikAbilitySystemComponent">();
	}
	static class UMagikAbilitySystemComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMagikAbilitySystemComponent>();
	}
};
static_assert(alignof(UMagikAbilitySystemComponent) == 0x000010, "Wrong alignment on UMagikAbilitySystemComponent");
static_assert(sizeof(UMagikAbilitySystemComponent) == 0x0072D0, "Wrong size on UMagikAbilitySystemComponent");

// Class Hero_1029.MagikCharacter
// 0x0010 (0x21B0 - 0x21A0)
class AMagikCharacter : public AMarvelBaseCharacter
{
public:
	class UMagikMoveLogicBaseComponent*           MagikMoveLogic;                                    // 0x21A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_21A8[0x8];                                     // 0x21A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsNormalState() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MagikCharacter">();
	}
	static class AMagikCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMagikCharacter>();
	}
};
static_assert(alignof(AMagikCharacter) == 0x000010, "Wrong alignment on AMagikCharacter");
static_assert(sizeof(AMagikCharacter) == 0x0021B0, "Wrong size on AMagikCharacter");
static_assert(offsetof(AMagikCharacter, MagikMoveLogic) == 0x0021A0, "Member 'AMagikCharacter::MagikMoveLogic' has a wrong offset!");

// Class Hero_1029.MagikMoveLogicBaseComponent
// 0x0000 (0x0400 - 0x0400)
class UMagikMoveLogicBaseComponent final : public UMarvelMoveLogicBaseComponent
{
public:
	void InterruptTurningPlaceMontage();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MagikMoveLogicBaseComponent">();
	}
	static class UMagikMoveLogicBaseComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMagikMoveLogicBaseComponent>();
	}
};
static_assert(alignof(UMagikMoveLogicBaseComponent) == 0x000008, "Wrong alignment on UMagikMoveLogicBaseComponent");
static_assert(sizeof(UMagikMoveLogicBaseComponent) == 0x000400, "Wrong size on UMagikMoveLogicBaseComponent");

// Class Hero_1029.MagikMovementComponent
// 0x0000 (0x2360 - 0x2360)
class UMagikMovementComponent final : public UMarvelCharacterMovementComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MagikMovementComponent">();
	}
	static class UMagikMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMagikMovementComponent>();
	}
};
static_assert(alignof(UMagikMovementComponent) == 0x000010, "Wrong alignment on UMagikMovementComponent");
static_assert(sizeof(UMagikMovementComponent) == 0x002360, "Wrong size on UMagikMovementComponent");

// Class Hero_1029.TabData_1029
// 0x0000 (0x0050 - 0x0050)
class UTabData_1029 : public UHeroTabDataBase
{
public:
	void OnActorDeath(class AActor* Killer, class AActor* Target, const struct FAttributeModifierHandle& ModifierParameterHandle, const struct FGlobalEventExtraData& ExtraData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TabData_1029">();
	}
	static class UTabData_1029* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTabData_1029>();
	}
};
static_assert(alignof(UTabData_1029) == 0x000008, "Wrong alignment on UTabData_1029");
static_assert(sizeof(UTabData_1029) == 0x000050, "Wrong size on UTabData_1029");

}

