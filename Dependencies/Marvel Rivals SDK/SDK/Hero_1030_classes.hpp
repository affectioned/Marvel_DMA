#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Hero_1030

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "Marvel_structs.hpp"
#include "Marvel_classes.hpp"
#include "GameplayTags_structs.hpp"
#include "Engine_structs.hpp"
#include "AnimGraphRuntime_structs.hpp"
#include "Hero_1026_structs.hpp"


namespace SDK
{

// Class Hero_1030.Config_103021
// 0x1710 (0x1830 - 0x0120)
#pragma pack(push, 0x1)
class alignas(0x10) UConfig_103021 : public UConfig_106
{
public:
	int32                                         TargetBuffID;                                      // 0x0120(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AnkaSummonerID;                                    // 0x0124(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EnhancedAnkaSummonedID;                            // 0x0128(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12C[0x4];                                      // 0x012C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FProjectileBounceInfo                  BounceInfo;                                        // 0x0130(0x16E0)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         AbsorbRadius;                                      // 0x1810(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1814[0x4];                                     // 0x1814(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 BattleLogName;                                     // 0x1818(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_103021">();
	}
	static class UConfig_103021* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_103021>();
	}
};
#pragma pack(pop)
static_assert(alignof(UConfig_103021) == 0x000010, "Wrong alignment on UConfig_103021");
static_assert(sizeof(UConfig_103021) == 0x001830, "Wrong size on UConfig_103021");
static_assert(offsetof(UConfig_103021, TargetBuffID) == 0x000120, "Member 'UConfig_103021::TargetBuffID' has a wrong offset!");
static_assert(offsetof(UConfig_103021, AnkaSummonerID) == 0x000124, "Member 'UConfig_103021::AnkaSummonerID' has a wrong offset!");
static_assert(offsetof(UConfig_103021, EnhancedAnkaSummonedID) == 0x000128, "Member 'UConfig_103021::EnhancedAnkaSummonedID' has a wrong offset!");
static_assert(offsetof(UConfig_103021, BounceInfo) == 0x000130, "Member 'UConfig_103021::BounceInfo' has a wrong offset!");
static_assert(offsetof(UConfig_103021, AbsorbRadius) == 0x001810, "Member 'UConfig_103021::AbsorbRadius' has a wrong offset!");
static_assert(offsetof(UConfig_103021, BattleLogName) == 0x001818, "Member 'UConfig_103021::BattleLogName' has a wrong offset!");

// Class Hero_1030.Projectile_10302101_Common
// 0x0050 (0x53B0 - 0x5360)
#pragma pack(push, 0x1)
class alignas(0x10) AProjectile_10302101_Common : public AMarvelBounceProjectile
{
public:
	class AMarvelBaseCharacter*                   OwnerCharacter;                                    // 0x5358(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UConfig_103021*                         AbilityConfig;                                     // 0x5360(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5368[0x4];                                     // 0x5368(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AActor>                  LastTarget;                                        // 0x536C(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5374[0x4];                                     // 0x5374(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USphereComponent*                       AbsorbedMovingComponent;                           // 0x5378(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5380[0x18];                                    // 0x5380(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 PendingAbsorbedAnka;                               // 0x5398(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_53A0[0x8];                                     // 0x53A0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnOwnerApplyDamage(class AActor* InSourceAvatar, class AActor* InTargetAvatar, const struct FAttributeModifierHandle& ModifierParameterHandle);
	void RemoteProjectileBounce(const struct FHitResult& ImpactResult, const struct FVector& ImpactVelocity);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Projectile_10302101_Common">();
	}
	static class AProjectile_10302101_Common* GetDefaultObj()
	{
		return GetDefaultObjImpl<AProjectile_10302101_Common>();
	}
};
#pragma pack(pop)
static_assert(alignof(AProjectile_10302101_Common) == 0x000010, "Wrong alignment on AProjectile_10302101_Common");
static_assert(sizeof(AProjectile_10302101_Common) == 0x0053B0, "Wrong size on AProjectile_10302101_Common");
static_assert(offsetof(AProjectile_10302101_Common, OwnerCharacter) == 0x005358, "Member 'AProjectile_10302101_Common::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(AProjectile_10302101_Common, AbilityConfig) == 0x005360, "Member 'AProjectile_10302101_Common::AbilityConfig' has a wrong offset!");
static_assert(offsetof(AProjectile_10302101_Common, LastTarget) == 0x00536C, "Member 'AProjectile_10302101_Common::LastTarget' has a wrong offset!");
static_assert(offsetof(AProjectile_10302101_Common, AbsorbedMovingComponent) == 0x005378, "Member 'AProjectile_10302101_Common::AbsorbedMovingComponent' has a wrong offset!");
static_assert(offsetof(AProjectile_10302101_Common, PendingAbsorbedAnka) == 0x005398, "Member 'AProjectile_10302101_Common::PendingAbsorbedAnka' has a wrong offset!");

// Class Hero_1030.Projectile_10302101
// 0x0000 (0x53B0 - 0x53B0)
class AProjectile_10302101 : public AProjectile_10302101_Common
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Projectile_10302101">();
	}
	static class AProjectile_10302101* GetDefaultObj()
	{
		return GetDefaultObjImpl<AProjectile_10302101>();
	}
};
static_assert(alignof(AProjectile_10302101) == 0x000010, "Wrong alignment on AProjectile_10302101");
static_assert(sizeof(AProjectile_10302101) == 0x0053B0, "Wrong size on AProjectile_10302101");

// Class Hero_1030.ConductProjectileMovement
// 0x0010 (0x2A50 - 0x2A40)
class UConductProjectileMovement final : public UMarvelProjectileComponent
{
public:
	float                                         DeltaRadius;                                       // 0x2A40(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSyncTargetPoint;                                  // 0x2A44(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A45[0xB];                                     // 0x2A45(0x000B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ConductProjectileMovement">();
	}
	static class UConductProjectileMovement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConductProjectileMovement>();
	}
};
static_assert(alignof(UConductProjectileMovement) == 0x000010, "Wrong alignment on UConductProjectileMovement");
static_assert(sizeof(UConductProjectileMovement) == 0x002A50, "Wrong size on UConductProjectileMovement");
static_assert(offsetof(UConductProjectileMovement, DeltaRadius) == 0x002A40, "Member 'UConductProjectileMovement::DeltaRadius' has a wrong offset!");
static_assert(offsetof(UConductProjectileMovement, bSyncTargetPoint) == 0x002A44, "Member 'UConductProjectileMovement::bSyncTargetPoint' has a wrong offset!");

// Class Hero_1030.VirtualProjectileActor_10302301_Common
// 0x0020 (0x5410 - 0x53F0)
class AVirtualProjectileActor_10302301_Common : public AVirtualProjectileActor_Bounce
{
public:
	class AMarvelBaseCharacter*                   OwnerCharacter;                                    // 0x53E8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UConfig_103021*                         AbilityConfig;                                     // 0x53F0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_53F8[0x4];                                     // 0x53F8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AActor>                  LastTarget;                                        // 0x53FC(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5404[0xC];                                     // 0x5404(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnOwnerApplyDamage(class AActor* InSourceAvatar, class AActor* InTargetAvatar, const struct FAttributeModifierHandle& ModifierParameterHandle);
	void RemoteProjectileBounce(const struct FHitResult& ImpactResult, const struct FVector& ImpactVelocity);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VirtualProjectileActor_10302301_Common">();
	}
	static class AVirtualProjectileActor_10302301_Common* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVirtualProjectileActor_10302301_Common>();
	}
};
static_assert(alignof(AVirtualProjectileActor_10302301_Common) == 0x000010, "Wrong alignment on AVirtualProjectileActor_10302301_Common");
static_assert(sizeof(AVirtualProjectileActor_10302301_Common) == 0x005410, "Wrong size on AVirtualProjectileActor_10302301_Common");
static_assert(offsetof(AVirtualProjectileActor_10302301_Common, OwnerCharacter) == 0x0053E8, "Member 'AVirtualProjectileActor_10302301_Common::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(AVirtualProjectileActor_10302301_Common, AbilityConfig) == 0x0053F0, "Member 'AVirtualProjectileActor_10302301_Common::AbilityConfig' has a wrong offset!");
static_assert(offsetof(AVirtualProjectileActor_10302301_Common, LastTarget) == 0x0053FC, "Member 'AVirtualProjectileActor_10302301_Common::LastTarget' has a wrong offset!");

// Class Hero_1030.VirtualProjectileBounceMovement_103023
// 0x0000 (0x2A60 - 0x2A60)
class UVirtualProjectileBounceMovement_103023 final : public UMarvelVirtualProjectileComponent
{
public:
	float                                         DeltaRadius;                                       // 0x2A58(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A5C[0x4];                                     // 0x2A5C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VirtualProjectileBounceMovement_103023">();
	}
	static class UVirtualProjectileBounceMovement_103023* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVirtualProjectileBounceMovement_103023>();
	}
};
static_assert(alignof(UVirtualProjectileBounceMovement_103023) == 0x000010, "Wrong alignment on UVirtualProjectileBounceMovement_103023");
static_assert(sizeof(UVirtualProjectileBounceMovement_103023) == 0x002A60, "Wrong size on UVirtualProjectileBounceMovement_103023");
static_assert(offsetof(UVirtualProjectileBounceMovement_103023, DeltaRadius) == 0x002A58, "Member 'UVirtualProjectileBounceMovement_103023::DeltaRadius' has a wrong offset!");

// Class Hero_1030.Projectile_10302301
// 0x0000 (0x5410 - 0x5410)
class AProjectile_10302301 : public AVirtualProjectileActor_10302301_Common
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Projectile_10302301">();
	}
	static class AProjectile_10302301* GetDefaultObj()
	{
		return GetDefaultObjImpl<AProjectile_10302301>();
	}
};
static_assert(alignof(AProjectile_10302301) == 0x000010, "Wrong alignment on AProjectile_10302301");
static_assert(sizeof(AProjectile_10302301) == 0x005410, "Wrong size on AProjectile_10302301");

// Class Hero_1030.Ability_103023
// 0x0010 (0x2AE8 - 0x2AD8)
class UAbility_103023 : public UAbility_106
{
public:
	struct FGameplayTag                           CueTag;                                            // 0x2AD8(0x000C)(Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2AE4[0x4];                                     // 0x2AE4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_103023">();
	}
	static class UAbility_103023* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_103023>();
	}
};
static_assert(alignof(UAbility_103023) == 0x000008, "Wrong alignment on UAbility_103023");
static_assert(sizeof(UAbility_103023) == 0x002AE8, "Wrong size on UAbility_103023");
static_assert(offsetof(UAbility_103023, CueTag) == 0x002AD8, "Member 'UAbility_103023::CueTag' has a wrong offset!");

// Class Hero_1030.Cue_Ability_Loop_10302301
// 0x0050 (0x1200 - 0x11B0)
class ACue_Ability_Loop_10302301 final : public AMarvelCueNotify_Ability
{
public:
	class UNiagaraSystem*                         SystemTemplate;                                    // 0x11B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UNiagaraComponent*>              LoopNXs;                                           // 0x11B8(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, ContainsInstancedReference, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<int32>                                 ActiveLoopNXIndexs;                                // 0x11C8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	TArray<struct FMarvelVirtualProjectileFlowHandle> ActiveFlowHandles;                             // 0x11D8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	TArray<struct FMarvelVirtualProjectileFlowHandle> TickUpdateFlowHandles;                         // 0x11E8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	class UVirtualProjectileWorldSubsystem*       VirtualProjectileWorldSubsystem;                   // 0x11F8(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void ReceiveAddNewFlowDelegateCallback(const struct FMarvelVirtualProjectileFlowHandle& FlowHandle);
	void ReceiveTickFlowUpdateDelegateCallback(const TArray<struct FMarvelVirtualProjectileFlowHandle>& FlowHandles);
	void ReceivRemoveFlowDelegateCallback(const struct FMarvelVirtualProjectileFlowHandle& FlowHandle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Ability_Loop_10302301">();
	}
	static class ACue_Ability_Loop_10302301* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Ability_Loop_10302301>();
	}
};
static_assert(alignof(ACue_Ability_Loop_10302301) == 0x000010, "Wrong alignment on ACue_Ability_Loop_10302301");
static_assert(sizeof(ACue_Ability_Loop_10302301) == 0x001200, "Wrong size on ACue_Ability_Loop_10302301");
static_assert(offsetof(ACue_Ability_Loop_10302301, SystemTemplate) == 0x0011B0, "Member 'ACue_Ability_Loop_10302301::SystemTemplate' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10302301, LoopNXs) == 0x0011B8, "Member 'ACue_Ability_Loop_10302301::LoopNXs' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10302301, ActiveLoopNXIndexs) == 0x0011C8, "Member 'ACue_Ability_Loop_10302301::ActiveLoopNXIndexs' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10302301, ActiveFlowHandles) == 0x0011D8, "Member 'ACue_Ability_Loop_10302301::ActiveFlowHandles' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10302301, TickUpdateFlowHandles) == 0x0011E8, "Member 'ACue_Ability_Loop_10302301::TickUpdateFlowHandles' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10302301, VirtualProjectileWorldSubsystem) == 0x0011F8, "Member 'ACue_Ability_Loop_10302301::VirtualProjectileWorldSubsystem' has a wrong offset!");

// Class Hero_1030.Cue_Projectile_Bounce_10302301
// 0x0008 (0x05D0 - 0x05C8)
class UCue_Projectile_Bounce_10302301 final : public UMarvelCueNotify_HitImpact
{
public:
	int32                                         HitNormalAudioID;                                  // 0x05C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HitAnkaAudioID;                                    // 0x05CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Projectile_Bounce_10302301">();
	}
	static class UCue_Projectile_Bounce_10302301* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCue_Projectile_Bounce_10302301>();
	}
};
static_assert(alignof(UCue_Projectile_Bounce_10302301) == 0x000008, "Wrong alignment on UCue_Projectile_Bounce_10302301");
static_assert(sizeof(UCue_Projectile_Bounce_10302301) == 0x0005D0, "Wrong size on UCue_Projectile_Bounce_10302301");
static_assert(offsetof(UCue_Projectile_Bounce_10302301, HitNormalAudioID) == 0x0005C8, "Member 'UCue_Projectile_Bounce_10302301::HitNormalAudioID' has a wrong offset!");
static_assert(offsetof(UCue_Projectile_Bounce_10302301, HitAnkaAudioID) == 0x0005CC, "Member 'UCue_Projectile_Bounce_10302301::HitAnkaAudioID' has a wrong offset!");

// Class Hero_1030.Config_103031
// 0x0000 (0x1830 - 0x1830)
class UConfig_103031 : public UConfig_103021
{
public:
	int32                                         ArmorBuffID;                                       // 0x1828(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_182C[0x4];                                     // 0x182C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_103031">();
	}
	static class UConfig_103031* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_103031>();
	}
};
static_assert(alignof(UConfig_103031) == 0x000010, "Wrong alignment on UConfig_103031");
static_assert(sizeof(UConfig_103031) == 0x001830, "Wrong size on UConfig_103031");
static_assert(offsetof(UConfig_103031, ArmorBuffID) == 0x001828, "Member 'UConfig_103031::ArmorBuffID' has a wrong offset!");

// Class Hero_1030.Ability_103031
// 0x0000 (0x29F0 - 0x29F0)
class UAbility_103031 final : public UMarvelGameplayAbility
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_103031">();
	}
	static class UAbility_103031* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_103031>();
	}
};
static_assert(alignof(UAbility_103031) == 0x000008, "Wrong alignment on UAbility_103031");
static_assert(sizeof(UAbility_103031) == 0x0029F0, "Wrong size on UAbility_103031");

// Class Hero_1030.Projectile_10303101
// 0x0000 (0x53B0 - 0x53B0)
class AProjectile_10303101 : public AProjectile_10302101_Common
{
public:
	class UConfig_103031*                         Config_103031;                                     // 0x53A8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Projectile_10303101">();
	}
	static class AProjectile_10303101* GetDefaultObj()
	{
		return GetDefaultObjImpl<AProjectile_10303101>();
	}
};
static_assert(alignof(AProjectile_10303101) == 0x000010, "Wrong alignment on AProjectile_10303101");
static_assert(sizeof(AProjectile_10303101) == 0x0053B0, "Wrong size on AProjectile_10303101");
static_assert(offsetof(AProjectile_10303101, Config_103031) == 0x0053A8, "Member 'AProjectile_10303101::Config_103031' has a wrong offset!");

// Class Hero_1030.NotTreatFallAbility_10303101
// 0x0008 (0x1548 - 0x1540)
class UNotTreatFallAbility_10303101 final : public UMarvelNotTreatFallAbility
{
public:
	float                                         AmorValue;                                         // 0x1540(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1544[0x4];                                     // 0x1544(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnEffectEffectStackOverflow(const struct FActiveGameplayEffectHandle& Handle);
	void OnEffectStackCountChange(const struct FActiveGameplayEffectHandle& Handle, int32 NewStackCount, int32 PreviousStackCount);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NotTreatFallAbility_10303101">();
	}
	static class UNotTreatFallAbility_10303101* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNotTreatFallAbility_10303101>();
	}
};
static_assert(alignof(UNotTreatFallAbility_10303101) == 0x000008, "Wrong alignment on UNotTreatFallAbility_10303101");
static_assert(sizeof(UNotTreatFallAbility_10303101) == 0x001548, "Wrong size on UNotTreatFallAbility_10303101");
static_assert(offsetof(UNotTreatFallAbility_10303101, AmorValue) == 0x001540, "Member 'UNotTreatFallAbility_10303101::AmorValue' has a wrong offset!");

// Class Hero_1030.Cue_Ability_Loop_10303101
// 0x0010 (0x11C0 - 0x11B0)
class ACue_Ability_Loop_10303101 : public AMarvelCueNotify_Ability
{
public:
	class USkeletalMeshComponent*                 MoonWeaponMesh;                                    // 0x11B0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11B8[0x8];                                     // 0x11B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Ability_Loop_10303101">();
	}
	static class ACue_Ability_Loop_10303101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Ability_Loop_10303101>();
	}
};
static_assert(alignof(ACue_Ability_Loop_10303101) == 0x000010, "Wrong alignment on ACue_Ability_Loop_10303101");
static_assert(sizeof(ACue_Ability_Loop_10303101) == 0x0011C0, "Wrong size on ACue_Ability_Loop_10303101");
static_assert(offsetof(ACue_Ability_Loop_10303101, MoonWeaponMesh) == 0x0011B0, "Member 'ACue_Ability_Loop_10303101::MoonWeaponMesh' has a wrong offset!");

// Class Hero_1030.Config_103041
// 0x1708 (0x17A0 - 0x0098)
class UConfig_103041 final : public UMarvelAbilityConfig
{
public:
	TArray<int32>                                 SummonerDontSpawnAnka;                             // 0x0098(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         WallTraceDepth;                                    // 0x00A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OffsetOutsideWall;                                 // 0x00AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OffsetInsideWall;                                  // 0x00B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B4[0xC];                                       // 0x00B4(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMarvelAbilityTraceContext             TraceContext;                                      // 0x00C0(0x1660)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	int32                                         AnkaSummonerID;                                    // 0x1720(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DamageScopeID;                                     // 0x1724(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ShieldBuffID;                                      // 0x1728(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ArmorPerTarget;                                    // 0x172C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  AddShieldTags;                                     // 0x1730(0x0068)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         Pad_1798[0x8];                                     // 0x1798(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_103041">();
	}
	static class UConfig_103041* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_103041>();
	}
};
static_assert(alignof(UConfig_103041) == 0x000010, "Wrong alignment on UConfig_103041");
static_assert(sizeof(UConfig_103041) == 0x0017A0, "Wrong size on UConfig_103041");
static_assert(offsetof(UConfig_103041, SummonerDontSpawnAnka) == 0x000098, "Member 'UConfig_103041::SummonerDontSpawnAnka' has a wrong offset!");
static_assert(offsetof(UConfig_103041, WallTraceDepth) == 0x0000A8, "Member 'UConfig_103041::WallTraceDepth' has a wrong offset!");
static_assert(offsetof(UConfig_103041, OffsetOutsideWall) == 0x0000AC, "Member 'UConfig_103041::OffsetOutsideWall' has a wrong offset!");
static_assert(offsetof(UConfig_103041, OffsetInsideWall) == 0x0000B0, "Member 'UConfig_103041::OffsetInsideWall' has a wrong offset!");
static_assert(offsetof(UConfig_103041, TraceContext) == 0x0000C0, "Member 'UConfig_103041::TraceContext' has a wrong offset!");
static_assert(offsetof(UConfig_103041, AnkaSummonerID) == 0x001720, "Member 'UConfig_103041::AnkaSummonerID' has a wrong offset!");
static_assert(offsetof(UConfig_103041, DamageScopeID) == 0x001724, "Member 'UConfig_103041::DamageScopeID' has a wrong offset!");
static_assert(offsetof(UConfig_103041, ShieldBuffID) == 0x001728, "Member 'UConfig_103041::ShieldBuffID' has a wrong offset!");
static_assert(offsetof(UConfig_103041, ArmorPerTarget) == 0x00172C, "Member 'UConfig_103041::ArmorPerTarget' has a wrong offset!");
static_assert(offsetof(UConfig_103041, AddShieldTags) == 0x001730, "Member 'UConfig_103041::AddShieldTags' has a wrong offset!");

// Class Hero_1030.Projectile_10304101
// 0x0200 (0x3D90 - 0x3B90)
class AProjectile_10304101 final : public AMarvelAbilityTargetActor_Projectile
{
public:
	class UConfig_103041*                         AbilityConfig;                                     // 0x3B88(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B90[0x200];                                   // 0x3B90(0x0200)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Projectile_10304101">();
	}
	static class AProjectile_10304101* GetDefaultObj()
	{
		return GetDefaultObjImpl<AProjectile_10304101>();
	}
};
static_assert(alignof(AProjectile_10304101) == 0x000010, "Wrong alignment on AProjectile_10304101");
static_assert(sizeof(AProjectile_10304101) == 0x003D90, "Wrong size on AProjectile_10304101");
static_assert(offsetof(AProjectile_10304101, AbilityConfig) == 0x003B88, "Member 'AProjectile_10304101::AbilityConfig' has a wrong offset!");

// Class Hero_1030.NotTreatFallAbility_10304101
// 0x0008 (0x1548 - 0x1540)
class UNotTreatFallAbility_10304101 : public UMarvelNotTreatFallAbility
{
public:
	class UConfig_103041*                         AbilityConfig;                                     // 0x1540(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NotTreatFallAbility_10304101">();
	}
	static class UNotTreatFallAbility_10304101* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNotTreatFallAbility_10304101>();
	}
};
static_assert(alignof(UNotTreatFallAbility_10304101) == 0x000008, "Wrong alignment on UNotTreatFallAbility_10304101");
static_assert(sizeof(UNotTreatFallAbility_10304101) == 0x001548, "Wrong size on UNotTreatFallAbility_10304101");
static_assert(offsetof(UNotTreatFallAbility_10304101, AbilityConfig) == 0x001540, "Member 'UNotTreatFallAbility_10304101::AbilityConfig' has a wrong offset!");

// Class Hero_1030.Summoned_10304101
// 0x0010 (0x0B50 - 0x0B40)
class ASummoned_10304101 : public AMarvelSummonerBase
{
public:
	class UMeshHiddenComponent*                   HiddenComponent;                                   // 0x0B40(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B48[0x8];                                      // 0x0B48(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Summoned_10304101">();
	}
	static class ASummoned_10304101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASummoned_10304101>();
	}
};
static_assert(alignof(ASummoned_10304101) == 0x000010, "Wrong alignment on ASummoned_10304101");
static_assert(sizeof(ASummoned_10304101) == 0x000B50, "Wrong size on ASummoned_10304101");
static_assert(offsetof(ASummoned_10304101, HiddenComponent) == 0x000B40, "Member 'ASummoned_10304101::HiddenComponent' has a wrong offset!");

// Class Hero_1030.SummonedComp_10304101
// 0x0018 (0x0DC8 - 0x0DB0)
class USummonedComp_10304101 final : public UMarvelSummonedComponent
{
public:
	uint8                                         Pad_DB0[0x18];                                     // 0x0DB0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SummonedComp_10304101">();
	}
	static class USummonedComp_10304101* GetDefaultObj()
	{
		return GetDefaultObjImpl<USummonedComp_10304101>();
	}
};
static_assert(alignof(USummonedComp_10304101) == 0x000008, "Wrong alignment on USummonedComp_10304101");
static_assert(sizeof(USummonedComp_10304101) == 0x000DC8, "Wrong size on USummonedComp_10304101");

// Class Hero_1030.Scope_10304102
// 0x0010 (0x1AB0 - 0x1AA0)
class AScope_10304102 final : public AMarvelAbilityTargetActor_Scope
{
public:
	uint8                                         Pad_1AA0[0x10];                                    // 0x1AA0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnActorEndPlay(class AActor* Actor, EEndPlayReason EndPlayReason);
	void OnCharacterDeath(class AActor* InSourceAvatar, class AActor* InTargetAvatar, const struct FAttributeModifierHandle& ModifierParameterHandle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Scope_10304102">();
	}
	static class AScope_10304102* GetDefaultObj()
	{
		return GetDefaultObjImpl<AScope_10304102>();
	}
};
static_assert(alignof(AScope_10304102) == 0x000010, "Wrong alignment on AScope_10304102");
static_assert(sizeof(AScope_10304102) == 0x001AB0, "Wrong size on AScope_10304102");

// Class Hero_1030.ScopeManager_10304102
// 0x0050 (0x0080 - 0x0030)
class UScopeManager_10304102 final : public UObject
{
public:
	uint8                                         Pad_30[0x50];                                      // 0x0030(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FVector DoCondition(class AActor* InActor, const struct FVector& Delta);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScopeManager_10304102">();
	}
	static class UScopeManager_10304102* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScopeManager_10304102>();
	}
};
static_assert(alignof(UScopeManager_10304102) == 0x000008, "Wrong alignment on UScopeManager_10304102");
static_assert(sizeof(UScopeManager_10304102) == 0x000080, "Wrong size on UScopeManager_10304102");

// Class Hero_1030.Cue_Buff_10304101
// 0x00A0 (0x16E0 - 0x1640)
class ACue_Buff_10304101 final : public AMarvelCueNotify_Buff
{
public:
	class UFXSystemAsset*                         LineEffectPartOne;                                 // 0x1638(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFXSystemAsset*                         LineEffectPartTwo;                                 // 0x1640(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFxMaterialsCurve                      ColorMaterial;                                     // 0x1648(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FFxMaterialsCurve                      GoldColorMaterial;                                 // 0x1680(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         LightDuration;                                     // 0x16B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16BC[0x4];                                     // 0x16BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AMarvelBaseCharacter*                   OwnerCharacter;                                    // 0x16C0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16C8[0x18];                                    // 0x16C8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnOwnerApplyDamage(class AActor* InSourceAvatar, class AActor* InTargetAvatar, const struct FAttributeModifierHandle& ModifierParameterHandle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Buff_10304101">();
	}
	static class ACue_Buff_10304101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Buff_10304101>();
	}
};
static_assert(alignof(ACue_Buff_10304101) == 0x000010, "Wrong alignment on ACue_Buff_10304101");
static_assert(sizeof(ACue_Buff_10304101) == 0x0016E0, "Wrong size on ACue_Buff_10304101");
static_assert(offsetof(ACue_Buff_10304101, LineEffectPartOne) == 0x001638, "Member 'ACue_Buff_10304101::LineEffectPartOne' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10304101, LineEffectPartTwo) == 0x001640, "Member 'ACue_Buff_10304101::LineEffectPartTwo' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10304101, ColorMaterial) == 0x001648, "Member 'ACue_Buff_10304101::ColorMaterial' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10304101, GoldColorMaterial) == 0x001680, "Member 'ACue_Buff_10304101::GoldColorMaterial' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10304101, LightDuration) == 0x0016B8, "Member 'ACue_Buff_10304101::LightDuration' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10304101, OwnerCharacter) == 0x0016C0, "Member 'ACue_Buff_10304101::OwnerCharacter' has a wrong offset!");

// Class Hero_1030.Cue_Summoner_Loop_10304101
// 0x0010 (0x1210 - 0x1200)
class ACue_Summoner_Loop_10304101 final : public AMarvelCueNotify_Summoned
{
public:
	class AMarvelSummonerBase*                    OwnerSummoner;                                     // 0x11F8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OwnerInstigator;                                   // 0x1200(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      NS_Anka;                                           // 0x1208(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void OnOwnerSummonerDeath(class AActor* InSource, class AActor* InSourceAvatar, const struct FAttributeModifierHandle& ModifierParameterHandle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Summoner_Loop_10304101">();
	}
	static class ACue_Summoner_Loop_10304101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Summoner_Loop_10304101>();
	}
};
static_assert(alignof(ACue_Summoner_Loop_10304101) == 0x000010, "Wrong alignment on ACue_Summoner_Loop_10304101");
static_assert(sizeof(ACue_Summoner_Loop_10304101) == 0x001210, "Wrong size on ACue_Summoner_Loop_10304101");
static_assert(offsetof(ACue_Summoner_Loop_10304101, OwnerSummoner) == 0x0011F8, "Member 'ACue_Summoner_Loop_10304101::OwnerSummoner' has a wrong offset!");
static_assert(offsetof(ACue_Summoner_Loop_10304101, OwnerInstigator) == 0x001200, "Member 'ACue_Summoner_Loop_10304101::OwnerInstigator' has a wrong offset!");
static_assert(offsetof(ACue_Summoner_Loop_10304101, NS_Anka) == 0x001208, "Member 'ACue_Summoner_Loop_10304101::NS_Anka' has a wrong offset!");

// Class Hero_1030.Config_103051
// 0x0BE8 (0x0C80 - 0x0098)
class UConfig_103051 final : public UMarvelAbilityConfig
{
public:
	struct FDashAbilityInfo                       DashInfo;                                          // 0x0098(0x0BC8)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bEnableOffsetZ;                                    // 0x0C60(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C61[0x3];                                      // 0x0C61(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DashOffsetZ;                                       // 0x0C64(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDashDistance;                                   // 0x0C68(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxFlyDistance;                                    // 0x0C6C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CableLaunchV;                                      // 0x0C70(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CableRecoverA;                                     // 0x0C74(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEndMontageWhenDashFinish;                         // 0x0C78(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C79[0x7];                                      // 0x0C79(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_103051">();
	}
	static class UConfig_103051* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_103051>();
	}
};
static_assert(alignof(UConfig_103051) == 0x000008, "Wrong alignment on UConfig_103051");
static_assert(sizeof(UConfig_103051) == 0x000C80, "Wrong size on UConfig_103051");
static_assert(offsetof(UConfig_103051, DashInfo) == 0x000098, "Member 'UConfig_103051::DashInfo' has a wrong offset!");
static_assert(offsetof(UConfig_103051, bEnableOffsetZ) == 0x000C60, "Member 'UConfig_103051::bEnableOffsetZ' has a wrong offset!");
static_assert(offsetof(UConfig_103051, DashOffsetZ) == 0x000C64, "Member 'UConfig_103051::DashOffsetZ' has a wrong offset!");
static_assert(offsetof(UConfig_103051, MaxDashDistance) == 0x000C68, "Member 'UConfig_103051::MaxDashDistance' has a wrong offset!");
static_assert(offsetof(UConfig_103051, MaxFlyDistance) == 0x000C6C, "Member 'UConfig_103051::MaxFlyDistance' has a wrong offset!");
static_assert(offsetof(UConfig_103051, CableLaunchV) == 0x000C70, "Member 'UConfig_103051::CableLaunchV' has a wrong offset!");
static_assert(offsetof(UConfig_103051, CableRecoverA) == 0x000C74, "Member 'UConfig_103051::CableRecoverA' has a wrong offset!");
static_assert(offsetof(UConfig_103051, bEndMontageWhenDashFinish) == 0x000C78, "Member 'UConfig_103051::bEndMontageWhenDashFinish' has a wrong offset!");

// Class Hero_1030.Ability_103051
// 0x0258 (0x2C50 - 0x29F8)
class UAbility_103051 : public UAbility_108
{
public:
	class UConfig_103051*                         AbilityConfig;                                     // 0x29F8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAbilityTask_WaitMovementModeChange*    MoveModeTask;                                      // 0x2A00(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A08[0x248];                                   // 0x2A08(0x0248)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnDashFinish(EDashStopReason Reason);
	void OnOwnerLanding(EMovementMode Mode);
	void OnTargetForceChangedByLevelPortal(const struct FTransform& OriginTransform, const struct FTransform& TargetTransform);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_103051">();
	}
	static class UAbility_103051* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_103051>();
	}
};
static_assert(alignof(UAbility_103051) == 0x000008, "Wrong alignment on UAbility_103051");
static_assert(sizeof(UAbility_103051) == 0x002C50, "Wrong size on UAbility_103051");
static_assert(offsetof(UAbility_103051, AbilityConfig) == 0x0029F8, "Member 'UAbility_103051::AbilityConfig' has a wrong offset!");
static_assert(offsetof(UAbility_103051, MoveModeTask) == 0x002A00, "Member 'UAbility_103051::MoveModeTask' has a wrong offset!");

// Class Hero_1030.Projectile_10305101
// 0x0000 (0x3B90 - 0x3B90)
class AProjectile_10305101 : public AMarvelAbilityTargetActor_Projectile
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Projectile_10305101">();
	}
	static class AProjectile_10305101* GetDefaultObj()
	{
		return GetDefaultObjImpl<AProjectile_10305101>();
	}
};
static_assert(alignof(AProjectile_10305101) == 0x000010, "Wrong alignment on AProjectile_10305101");
static_assert(sizeof(AProjectile_10305101) == 0x003B90, "Wrong size on AProjectile_10305101");

// Class Hero_1030.Cue_Projectile_Loop_10305101
// 0x0120 (0x1250 - 0x1130)
class ACue_Projectile_Loop_10305101 final : public AMarvelCueNotify_Projectile
{
public:
	class FName                                   CableAttachedSocket;                               // 0x1128(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DelayFromHit;                                      // 0x1134(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DelayFromDistance;                                 // 0x1138(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartParticleScale;                                // 0x113C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  TagContainer;                                      // 0x1140(0x0068)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         MinNumOfSegments;                                  // 0x11A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11AC[0x4];                                     // 0x11AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            ControlPointCurve;                                 // 0x11B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMoonKnightCableComponent*              CableComponent;                                    // 0x11B8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   HookComponent;                                     // 0x11C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AMarvelBaseCharacter*                   OwnerCharacter;                                    // 0x11C8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AMarvelAbilityTargetActor_Projectile*   OwnerProjectile;                                   // 0x11D0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMarvelGameplayAbility*                 OwningAbility;                                     // 0x11D8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11E0[0x70];                                    // 0x11E0(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnGenericGameplayTagUpdate(const struct FGameplayTag& InTag, int32 Count);
	void OnProjectileHit(const struct FHitResult& Hit);
	void PostCableUpdate(float DeltaSeconds);
	void PreCableUpdate(float DeltaSeconds);
	void SetCableVisibility(bool bVisible);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Projectile_Loop_10305101">();
	}
	static class ACue_Projectile_Loop_10305101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Projectile_Loop_10305101>();
	}
};
static_assert(alignof(ACue_Projectile_Loop_10305101) == 0x000010, "Wrong alignment on ACue_Projectile_Loop_10305101");
static_assert(sizeof(ACue_Projectile_Loop_10305101) == 0x001250, "Wrong size on ACue_Projectile_Loop_10305101");
static_assert(offsetof(ACue_Projectile_Loop_10305101, CableAttachedSocket) == 0x001128, "Member 'ACue_Projectile_Loop_10305101::CableAttachedSocket' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10305101, DelayFromHit) == 0x001134, "Member 'ACue_Projectile_Loop_10305101::DelayFromHit' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10305101, DelayFromDistance) == 0x001138, "Member 'ACue_Projectile_Loop_10305101::DelayFromDistance' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10305101, StartParticleScale) == 0x00113C, "Member 'ACue_Projectile_Loop_10305101::StartParticleScale' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10305101, TagContainer) == 0x001140, "Member 'ACue_Projectile_Loop_10305101::TagContainer' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10305101, MinNumOfSegments) == 0x0011A8, "Member 'ACue_Projectile_Loop_10305101::MinNumOfSegments' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10305101, ControlPointCurve) == 0x0011B0, "Member 'ACue_Projectile_Loop_10305101::ControlPointCurve' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10305101, CableComponent) == 0x0011B8, "Member 'ACue_Projectile_Loop_10305101::CableComponent' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10305101, HookComponent) == 0x0011C0, "Member 'ACue_Projectile_Loop_10305101::HookComponent' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10305101, OwnerCharacter) == 0x0011C8, "Member 'ACue_Projectile_Loop_10305101::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10305101, OwnerProjectile) == 0x0011D0, "Member 'ACue_Projectile_Loop_10305101::OwnerProjectile' has a wrong offset!");
static_assert(offsetof(ACue_Projectile_Loop_10305101, OwningAbility) == 0x0011D8, "Member 'ACue_Projectile_Loop_10305101::OwningAbility' has a wrong offset!");

// Class Hero_1030.MoonKnightCableComponent
// 0x0000 (0x0BA0 - 0x0BA0)
class UMoonKnightCableComponent final : public UMarvelCableComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoonKnightCableComponent">();
	}
	static class UMoonKnightCableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoonKnightCableComponent>();
	}
};
static_assert(alignof(UMoonKnightCableComponent) == 0x000010, "Wrong alignment on UMoonKnightCableComponent");
static_assert(sizeof(UMoonKnightCableComponent) == 0x000BA0, "Wrong size on UMoonKnightCableComponent");

// Class Hero_1030.Config_103052
// 0x0028 (0x0120 - 0x00F8)
class UConfig_103052 final : public UConfig_AeroBase
{
public:
	float                                         DefaultGlidingV;                                   // 0x00F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           CueTag;                                            // 0x00FC(0x000C)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           CloakOneTag;                                       // 0x0108(0x000C)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           CloakTwoTag;                                       // 0x0114(0x000C)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_103052">();
	}
	static class UConfig_103052* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_103052>();
	}
};
static_assert(alignof(UConfig_103052) == 0x000008, "Wrong alignment on UConfig_103052");
static_assert(sizeof(UConfig_103052) == 0x000120, "Wrong size on UConfig_103052");
static_assert(offsetof(UConfig_103052, DefaultGlidingV) == 0x0000F8, "Member 'UConfig_103052::DefaultGlidingV' has a wrong offset!");
static_assert(offsetof(UConfig_103052, CueTag) == 0x0000FC, "Member 'UConfig_103052::CueTag' has a wrong offset!");
static_assert(offsetof(UConfig_103052, CloakOneTag) == 0x000108, "Member 'UConfig_103052::CloakOneTag' has a wrong offset!");
static_assert(offsetof(UConfig_103052, CloakTwoTag) == 0x000114, "Member 'UConfig_103052::CloakTwoTag' has a wrong offset!");

// Class Hero_1030.Ability_103052
// 0x00F8 (0x2C08 - 0x2B10)
class UAbility_103052 : public UMarvelAeroBaseAbility
{
public:
	class UConfig_103052*                         AbilityConfig;                                     // 0x2B10(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMarvelAbilityTask_WaitBindInput*       InputTask;                                         // 0x2B18(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMarvelAbilityTask_PlayMontageAndWaitForEvent* TimelineTask;                               // 0x2B20(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B28[0xE0];                                    // 0x2B28(0x00E0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CanActivateForUI();
	void LeaveGlide(float Time);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_103052">();
	}
	static class UAbility_103052* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_103052>();
	}
};
static_assert(alignof(UAbility_103052) == 0x000008, "Wrong alignment on UAbility_103052");
static_assert(sizeof(UAbility_103052) == 0x002C08, "Wrong size on UAbility_103052");
static_assert(offsetof(UAbility_103052, AbilityConfig) == 0x002B10, "Member 'UAbility_103052::AbilityConfig' has a wrong offset!");
static_assert(offsetof(UAbility_103052, InputTask) == 0x002B18, "Member 'UAbility_103052::InputTask' has a wrong offset!");
static_assert(offsetof(UAbility_103052, TimelineTask) == 0x002B20, "Member 'UAbility_103052::TimelineTask' has a wrong offset!");

// Class Hero_1030.Ability_103053
// 0x0038 (0x2A28 - 0x29F0)
class UAbility_103053 : public UMarvelGameplayAbility
{
public:
	class UAbility_103052*                        Ability_Glide;                                     // 0x29F0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMarvelGameplayAbility*                 Ability_DoubleJump;                                // 0x29F8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AMarvelBaseCharacter*                   OwnerCharacter;                                    // 0x2A00(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UConfig_103052*                         GlideConfig;                                       // 0x2A08(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMarvelAbilityTask_WaitBindInput*       InputTask;                                         // 0x2A10(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A18[0x10];                                    // 0x2A18(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_103053">();
	}
	static class UAbility_103053* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_103053>();
	}
};
static_assert(alignof(UAbility_103053) == 0x000008, "Wrong alignment on UAbility_103053");
static_assert(sizeof(UAbility_103053) == 0x002A28, "Wrong size on UAbility_103053");
static_assert(offsetof(UAbility_103053, Ability_Glide) == 0x0029F0, "Member 'UAbility_103053::Ability_Glide' has a wrong offset!");
static_assert(offsetof(UAbility_103053, Ability_DoubleJump) == 0x0029F8, "Member 'UAbility_103053::Ability_DoubleJump' has a wrong offset!");
static_assert(offsetof(UAbility_103053, OwnerCharacter) == 0x002A00, "Member 'UAbility_103053::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(UAbility_103053, GlideConfig) == 0x002A08, "Member 'UAbility_103053::GlideConfig' has a wrong offset!");
static_assert(offsetof(UAbility_103053, InputTask) == 0x002A10, "Member 'UAbility_103053::InputTask' has a wrong offset!");

// Class Hero_1030.Config_103061
// 0x0020 (0x00B8 - 0x0098)
class UConfig_103061 : public UMarvelAbilityConfig
{
public:
	int32                                         ProjectileID;                                      // 0x0098(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ProjectileNum;                                     // 0x009C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ProjectileDelay;                                   // 0x00A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ProjectileInterval;                                // 0x00A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DamageScopeID_HitPoint;                            // 0x00A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DamageScopeID_Summoner;                            // 0x00AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EnergyForbidBuffID;                                // 0x00B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B4[0x4];                                       // 0x00B4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_103061">();
	}
	static class UConfig_103061* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_103061>();
	}
};
static_assert(alignof(UConfig_103061) == 0x000008, "Wrong alignment on UConfig_103061");
static_assert(sizeof(UConfig_103061) == 0x0000B8, "Wrong size on UConfig_103061");
static_assert(offsetof(UConfig_103061, ProjectileID) == 0x000098, "Member 'UConfig_103061::ProjectileID' has a wrong offset!");
static_assert(offsetof(UConfig_103061, ProjectileNum) == 0x00009C, "Member 'UConfig_103061::ProjectileNum' has a wrong offset!");
static_assert(offsetof(UConfig_103061, ProjectileDelay) == 0x0000A0, "Member 'UConfig_103061::ProjectileDelay' has a wrong offset!");
static_assert(offsetof(UConfig_103061, ProjectileInterval) == 0x0000A4, "Member 'UConfig_103061::ProjectileInterval' has a wrong offset!");
static_assert(offsetof(UConfig_103061, DamageScopeID_HitPoint) == 0x0000A8, "Member 'UConfig_103061::DamageScopeID_HitPoint' has a wrong offset!");
static_assert(offsetof(UConfig_103061, DamageScopeID_Summoner) == 0x0000AC, "Member 'UConfig_103061::DamageScopeID_Summoner' has a wrong offset!");
static_assert(offsetof(UConfig_103061, EnergyForbidBuffID) == 0x0000B0, "Member 'UConfig_103061::EnergyForbidBuffID' has a wrong offset!");

// Class Hero_1030.Ability_103061
// 0x0008 (0x2A00 - 0x29F8)
class UAbility_103061 : public UAbility_108
{
public:
	class AMarvelAbilityTargetActor_Projectile*   CurrentProjectile;                                 // 0x29F8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_103061">();
	}
	static class UAbility_103061* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_103061>();
	}
};
static_assert(alignof(UAbility_103061) == 0x000008, "Wrong alignment on UAbility_103061");
static_assert(sizeof(UAbility_103061) == 0x002A00, "Wrong size on UAbility_103061");
static_assert(offsetof(UAbility_103061, CurrentProjectile) == 0x0029F8, "Member 'UAbility_103061::CurrentProjectile' has a wrong offset!");

// Class Hero_1030.ProjectileMovementComponent_Parabola
// 0x0020 (0x2A60 - 0x2A40)
class UProjectileMovementComponent_Parabola final : public UMarvelProjectileComponent
{
public:
	struct FVector                                ParabolaEndPoint;                                  // 0x2A40(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A58[0x8];                                     // 0x2A58(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProjectileMovementComponent_Parabola">();
	}
	static class UProjectileMovementComponent_Parabola* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProjectileMovementComponent_Parabola>();
	}
};
static_assert(alignof(UProjectileMovementComponent_Parabola) == 0x000010, "Wrong alignment on UProjectileMovementComponent_Parabola");
static_assert(sizeof(UProjectileMovementComponent_Parabola) == 0x002A60, "Wrong size on UProjectileMovementComponent_Parabola");
static_assert(offsetof(UProjectileMovementComponent_Parabola, ParabolaEndPoint) == 0x002A40, "Member 'UProjectileMovementComponent_Parabola::ParabolaEndPoint' has a wrong offset!");

// Class Hero_1030.Projectile_10306101
// 0x00C0 (0x3C50 - 0x3B90)
class AProjectile_10306101 final : public AMarvelAbilityTargetActor_Projectile
{
public:
	int32                                         ProjectileIndex;                                   // 0x3B88(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3B8C[0x4];                                     // 0x3B8C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                EndPoint;                                          // 0x3B90(0x0018)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3BA8[0x8];                                     // 0x3BA8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             ProjectileTransform;                               // 0x3BB0(0x0060)(Net, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                SummonerLocation;                                  // 0x3C10(0x0018)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C28[0x28];                                    // 0x3C28(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetProjectileEndPoint(const struct FVector& InLocation);
	void SetProjectileIndex(const int32 InValue);
	void SetProjectileTransform(const struct FTransform& InTransform);
	void SetSummonerLocation(const struct FVector& InLocation);

	struct FVector GetSummonerLocation() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Projectile_10306101">();
	}
	static class AProjectile_10306101* GetDefaultObj()
	{
		return GetDefaultObjImpl<AProjectile_10306101>();
	}
};
static_assert(alignof(AProjectile_10306101) == 0x000010, "Wrong alignment on AProjectile_10306101");
static_assert(sizeof(AProjectile_10306101) == 0x003C50, "Wrong size on AProjectile_10306101");
static_assert(offsetof(AProjectile_10306101, ProjectileIndex) == 0x003B88, "Member 'AProjectile_10306101::ProjectileIndex' has a wrong offset!");
static_assert(offsetof(AProjectile_10306101, EndPoint) == 0x003B90, "Member 'AProjectile_10306101::EndPoint' has a wrong offset!");
static_assert(offsetof(AProjectile_10306101, ProjectileTransform) == 0x003BB0, "Member 'AProjectile_10306101::ProjectileTransform' has a wrong offset!");
static_assert(offsetof(AProjectile_10306101, SummonerLocation) == 0x003C10, "Member 'AProjectile_10306101::SummonerLocation' has a wrong offset!");

// Class Hero_1030.Summoned_10306101
// 0x01C0 (0x0D00 - 0x0B40)
class ASummoned_10306101 : public AMarvelSummonerBase
{
public:
	class AMarvelBaseCharacter*                   OwnerCharacter;                                    // 0x0B40(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UConfig_103061*                         AbilityConfig;                                     // 0x0B48(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B50[0x170];                                    // 0x0B50(0x0170)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ProjectileNum;                                     // 0x0CC0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MoonRightOffset;                                   // 0x0CC4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MoonUpOffset;                                      // 0x0CC8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MoonScaleOverride;                                 // 0x0CCC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SkyHeight;                                         // 0x0CD0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MoonRadius;                                        // 0x0CD4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                ProjectileStartOffset;                             // 0x0CD8(0x0018)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EndPointRadius;                                    // 0x0CF0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EndPointAngle;                                     // 0x0CF4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_CF8[0x8];                                      // 0x0CF8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FTransform CalcMoonTransform();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Summoned_10306101">();
	}
	static class ASummoned_10306101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASummoned_10306101>();
	}
};
static_assert(alignof(ASummoned_10306101) == 0x000010, "Wrong alignment on ASummoned_10306101");
static_assert(sizeof(ASummoned_10306101) == 0x000D00, "Wrong size on ASummoned_10306101");
static_assert(offsetof(ASummoned_10306101, OwnerCharacter) == 0x000B40, "Member 'ASummoned_10306101::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(ASummoned_10306101, AbilityConfig) == 0x000B48, "Member 'ASummoned_10306101::AbilityConfig' has a wrong offset!");
static_assert(offsetof(ASummoned_10306101, ProjectileNum) == 0x000CC0, "Member 'ASummoned_10306101::ProjectileNum' has a wrong offset!");
static_assert(offsetof(ASummoned_10306101, MoonRightOffset) == 0x000CC4, "Member 'ASummoned_10306101::MoonRightOffset' has a wrong offset!");
static_assert(offsetof(ASummoned_10306101, MoonUpOffset) == 0x000CC8, "Member 'ASummoned_10306101::MoonUpOffset' has a wrong offset!");
static_assert(offsetof(ASummoned_10306101, MoonScaleOverride) == 0x000CCC, "Member 'ASummoned_10306101::MoonScaleOverride' has a wrong offset!");
static_assert(offsetof(ASummoned_10306101, SkyHeight) == 0x000CD0, "Member 'ASummoned_10306101::SkyHeight' has a wrong offset!");
static_assert(offsetof(ASummoned_10306101, MoonRadius) == 0x000CD4, "Member 'ASummoned_10306101::MoonRadius' has a wrong offset!");
static_assert(offsetof(ASummoned_10306101, ProjectileStartOffset) == 0x000CD8, "Member 'ASummoned_10306101::ProjectileStartOffset' has a wrong offset!");
static_assert(offsetof(ASummoned_10306101, EndPointRadius) == 0x000CF0, "Member 'ASummoned_10306101::EndPointRadius' has a wrong offset!");
static_assert(offsetof(ASummoned_10306101, EndPointAngle) == 0x000CF4, "Member 'ASummoned_10306101::EndPointAngle' has a wrong offset!");

// Class Hero_1030.Cue_Ability_Loop_10306102
// 0x0010 (0x11C0 - 0x11B0)
class ACue_Ability_Loop_10306102 : public AMarvelCueNotify_Ability
{
public:
	class USkeletalMeshComponent*                 AnkaWeaponMesh;                                    // 0x11B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11B8[0x8];                                     // 0x11B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Ability_Loop_10306102">();
	}
	static class ACue_Ability_Loop_10306102* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Ability_Loop_10306102>();
	}
};
static_assert(alignof(ACue_Ability_Loop_10306102) == 0x000010, "Wrong alignment on ACue_Ability_Loop_10306102");
static_assert(sizeof(ACue_Ability_Loop_10306102) == 0x0011C0, "Wrong size on ACue_Ability_Loop_10306102");
static_assert(offsetof(ACue_Ability_Loop_10306102, AnkaWeaponMesh) == 0x0011B0, "Member 'ACue_Ability_Loop_10306102::AnkaWeaponMesh' has a wrong offset!");

// Class Hero_1030.Cue_Summoned_Loop_10306101
// 0x0010 (0x1210 - 0x1200)
class ACue_Summoned_Loop_10306101 : public AMarvelCueNotify_Summoned
{
public:
	class ASummoned_10306101*                     OwnerSummoner;                                     // 0x11F8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   Moon;                                              // 0x1200(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFXSystemComponent*                     SkyFX;                                             // 0x1208(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Summoned_Loop_10306101">();
	}
	static class ACue_Summoned_Loop_10306101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Summoned_Loop_10306101>();
	}
};
static_assert(alignof(ACue_Summoned_Loop_10306101) == 0x000010, "Wrong alignment on ACue_Summoned_Loop_10306101");
static_assert(sizeof(ACue_Summoned_Loop_10306101) == 0x001210, "Wrong size on ACue_Summoned_Loop_10306101");
static_assert(offsetof(ACue_Summoned_Loop_10306101, OwnerSummoner) == 0x0011F8, "Member 'ACue_Summoned_Loop_10306101::OwnerSummoner' has a wrong offset!");
static_assert(offsetof(ACue_Summoned_Loop_10306101, Moon) == 0x001200, "Member 'ACue_Summoned_Loop_10306101::Moon' has a wrong offset!");
static_assert(offsetof(ACue_Summoned_Loop_10306101, SkyFX) == 0x001208, "Member 'ACue_Summoned_Loop_10306101::SkyFX' has a wrong offset!");

// Class Hero_1030.Cue_TraceActor_10306101
// 0x0020 (0x1000 - 0x0FE0)
class ACue_TraceActor_10306101 final : public AMarvelCueNotify_TraceActor
{
public:
	struct FVector                                DecalSize;                                         // 0x0FD8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDecalComponent*                        DecalComponent;                                    // 0x0FF0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FF8[0x8];                                      // 0x0FF8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_TraceActor_10306101">();
	}
	static class ACue_TraceActor_10306101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_TraceActor_10306101>();
	}
};
static_assert(alignof(ACue_TraceActor_10306101) == 0x000010, "Wrong alignment on ACue_TraceActor_10306101");
static_assert(sizeof(ACue_TraceActor_10306101) == 0x001000, "Wrong size on ACue_TraceActor_10306101");
static_assert(offsetof(ACue_TraceActor_10306101, DecalSize) == 0x000FD8, "Member 'ACue_TraceActor_10306101::DecalSize' has a wrong offset!");
static_assert(offsetof(ACue_TraceActor_10306101, DecalComponent) == 0x000FF0, "Member 'ACue_TraceActor_10306101::DecalComponent' has a wrong offset!");

// Class Hero_1030.Cue_Projectile_HitImpact_10306101
// 0x0000 (0x05C8 - 0x05C8)
class UCue_Projectile_HitImpact_10306101 final : public UMarvelCueNotify_HitImpact
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Projectile_HitImpact_10306101">();
	}
	static class UCue_Projectile_HitImpact_10306101* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCue_Projectile_HitImpact_10306101>();
	}
};
static_assert(alignof(UCue_Projectile_HitImpact_10306101) == 0x000008, "Wrong alignment on UCue_Projectile_HitImpact_10306101");
static_assert(sizeof(UCue_Projectile_HitImpact_10306101) == 0x0005C8, "Wrong size on UCue_Projectile_HitImpact_10306101");

// Class Hero_1030.Config_103071
// 0x0000 (0x00C0 - 0x00C0)
class UConfig_103071 final : public UMarvelAbilityConfig_DoubleJump
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_103071">();
	}
	static class UConfig_103071* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_103071>();
	}
};
static_assert(alignof(UConfig_103071) == 0x000008, "Wrong alignment on UConfig_103071");
static_assert(sizeof(UConfig_103071) == 0x0000C0, "Wrong size on UConfig_103071");

// Class Hero_1030.Ability_103071
// 0x0000 (0x2AB8 - 0x2AB8)
class UAbility_103071 : public UMarvelAbility_DoubleJump
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_103071">();
	}
	static class UAbility_103071* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_103071>();
	}
};
static_assert(alignof(UAbility_103071) == 0x000008, "Wrong alignment on UAbility_103071");
static_assert(sizeof(UAbility_103071) == 0x002AB8, "Wrong size on UAbility_103071");

// Class Hero_1030.EpicMomentAction_1030
// 0x0000 (0x0120 - 0x0120)
class UEpicMomentAction_1030 final : public UEpicMomentBaseAction
{
public:
	void OnSummonerBegin(class AActor* SourceActor, class UMarvelGameplayAbility* SourceAbility, class AActor* Summoned, const struct FMarvelTargetActorGenerateInfo& GenerateInfo);
	void OnSummonerEnd(class AActor* InActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EpicMomentAction_1030">();
	}
	static class UEpicMomentAction_1030* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEpicMomentAction_1030>();
	}
};
static_assert(alignof(UEpicMomentAction_1030) == 0x000008, "Wrong alignment on UEpicMomentAction_1030");
static_assert(sizeof(UEpicMomentAction_1030) == 0x000120, "Wrong size on UEpicMomentAction_1030");

// Class Hero_1030.MoonKnightAnimInstance
// 0x00E0 (0x0B00 - 0x0A20)
class UMoonKnightAnimInstance final : public UMarvelAnimInstance
{
public:
	class UAnimSequence*                          FallingAnimAsset;                                  // 0x0A20(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLayeredBoneBlendExternalSetting       PelvisBlendSettings;                               // 0x0A28(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FName                                   PelvisModifyCurveName_103051;                      // 0x0A38(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           MeleeAbilityTag;                                   // 0x0A44(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PevisLoc;                                          // 0x0A50(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                StartVelocity;                                     // 0x0A68(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsDoubleJumpingForAnim;                            // 0x0A80(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldUseAO;                                      // 0x0A81(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bNeedModifyBone;                                   // 0x0A82(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A83[0x1];                                      // 0x0A83(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PelvisModifyCurveValue_103051;                     // 0x0A84(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A88[0x78];                                     // 0x0A88(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnGenericGameplayTagUpdate(const struct FGameplayTag& InTag, int32 Count);

	void GetLinkedAeroAnimInstances(TArray<class UAnimInstance*>* OutLinkedInstances) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoonKnightAnimInstance">();
	}
	static class UMoonKnightAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoonKnightAnimInstance>();
	}
};
static_assert(alignof(UMoonKnightAnimInstance) == 0x000010, "Wrong alignment on UMoonKnightAnimInstance");
static_assert(sizeof(UMoonKnightAnimInstance) == 0x000B00, "Wrong size on UMoonKnightAnimInstance");
static_assert(offsetof(UMoonKnightAnimInstance, FallingAnimAsset) == 0x000A20, "Member 'UMoonKnightAnimInstance::FallingAnimAsset' has a wrong offset!");
static_assert(offsetof(UMoonKnightAnimInstance, PelvisBlendSettings) == 0x000A28, "Member 'UMoonKnightAnimInstance::PelvisBlendSettings' has a wrong offset!");
static_assert(offsetof(UMoonKnightAnimInstance, PelvisModifyCurveName_103051) == 0x000A38, "Member 'UMoonKnightAnimInstance::PelvisModifyCurveName_103051' has a wrong offset!");
static_assert(offsetof(UMoonKnightAnimInstance, MeleeAbilityTag) == 0x000A44, "Member 'UMoonKnightAnimInstance::MeleeAbilityTag' has a wrong offset!");
static_assert(offsetof(UMoonKnightAnimInstance, PevisLoc) == 0x000A50, "Member 'UMoonKnightAnimInstance::PevisLoc' has a wrong offset!");
static_assert(offsetof(UMoonKnightAnimInstance, StartVelocity) == 0x000A68, "Member 'UMoonKnightAnimInstance::StartVelocity' has a wrong offset!");
static_assert(offsetof(UMoonKnightAnimInstance, IsDoubleJumpingForAnim) == 0x000A80, "Member 'UMoonKnightAnimInstance::IsDoubleJumpingForAnim' has a wrong offset!");
static_assert(offsetof(UMoonKnightAnimInstance, bShouldUseAO) == 0x000A81, "Member 'UMoonKnightAnimInstance::bShouldUseAO' has a wrong offset!");
static_assert(offsetof(UMoonKnightAnimInstance, bNeedModifyBone) == 0x000A82, "Member 'UMoonKnightAnimInstance::bNeedModifyBone' has a wrong offset!");
static_assert(offsetof(UMoonKnightAnimInstance, PelvisModifyCurveValue_103051) == 0x000A84, "Member 'UMoonKnightAnimInstance::PelvisModifyCurveValue_103051' has a wrong offset!");

// Class Hero_1030.MoonKnightCharacter
// 0x0010 (0x21B0 - 0x21A0)
class AMoonKnightCharacter : public AMarvelBaseCharacter
{
public:
	class UMoonKnightMoveLogicBaseComponent*      MoonKnightMoveLogic;                               // 0x21A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_21A8[0x8];                                     // 0x21A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoonKnightCharacter">();
	}
	static class AMoonKnightCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMoonKnightCharacter>();
	}
};
static_assert(alignof(AMoonKnightCharacter) == 0x000010, "Wrong alignment on AMoonKnightCharacter");
static_assert(sizeof(AMoonKnightCharacter) == 0x0021B0, "Wrong size on AMoonKnightCharacter");
static_assert(offsetof(AMoonKnightCharacter, MoonKnightMoveLogic) == 0x0021A0, "Member 'AMoonKnightCharacter::MoonKnightMoveLogic' has a wrong offset!");

// Class Hero_1030.MoonKnightChildActor
// 0x0110 (0x0F30 - 0x0E20)
class AMoonKnightChildActor : public AMarvelCharacterChildActor
{
public:
	class AMarvelBaseCharacter*                   OwnerCharacter;                                    // 0x0E18(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   MoonMesh;                                          // 0x0E20(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E28[0x30];                                     // 0x0E28(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ResetCloakDelay;                                   // 0x0E58(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E5C[0x4];                                      // 0x0E5C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<struct FMaterialQuery>                   NormalCloakQuery;                                  // 0x0E60(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSet<struct FMaterialQuery>                   GlideCloakQuery;                                   // 0x0EB0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<int32>                                 NormalCloakSlot;                                   // 0x0F00(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<int32>                                 GlideCloakSlot;                                    // 0x0F10(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<int32>                                 ExtraMoonSkinIDs;                                  // 0x0F20(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	void OnOwnerReborn(class AActor* Target, const struct FCharacterRebornParam& Param);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoonKnightChildActor">();
	}
	static class AMoonKnightChildActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMoonKnightChildActor>();
	}
};
static_assert(alignof(AMoonKnightChildActor) == 0x000010, "Wrong alignment on AMoonKnightChildActor");
static_assert(sizeof(AMoonKnightChildActor) == 0x000F30, "Wrong size on AMoonKnightChildActor");
static_assert(offsetof(AMoonKnightChildActor, OwnerCharacter) == 0x000E18, "Member 'AMoonKnightChildActor::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(AMoonKnightChildActor, MoonMesh) == 0x000E20, "Member 'AMoonKnightChildActor::MoonMesh' has a wrong offset!");
static_assert(offsetof(AMoonKnightChildActor, ResetCloakDelay) == 0x000E58, "Member 'AMoonKnightChildActor::ResetCloakDelay' has a wrong offset!");
static_assert(offsetof(AMoonKnightChildActor, NormalCloakQuery) == 0x000E60, "Member 'AMoonKnightChildActor::NormalCloakQuery' has a wrong offset!");
static_assert(offsetof(AMoonKnightChildActor, GlideCloakQuery) == 0x000EB0, "Member 'AMoonKnightChildActor::GlideCloakQuery' has a wrong offset!");
static_assert(offsetof(AMoonKnightChildActor, NormalCloakSlot) == 0x000F00, "Member 'AMoonKnightChildActor::NormalCloakSlot' has a wrong offset!");
static_assert(offsetof(AMoonKnightChildActor, GlideCloakSlot) == 0x000F10, "Member 'AMoonKnightChildActor::GlideCloakSlot' has a wrong offset!");
static_assert(offsetof(AMoonKnightChildActor, ExtraMoonSkinIDs) == 0x000F20, "Member 'AMoonKnightChildActor::ExtraMoonSkinIDs' has a wrong offset!");

// Class Hero_1030.MoonKnightMoveLogicBaseComponent
// 0x0008 (0x0408 - 0x0400)
class UMoonKnightMoveLogicBaseComponent final : public UMarvelMoveLogicBaseComponent
{
public:
	uint8                                         Pad_400[0x8];                                      // 0x0400(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BlockASDInputMovment(uint8 BlockInput);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoonKnightMoveLogicBaseComponent">();
	}
	static class UMoonKnightMoveLogicBaseComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoonKnightMoveLogicBaseComponent>();
	}
};
static_assert(alignof(UMoonKnightMoveLogicBaseComponent) == 0x000008, "Wrong alignment on UMoonKnightMoveLogicBaseComponent");
static_assert(sizeof(UMoonKnightMoveLogicBaseComponent) == 0x000408, "Wrong size on UMoonKnightMoveLogicBaseComponent");

// Class Hero_1030.MoonKnightMovementComponent
// 0x0000 (0x2360 - 0x2360)
class UMoonKnightMovementComponent final : public UMarvelCharacterMovementComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoonKnightMovementComponent">();
	}
	static class UMoonKnightMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoonKnightMovementComponent>();
	}
};
static_assert(alignof(UMoonKnightMovementComponent) == 0x000010, "Wrong alignment on UMoonKnightMovementComponent");
static_assert(sizeof(UMoonKnightMovementComponent) == 0x002360, "Wrong size on UMoonKnightMovementComponent");

}

