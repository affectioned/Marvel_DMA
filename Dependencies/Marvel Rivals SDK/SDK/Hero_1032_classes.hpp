#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Hero_1032

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "Marvel_structs.hpp"
#include "Marvel_classes.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "GameplayAbilities_structs.hpp"


namespace SDK
{

// Class Hero_1032.Config_103221
// 0x1698 (0x1730 - 0x0098)
class UConfig_103221 : public UMarvelAbilityConfig
{
public:
	class UCurveFloat*                            ChargeCurve;                                       // 0x0098(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMarvelAbilityTraceContext             TraceContext;                                      // 0x00A0(0x1660)(Edit, BlueprintVisible, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<EObjectTypeQuery>                      TraceObjectType;                                   // 0x1700(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         TraceDistance;                                     // 0x1710(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1714[0x4];                                     // 0x1714(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class AActor>>             ActorClassToIgnore;                                // 0x1718(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	bool                                          bIsBound;                                          // 0x1728(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseFastPathPredict;                               // 0x1729(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_172A[0x2];                                     // 0x172A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FastPathPredictTolerance;                          // 0x172C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_103221">();
	}
	static class UConfig_103221* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_103221>();
	}
};
static_assert(alignof(UConfig_103221) == 0x000010, "Wrong alignment on UConfig_103221");
static_assert(sizeof(UConfig_103221) == 0x001730, "Wrong size on UConfig_103221");
static_assert(offsetof(UConfig_103221, ChargeCurve) == 0x000098, "Member 'UConfig_103221::ChargeCurve' has a wrong offset!");
static_assert(offsetof(UConfig_103221, TraceContext) == 0x0000A0, "Member 'UConfig_103221::TraceContext' has a wrong offset!");
static_assert(offsetof(UConfig_103221, TraceObjectType) == 0x001700, "Member 'UConfig_103221::TraceObjectType' has a wrong offset!");
static_assert(offsetof(UConfig_103221, TraceDistance) == 0x001710, "Member 'UConfig_103221::TraceDistance' has a wrong offset!");
static_assert(offsetof(UConfig_103221, ActorClassToIgnore) == 0x001718, "Member 'UConfig_103221::ActorClassToIgnore' has a wrong offset!");
static_assert(offsetof(UConfig_103221, bIsBound) == 0x001728, "Member 'UConfig_103221::bIsBound' has a wrong offset!");
static_assert(offsetof(UConfig_103221, bUseFastPathPredict) == 0x001729, "Member 'UConfig_103221::bUseFastPathPredict' has a wrong offset!");
static_assert(offsetof(UConfig_103221, FastPathPredictTolerance) == 0x00172C, "Member 'UConfig_103221::FastPathPredictTolerance' has a wrong offset!");

// Class Hero_1032.Ability_103221
// 0x0000 (0x29F0 - 0x29F0)
class UAbility_103221 : public UMarvelGameplayAbility
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_103221">();
	}
	static class UAbility_103221* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_103221>();
	}
};
static_assert(alignof(UAbility_103221) == 0x000008, "Wrong alignment on UAbility_103221");
static_assert(sizeof(UAbility_103221) == 0x0029F0, "Wrong size on UAbility_103221");

// Class Hero_1032.Cue_Ability_Loop_10322103
// 0x10B0 (0x2260 - 0x11B0)
class ACue_Ability_Loop_10322103 : public AMarvelCueNotify_Ability
{
public:
	class UMarvelSplineComponent*                 SplineComponent;                                   // 0x11B0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            TailStaticMesh;                                    // 0x11B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            BodyStaticMesh;                                    // 0x11C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            HeadStaticMesh;                                    // 0x11C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class USplineMeshComponent*>           SplineMeshCollection;                              // 0x11D0(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	int32                                         MaxNumOfSplineMeshUsed;                            // 0x11E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11E4[0x4];                                     // 0x11E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMarvelProjectileAgentTable            ProjectileDate;                                    // 0x11E8(0x1068)(NativeAccessSpecifierPublic)
	class ASquirrelGirlCharacter*                 OwnCharacter;                                      // 0x2250(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2258[0x8];                                     // 0x2258(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Ability_Loop_10322103">();
	}
	static class ACue_Ability_Loop_10322103* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Ability_Loop_10322103>();
	}
};
static_assert(alignof(ACue_Ability_Loop_10322103) == 0x000010, "Wrong alignment on ACue_Ability_Loop_10322103");
static_assert(sizeof(ACue_Ability_Loop_10322103) == 0x002260, "Wrong size on ACue_Ability_Loop_10322103");
static_assert(offsetof(ACue_Ability_Loop_10322103, SplineComponent) == 0x0011B0, "Member 'ACue_Ability_Loop_10322103::SplineComponent' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10322103, TailStaticMesh) == 0x0011B8, "Member 'ACue_Ability_Loop_10322103::TailStaticMesh' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10322103, BodyStaticMesh) == 0x0011C0, "Member 'ACue_Ability_Loop_10322103::BodyStaticMesh' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10322103, HeadStaticMesh) == 0x0011C8, "Member 'ACue_Ability_Loop_10322103::HeadStaticMesh' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10322103, SplineMeshCollection) == 0x0011D0, "Member 'ACue_Ability_Loop_10322103::SplineMeshCollection' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10322103, MaxNumOfSplineMeshUsed) == 0x0011E0, "Member 'ACue_Ability_Loop_10322103::MaxNumOfSplineMeshUsed' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10322103, ProjectileDate) == 0x0011E8, "Member 'ACue_Ability_Loop_10322103::ProjectileDate' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10322103, OwnCharacter) == 0x002250, "Member 'ACue_Ability_Loop_10322103::OwnCharacter' has a wrong offset!");

// Class Hero_1032.103221MovableSplineMeshComponent
// 0x0000 (0x0A00 - 0x0A00)
class UOne03221MovableSplineMeshComponent final : public USplineMeshComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"103221MovableSplineMeshComponent">();
	}
	static class UOne03221MovableSplineMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOne03221MovableSplineMeshComponent>();
	}
};
static_assert(alignof(UOne03221MovableSplineMeshComponent) == 0x000010, "Wrong alignment on UOne03221MovableSplineMeshComponent");
static_assert(sizeof(UOne03221MovableSplineMeshComponent) == 0x000A00, "Wrong size on UOne03221MovableSplineMeshComponent");

// Class Hero_1032.SummonedMovementComponent_10324101
// 0x0010 (0x0BA0 - 0x0B90)
class USummonedMovementComponent_10324101 final : public USummonedMovementComponent
{
public:
	TMulticastInlineDelegate<void(class AActor* Value)> OnSquirrelAttachDelegate;                    // 0x0B90(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SummonedMovementComponent_10324101">();
	}
	static class USummonedMovementComponent_10324101* GetDefaultObj()
	{
		return GetDefaultObjImpl<USummonedMovementComponent_10324101>();
	}
};
static_assert(alignof(USummonedMovementComponent_10324101) == 0x000010, "Wrong alignment on USummonedMovementComponent_10324101");
static_assert(sizeof(USummonedMovementComponent_10324101) == 0x000BA0, "Wrong size on USummonedMovementComponent_10324101");
static_assert(offsetof(USummonedMovementComponent_10324101, OnSquirrelAttachDelegate) == 0x000B90, "Member 'USummonedMovementComponent_10324101::OnSquirrelAttachDelegate' has a wrong offset!");

// Class Hero_1032.Summoned_10324101
// 0x0010 (0x0C20 - 0x0C10)
class ASummoned_10324101 final : public AMarvelTraceableSummoner
{
public:
	class USummonedMovementComponent*             SummonedMovement_10324101;                         // 0x0C10(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C18[0x8];                                      // 0x0C18(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Summoned_10324101">();
	}
	static class ASummoned_10324101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASummoned_10324101>();
	}
};
static_assert(alignof(ASummoned_10324101) == 0x000010, "Wrong alignment on ASummoned_10324101");
static_assert(sizeof(ASummoned_10324101) == 0x000C20, "Wrong size on ASummoned_10324101");
static_assert(offsetof(ASummoned_10324101, SummonedMovement_10324101) == 0x000C10, "Member 'ASummoned_10324101::SummonedMovement_10324101' has a wrong offset!");

// Class Hero_1032.Summoned_V2_10325101
// 0x0450 (0x1890 - 0x1440)
class ASummoned_V2_10325101 : public ASummonedCharacterBase
{
public:
	struct FVector                                CachedForward;                                     // 0x1438(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsActorHit;                                       // 0x1450(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsEndFlying;                                      // 0x1451(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1452[0x6];                                     // 0x1452(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UCharacterMovementComponent*            Movement;                                          // 0x1458(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                ForwardVector;                                     // 0x1460(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UConfig_103251*                         AbilityConfig;                                     // 0x1478(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayCueParameters                 Parameter;                                         // 0x1480(0x01D0)(ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FHitResult                             HitPoint;                                          // 0x1650(0x01F0)(ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FTimerHandle                           SetModeHandle;                                     // 0x1840(0x0018)(Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                LastHitPosition;                                   // 0x1858(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1870[0x20];                                    // 0x1870(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UConfig_103251* GetAbilityConfig();
	bool IsWallClimbing(const struct FHitResult& Hit);
	void MovementModeChange(class ACharacter* Character, EMovementMode PrevMovementMode, uint8 PreviousCustomMode);
	void OnSquirrelHit(class AActor* SelfActor, class AActor* OtherActor, const struct FVector& NormalImpulse, const struct FHitResult& Hit);
	void OnSummonedKillOther(class AActor* InSourceAvatar, class AActor* InTargetAvatar, const struct FAttributeModifierHandle& ModifierParameterHandle);
	void SetActorRotationOnForwardVectorChange();
	void SetMovementModeAndSmoothingMode();
	void SquirrelClimbingWall(const struct FHitResult& Hit);
	void SquirrelTurn(const struct FHitResult& Hit, float Angle, float ForceTurn);
	void SquirrelTurnInternal(const struct FHitResult& Hit, const struct FVector& Vector);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Summoned_V2_10325101">();
	}
	static class ASummoned_V2_10325101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASummoned_V2_10325101>();
	}
};
static_assert(alignof(ASummoned_V2_10325101) == 0x000010, "Wrong alignment on ASummoned_V2_10325101");
static_assert(sizeof(ASummoned_V2_10325101) == 0x001890, "Wrong size on ASummoned_V2_10325101");
static_assert(offsetof(ASummoned_V2_10325101, CachedForward) == 0x001438, "Member 'ASummoned_V2_10325101::CachedForward' has a wrong offset!");
static_assert(offsetof(ASummoned_V2_10325101, bIsActorHit) == 0x001450, "Member 'ASummoned_V2_10325101::bIsActorHit' has a wrong offset!");
static_assert(offsetof(ASummoned_V2_10325101, bIsEndFlying) == 0x001451, "Member 'ASummoned_V2_10325101::bIsEndFlying' has a wrong offset!");
static_assert(offsetof(ASummoned_V2_10325101, Movement) == 0x001458, "Member 'ASummoned_V2_10325101::Movement' has a wrong offset!");
static_assert(offsetof(ASummoned_V2_10325101, ForwardVector) == 0x001460, "Member 'ASummoned_V2_10325101::ForwardVector' has a wrong offset!");
static_assert(offsetof(ASummoned_V2_10325101, AbilityConfig) == 0x001478, "Member 'ASummoned_V2_10325101::AbilityConfig' has a wrong offset!");
static_assert(offsetof(ASummoned_V2_10325101, Parameter) == 0x001480, "Member 'ASummoned_V2_10325101::Parameter' has a wrong offset!");
static_assert(offsetof(ASummoned_V2_10325101, HitPoint) == 0x001650, "Member 'ASummoned_V2_10325101::HitPoint' has a wrong offset!");
static_assert(offsetof(ASummoned_V2_10325101, SetModeHandle) == 0x001840, "Member 'ASummoned_V2_10325101::SetModeHandle' has a wrong offset!");
static_assert(offsetof(ASummoned_V2_10325101, LastHitPosition) == 0x001858, "Member 'ASummoned_V2_10325101::LastHitPosition' has a wrong offset!");

// Class Hero_1032.SummonedComp_10325101
// 0x0000 (0x0DB0 - 0x0DB0)
class USummonedComp_10325101 final : public UMarvelSummonedComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SummonedComp_10325101">();
	}
	static class USummonedComp_10325101* GetDefaultObj()
	{
		return GetDefaultObjImpl<USummonedComp_10325101>();
	}
};
static_assert(alignof(USummonedComp_10325101) == 0x000008, "Wrong alignment on USummonedComp_10325101");
static_assert(sizeof(USummonedComp_10325101) == 0x000DB0, "Wrong size on USummonedComp_10325101");

// Class Hero_1032.Config_103251
// 0x4738 (0x47D0 - 0x0098)
class UConfig_103251 final : public UMarvelAbilityConfig
{
public:
	uint8                                         Pad_98[0x8];                                       // 0x0098(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMarvelAbilityTraceContext             TraceContext;                                      // 0x00A0(0x1660)(Edit, BlueprintVisible, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FMarvelAbilityTraceContext             TraceContextSphere;                                // 0x1700(0x1660)(Edit, BlueprintVisible, ContainsInstancedReference, NativeAccessSpecifierPublic)
	int32                                         ClimbWallHeight;                                   // 0x2D60(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExtensionDistance;                                 // 0x2D64(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InitWalkSpeed;                                     // 0x2D68(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxWalkSpeed;                                      // 0x2D6C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DelayTime;                                         // 0x2D70(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D74[0x4];                                     // 0x2D74(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMarvelTraceRule                       TraceRule;                                         // 0x2D78(0x0398)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FVector                                SpawnOffset;                                       // 0x3110(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SphereRadius;                                      // 0x3128(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_312C[0x4];                                     // 0x312C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EObjectTypeQuery>                      TraceObjectType;                                   // 0x3130(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FVector                                InitLocationOffset;                                // 0x3140(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTurnAfterTrace;                                   // 0x3158(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3159[0x7];                                     // 0x3159(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMarvelAbilityTraceContext             TurnTraceContext;                                  // 0x3160(0x1660)(Edit, BlueprintVisible, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         TurnTraceMinAngle;                                 // 0x47C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnTraceMinDistance;                              // 0x47C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_47C8[0x8];                                     // 0x47C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_103251">();
	}
	static class UConfig_103251* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_103251>();
	}
};
static_assert(alignof(UConfig_103251) == 0x000010, "Wrong alignment on UConfig_103251");
static_assert(sizeof(UConfig_103251) == 0x0047D0, "Wrong size on UConfig_103251");
static_assert(offsetof(UConfig_103251, TraceContext) == 0x0000A0, "Member 'UConfig_103251::TraceContext' has a wrong offset!");
static_assert(offsetof(UConfig_103251, TraceContextSphere) == 0x001700, "Member 'UConfig_103251::TraceContextSphere' has a wrong offset!");
static_assert(offsetof(UConfig_103251, ClimbWallHeight) == 0x002D60, "Member 'UConfig_103251::ClimbWallHeight' has a wrong offset!");
static_assert(offsetof(UConfig_103251, ExtensionDistance) == 0x002D64, "Member 'UConfig_103251::ExtensionDistance' has a wrong offset!");
static_assert(offsetof(UConfig_103251, InitWalkSpeed) == 0x002D68, "Member 'UConfig_103251::InitWalkSpeed' has a wrong offset!");
static_assert(offsetof(UConfig_103251, MaxWalkSpeed) == 0x002D6C, "Member 'UConfig_103251::MaxWalkSpeed' has a wrong offset!");
static_assert(offsetof(UConfig_103251, DelayTime) == 0x002D70, "Member 'UConfig_103251::DelayTime' has a wrong offset!");
static_assert(offsetof(UConfig_103251, TraceRule) == 0x002D78, "Member 'UConfig_103251::TraceRule' has a wrong offset!");
static_assert(offsetof(UConfig_103251, SpawnOffset) == 0x003110, "Member 'UConfig_103251::SpawnOffset' has a wrong offset!");
static_assert(offsetof(UConfig_103251, SphereRadius) == 0x003128, "Member 'UConfig_103251::SphereRadius' has a wrong offset!");
static_assert(offsetof(UConfig_103251, TraceObjectType) == 0x003130, "Member 'UConfig_103251::TraceObjectType' has a wrong offset!");
static_assert(offsetof(UConfig_103251, InitLocationOffset) == 0x003140, "Member 'UConfig_103251::InitLocationOffset' has a wrong offset!");
static_assert(offsetof(UConfig_103251, bTurnAfterTrace) == 0x003158, "Member 'UConfig_103251::bTurnAfterTrace' has a wrong offset!");
static_assert(offsetof(UConfig_103251, TurnTraceContext) == 0x003160, "Member 'UConfig_103251::TurnTraceContext' has a wrong offset!");
static_assert(offsetof(UConfig_103251, TurnTraceMinAngle) == 0x0047C0, "Member 'UConfig_103251::TurnTraceMinAngle' has a wrong offset!");
static_assert(offsetof(UConfig_103251, TurnTraceMinDistance) == 0x0047C4, "Member 'UConfig_103251::TurnTraceMinDistance' has a wrong offset!");

// Class Hero_1032.Ability_103251
// 0x02E0 (0x2CD0 - 0x29F0)
class UAbility_103251 : public UMarvelGameplayAbility
{
public:
	class UMarvelAbilityTask_PlayMontageAndWaitForEvent* TimelineTask;                               // 0x29F0(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UConfig_103251*                         AbilityConfig;                                     // 0x29F8(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(bool Visible)>  OnUIControl;                                       // 0x2A00(0x0010)(ZeroConstructor, InstancedReference, Protected, NativeAccessSpecifierProtected)
	class UMarvelAbilityTask_WaitBindInput*       InputTaskCancel;                                   // 0x2A10(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMarvelAbilityTask_WaitBindInput*       InputTaskConfirm;                                  // 0x2A18(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayCueParameters                 Parameter;                                         // 0x2A20(0x01D0)(ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FPredictionKey                         WaitTaskConfirmKey;                                // 0x2BF0(0x0070)(Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FPredictionKey                         WaitTaskCancelKey;                                 // 0x2C60(0x0070)(Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnWaitTaskCancel_ThreadSafe(float TimeWaited);
	void OnWaitTaskConfirm(float TimeWaited);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_103251">();
	}
	static class UAbility_103251* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_103251>();
	}
};
static_assert(alignof(UAbility_103251) == 0x000008, "Wrong alignment on UAbility_103251");
static_assert(sizeof(UAbility_103251) == 0x002CD0, "Wrong size on UAbility_103251");
static_assert(offsetof(UAbility_103251, TimelineTask) == 0x0029F0, "Member 'UAbility_103251::TimelineTask' has a wrong offset!");
static_assert(offsetof(UAbility_103251, AbilityConfig) == 0x0029F8, "Member 'UAbility_103251::AbilityConfig' has a wrong offset!");
static_assert(offsetof(UAbility_103251, OnUIControl) == 0x002A00, "Member 'UAbility_103251::OnUIControl' has a wrong offset!");
static_assert(offsetof(UAbility_103251, InputTaskCancel) == 0x002A10, "Member 'UAbility_103251::InputTaskCancel' has a wrong offset!");
static_assert(offsetof(UAbility_103251, InputTaskConfirm) == 0x002A18, "Member 'UAbility_103251::InputTaskConfirm' has a wrong offset!");
static_assert(offsetof(UAbility_103251, Parameter) == 0x002A20, "Member 'UAbility_103251::Parameter' has a wrong offset!");
static_assert(offsetof(UAbility_103251, WaitTaskConfirmKey) == 0x002BF0, "Member 'UAbility_103251::WaitTaskConfirmKey' has a wrong offset!");
static_assert(offsetof(UAbility_103251, WaitTaskCancelKey) == 0x002C60, "Member 'UAbility_103251::WaitTaskCancelKey' has a wrong offset!");

// Class Hero_1032.Cue_Buff_Loop_10328101
// 0x0070 (0x16B0 - 0x1640)
class ACue_Buff_Loop_10328101 final : public AMarvelCueNotify_Buff
{
public:
	float                                         FlightDuration;                                    // 0x1638(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   SpawnSocket;                                       // 0x163C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   SquirrelSocket;                                    // 0x1648(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FlightTimer;                                       // 0x1654(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                StartLoc;                                          // 0x1658(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1670[0x30];                                    // 0x1670(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 Mesh;                                              // 0x16A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_16A8[0x8];                                     // 0x16A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnBuffOwnerDeath(class AActor* InSourceAvatar, class AActor* InTargetAvatar, const struct FAttributeModifierHandle& ModifierParameterHandle);
	void OnBuffOwnerReborn(class AActor* InSourceActor, const struct FCharacterRebornParam& RebornParam);
	void OnGameplayTagUpdate(const struct FGameplayTag& Tag, bool TagExists);
	void SetMeshHidden();
	void UpdateSquirrelTransform();

	void SetAnimPlaying(bool bIsPlaying) const;
	void SetMontageSection(class FName SectionName) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Buff_Loop_10328101">();
	}
	static class ACue_Buff_Loop_10328101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Buff_Loop_10328101>();
	}
};
static_assert(alignof(ACue_Buff_Loop_10328101) == 0x000010, "Wrong alignment on ACue_Buff_Loop_10328101");
static_assert(sizeof(ACue_Buff_Loop_10328101) == 0x0016B0, "Wrong size on ACue_Buff_Loop_10328101");
static_assert(offsetof(ACue_Buff_Loop_10328101, FlightDuration) == 0x001638, "Member 'ACue_Buff_Loop_10328101::FlightDuration' has a wrong offset!");
static_assert(offsetof(ACue_Buff_Loop_10328101, SpawnSocket) == 0x00163C, "Member 'ACue_Buff_Loop_10328101::SpawnSocket' has a wrong offset!");
static_assert(offsetof(ACue_Buff_Loop_10328101, SquirrelSocket) == 0x001648, "Member 'ACue_Buff_Loop_10328101::SquirrelSocket' has a wrong offset!");
static_assert(offsetof(ACue_Buff_Loop_10328101, FlightTimer) == 0x001654, "Member 'ACue_Buff_Loop_10328101::FlightTimer' has a wrong offset!");
static_assert(offsetof(ACue_Buff_Loop_10328101, StartLoc) == 0x001658, "Member 'ACue_Buff_Loop_10328101::StartLoc' has a wrong offset!");
static_assert(offsetof(ACue_Buff_Loop_10328101, Mesh) == 0x0016A0, "Member 'ACue_Buff_Loop_10328101::Mesh' has a wrong offset!");

// Class Hero_1032.EpicMomentAction_1032
// 0x0018 (0x0138 - 0x0120)
class UEpicMomentAction_1032 : public UEpicMomentBaseAction
{
public:
	struct FEpicMomentNodeInfo                    ControlConfig;                                     // 0x0120(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         ControlBuffID;                                     // 0x012C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         QSummonerID;                                       // 0x0130(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_134[0x4];                                      // 0x0134(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnGameplayEffectAppliedToTarget(class UAbilitySystemComponent* ASC, const struct FGameplayEffectSpecStackHandle& GameplayEffectSpecHandle, const struct FActiveGameplayEffectHandle& ActiveGameplayEffectHandle);
	void OnSummonerBegin(class AActor* SourceActor, class UMarvelGameplayAbility* SourceAbility, class AActor* Summoned, const struct FMarvelTargetActorGenerateInfo& GenerateInfo);
	void OnSummonerEnd(class AActor* InActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EpicMomentAction_1032">();
	}
	static class UEpicMomentAction_1032* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEpicMomentAction_1032>();
	}
};
static_assert(alignof(UEpicMomentAction_1032) == 0x000008, "Wrong alignment on UEpicMomentAction_1032");
static_assert(sizeof(UEpicMomentAction_1032) == 0x000138, "Wrong size on UEpicMomentAction_1032");
static_assert(offsetof(UEpicMomentAction_1032, ControlConfig) == 0x000120, "Member 'UEpicMomentAction_1032::ControlConfig' has a wrong offset!");
static_assert(offsetof(UEpicMomentAction_1032, ControlBuffID) == 0x00012C, "Member 'UEpicMomentAction_1032::ControlBuffID' has a wrong offset!");
static_assert(offsetof(UEpicMomentAction_1032, QSummonerID) == 0x000130, "Member 'UEpicMomentAction_1032::QSummonerID' has a wrong offset!");

// Class Hero_1032.SquirrelGirlAnimInstance
// 0x0090 (0x0AB0 - 0x0A20)
class USquirrelGirlAnimInstance : public UMarvelAnimInstance
{
public:
	float                                         InterpolationSpeed;                                // 0x0A20(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A24[0x4];                                      // 0x0A24(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            LandBlendCurve;                                    // 0x0A28(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MaskLandBlendFactorCurveName;                      // 0x0A30(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A3C[0x4];                                      // 0x0A3C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                StartVelocity;                                     // 0x0A40(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsFalling;                                         // 0x0A58(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsLandStop;                                        // 0x0A59(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsJumping;                                         // 0x0A5A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsDead;                                            // 0x0A5B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LandBlendFactor;                                   // 0x0A5C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bJumpFallingToLand;                                // 0x0A60(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A61[0x4F];                                     // 0x0A61(0x004F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SquirrelGirlAnimInstance">();
	}
	static class USquirrelGirlAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<USquirrelGirlAnimInstance>();
	}
};
static_assert(alignof(USquirrelGirlAnimInstance) == 0x000010, "Wrong alignment on USquirrelGirlAnimInstance");
static_assert(sizeof(USquirrelGirlAnimInstance) == 0x000AB0, "Wrong size on USquirrelGirlAnimInstance");
static_assert(offsetof(USquirrelGirlAnimInstance, InterpolationSpeed) == 0x000A20, "Member 'USquirrelGirlAnimInstance::InterpolationSpeed' has a wrong offset!");
static_assert(offsetof(USquirrelGirlAnimInstance, LandBlendCurve) == 0x000A28, "Member 'USquirrelGirlAnimInstance::LandBlendCurve' has a wrong offset!");
static_assert(offsetof(USquirrelGirlAnimInstance, MaskLandBlendFactorCurveName) == 0x000A30, "Member 'USquirrelGirlAnimInstance::MaskLandBlendFactorCurveName' has a wrong offset!");
static_assert(offsetof(USquirrelGirlAnimInstance, StartVelocity) == 0x000A40, "Member 'USquirrelGirlAnimInstance::StartVelocity' has a wrong offset!");
static_assert(offsetof(USquirrelGirlAnimInstance, IsFalling) == 0x000A58, "Member 'USquirrelGirlAnimInstance::IsFalling' has a wrong offset!");
static_assert(offsetof(USquirrelGirlAnimInstance, IsLandStop) == 0x000A59, "Member 'USquirrelGirlAnimInstance::IsLandStop' has a wrong offset!");
static_assert(offsetof(USquirrelGirlAnimInstance, IsJumping) == 0x000A5A, "Member 'USquirrelGirlAnimInstance::IsJumping' has a wrong offset!");
static_assert(offsetof(USquirrelGirlAnimInstance, IsDead) == 0x000A5B, "Member 'USquirrelGirlAnimInstance::IsDead' has a wrong offset!");
static_assert(offsetof(USquirrelGirlAnimInstance, LandBlendFactor) == 0x000A5C, "Member 'USquirrelGirlAnimInstance::LandBlendFactor' has a wrong offset!");
static_assert(offsetof(USquirrelGirlAnimInstance, bJumpFallingToLand) == 0x000A60, "Member 'USquirrelGirlAnimInstance::bJumpFallingToLand' has a wrong offset!");

// Class Hero_1032.TippyToeAnimInstance
// 0x0050 (0x0B00 - 0x0AB0)
class UTippyToeAnimInstance final : public USquirrelGirlAnimInstance
{
public:
	TArray<class UAnimMontage*>                   AnimMontages;                                      // 0x0AB0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         AbilityIDList;                                     // 0x0AC0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         ShiftAbilityIDList;                                // 0x0AD0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         LoopAbilityIDList;                                 // 0x0AE0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         HitDirection;                                      // 0x0AF0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_AF4[0x4];                                      // 0x0AF4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           CurrentMontage;                                    // 0x0AF8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void AbilityMontageBlendingOut(class UAnimMontage* Montage, bool bInterrupted);
	void AbilityMontageStarted(class UAnimMontage* Montage);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TippyToeAnimInstance">();
	}
	static class UTippyToeAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTippyToeAnimInstance>();
	}
};
static_assert(alignof(UTippyToeAnimInstance) == 0x000010, "Wrong alignment on UTippyToeAnimInstance");
static_assert(sizeof(UTippyToeAnimInstance) == 0x000B00, "Wrong size on UTippyToeAnimInstance");
static_assert(offsetof(UTippyToeAnimInstance, AnimMontages) == 0x000AB0, "Member 'UTippyToeAnimInstance::AnimMontages' has a wrong offset!");
static_assert(offsetof(UTippyToeAnimInstance, AbilityIDList) == 0x000AC0, "Member 'UTippyToeAnimInstance::AbilityIDList' has a wrong offset!");
static_assert(offsetof(UTippyToeAnimInstance, ShiftAbilityIDList) == 0x000AD0, "Member 'UTippyToeAnimInstance::ShiftAbilityIDList' has a wrong offset!");
static_assert(offsetof(UTippyToeAnimInstance, LoopAbilityIDList) == 0x000AE0, "Member 'UTippyToeAnimInstance::LoopAbilityIDList' has a wrong offset!");
static_assert(offsetof(UTippyToeAnimInstance, HitDirection) == 0x000AF0, "Member 'UTippyToeAnimInstance::HitDirection' has a wrong offset!");
static_assert(offsetof(UTippyToeAnimInstance, CurrentMontage) == 0x000AF8, "Member 'UTippyToeAnimInstance::CurrentMontage' has a wrong offset!");

// Class Hero_1032.SquirrelGirlCharacter
// 0x0020 (0x21C0 - 0x21A0)
class ASquirrelGirlCharacter : public AMarvelBaseCharacter
{
public:
	bool                                          bIsShiftJumping;                                   // 0x21A0(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21A1[0x7];                                     // 0x21A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 TempInstigator;                                    // 0x21A8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USquirrelGirlMoveLogicBaseComponent*    SquirrelGirlMoveLogic;                             // 0x21B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_21B8[0x8];                                     // 0x21B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetSquirrelGirlJump(bool NewState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SquirrelGirlCharacter">();
	}
	static class ASquirrelGirlCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASquirrelGirlCharacter>();
	}
};
static_assert(alignof(ASquirrelGirlCharacter) == 0x000010, "Wrong alignment on ASquirrelGirlCharacter");
static_assert(sizeof(ASquirrelGirlCharacter) == 0x0021C0, "Wrong size on ASquirrelGirlCharacter");
static_assert(offsetof(ASquirrelGirlCharacter, bIsShiftJumping) == 0x0021A0, "Member 'ASquirrelGirlCharacter::bIsShiftJumping' has a wrong offset!");
static_assert(offsetof(ASquirrelGirlCharacter, TempInstigator) == 0x0021A8, "Member 'ASquirrelGirlCharacter::TempInstigator' has a wrong offset!");
static_assert(offsetof(ASquirrelGirlCharacter, SquirrelGirlMoveLogic) == 0x0021B0, "Member 'ASquirrelGirlCharacter::SquirrelGirlMoveLogic' has a wrong offset!");

// Class Hero_1032.SquirrelGirlChildActor
// 0x0050 (0x0E70 - 0x0E20)
class ASquirrelGirlChildActor final : public AMarvelCharacterChildActor
{
public:
	class UPhysicalAnimationComponent*            PhysicalAnimation;                                 // 0x0E18(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BoneName1;                                         // 0x0E20(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BoneName2;                                         // 0x0E2C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PhysicsBlendWeight1;                               // 0x0E38(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PhysicsBlendWeight2;                               // 0x0E3C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TippyToeName;                                      // 0x0E40(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPhysicsAsset*                          TippyToePhysicsAssetOnDeath;                       // 0x0E50(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPhysicsAsset*                          TippyToePhysicsAssetOnReborn;                      // 0x0E58(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E60[0x10];                                     // 0x0E60(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DeactivatePhysicalAnimation(bool bNeedPhysics, class FName InBoneName1, class FName InBoneName2);
	void SetPhysicalAnimation(class FName InBoneName1, float InPhysicsBlendWeight1, class FName InBoneName2, float PhysicsBlendWeight2_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SquirrelGirlChildActor">();
	}
	static class ASquirrelGirlChildActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASquirrelGirlChildActor>();
	}
};
static_assert(alignof(ASquirrelGirlChildActor) == 0x000010, "Wrong alignment on ASquirrelGirlChildActor");
static_assert(sizeof(ASquirrelGirlChildActor) == 0x000E70, "Wrong size on ASquirrelGirlChildActor");
static_assert(offsetof(ASquirrelGirlChildActor, PhysicalAnimation) == 0x000E18, "Member 'ASquirrelGirlChildActor::PhysicalAnimation' has a wrong offset!");
static_assert(offsetof(ASquirrelGirlChildActor, BoneName1) == 0x000E20, "Member 'ASquirrelGirlChildActor::BoneName1' has a wrong offset!");
static_assert(offsetof(ASquirrelGirlChildActor, BoneName2) == 0x000E2C, "Member 'ASquirrelGirlChildActor::BoneName2' has a wrong offset!");
static_assert(offsetof(ASquirrelGirlChildActor, PhysicsBlendWeight1) == 0x000E38, "Member 'ASquirrelGirlChildActor::PhysicsBlendWeight1' has a wrong offset!");
static_assert(offsetof(ASquirrelGirlChildActor, PhysicsBlendWeight2) == 0x000E3C, "Member 'ASquirrelGirlChildActor::PhysicsBlendWeight2' has a wrong offset!");
static_assert(offsetof(ASquirrelGirlChildActor, TippyToeName) == 0x000E40, "Member 'ASquirrelGirlChildActor::TippyToeName' has a wrong offset!");
static_assert(offsetof(ASquirrelGirlChildActor, TippyToePhysicsAssetOnDeath) == 0x000E50, "Member 'ASquirrelGirlChildActor::TippyToePhysicsAssetOnDeath' has a wrong offset!");
static_assert(offsetof(ASquirrelGirlChildActor, TippyToePhysicsAssetOnReborn) == 0x000E58, "Member 'ASquirrelGirlChildActor::TippyToePhysicsAssetOnReborn' has a wrong offset!");

// Class Hero_1032.SquirrelGirlMoveLogicBaseComponent
// 0x0000 (0x0400 - 0x0400)
class USquirrelGirlMoveLogicBaseComponent final : public UMarvelMoveLogicBaseComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SquirrelGirlMoveLogicBaseComponent">();
	}
	static class USquirrelGirlMoveLogicBaseComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USquirrelGirlMoveLogicBaseComponent>();
	}
};
static_assert(alignof(USquirrelGirlMoveLogicBaseComponent) == 0x000008, "Wrong alignment on USquirrelGirlMoveLogicBaseComponent");
static_assert(sizeof(USquirrelGirlMoveLogicBaseComponent) == 0x000400, "Wrong size on USquirrelGirlMoveLogicBaseComponent");

// Class Hero_1032.SquirrelGirlMovementComponent
// 0x0000 (0x2360 - 0x2360)
class USquirrelGirlMovementComponent final : public UMarvelCharacterMovementComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SquirrelGirlMovementComponent">();
	}
	static class USquirrelGirlMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USquirrelGirlMovementComponent>();
	}
};
static_assert(alignof(USquirrelGirlMovementComponent) == 0x000010, "Wrong alignment on USquirrelGirlMovementComponent");
static_assert(sizeof(USquirrelGirlMovementComponent) == 0x002360, "Wrong size on USquirrelGirlMovementComponent");

}

