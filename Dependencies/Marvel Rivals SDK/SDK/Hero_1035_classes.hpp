#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Hero_1035

#include "Basic.hpp"

#include "DeclarativeUnreal_structs.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "Hero_1035_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "Marvel_structs.hpp"
#include "Marvel_classes.hpp"
#include "GameplayTags_structs.hpp"
#include "Niagara_classes.hpp"
#include "GameplayAbilities_structs.hpp"


namespace SDK
{

// Class Hero_1035.Config_103521
// 0x0050 (0x00E8 - 0x0098)
class UConfig_103521 final : public UMarvelAbilityConfig
{
public:
	class FName                                   ActivateTentaclePreName;                           // 0x0098(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ScopeID;                                           // 0x00A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TraceStartSocketName;                              // 0x00A8(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TraceEndSocketName;                                // 0x00B4(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TraceDistance;                                     // 0x00C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C4[0x4];                                       // 0x00C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVenomTentacleInfo>             TentacleInfos;                                     // 0x00C8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         TraceDelayTime;                                    // 0x00D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTraceDebugDraw;                                   // 0x00DC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFramingUpdateTentacles;                           // 0x00DD(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DE[0x2];                                       // 0x00DE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxFramingUpdateDeltaTime;                         // 0x00E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E4[0x4];                                       // 0x00E4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_103521">();
	}
	static class UConfig_103521* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_103521>();
	}
};
static_assert(alignof(UConfig_103521) == 0x000008, "Wrong alignment on UConfig_103521");
static_assert(sizeof(UConfig_103521) == 0x0000E8, "Wrong size on UConfig_103521");
static_assert(offsetof(UConfig_103521, ActivateTentaclePreName) == 0x000098, "Member 'UConfig_103521::ActivateTentaclePreName' has a wrong offset!");
static_assert(offsetof(UConfig_103521, ScopeID) == 0x0000A4, "Member 'UConfig_103521::ScopeID' has a wrong offset!");
static_assert(offsetof(UConfig_103521, TraceStartSocketName) == 0x0000A8, "Member 'UConfig_103521::TraceStartSocketName' has a wrong offset!");
static_assert(offsetof(UConfig_103521, TraceEndSocketName) == 0x0000B4, "Member 'UConfig_103521::TraceEndSocketName' has a wrong offset!");
static_assert(offsetof(UConfig_103521, TraceDistance) == 0x0000C0, "Member 'UConfig_103521::TraceDistance' has a wrong offset!");
static_assert(offsetof(UConfig_103521, TentacleInfos) == 0x0000C8, "Member 'UConfig_103521::TentacleInfos' has a wrong offset!");
static_assert(offsetof(UConfig_103521, TraceDelayTime) == 0x0000D8, "Member 'UConfig_103521::TraceDelayTime' has a wrong offset!");
static_assert(offsetof(UConfig_103521, bTraceDebugDraw) == 0x0000DC, "Member 'UConfig_103521::bTraceDebugDraw' has a wrong offset!");
static_assert(offsetof(UConfig_103521, bFramingUpdateTentacles) == 0x0000DD, "Member 'UConfig_103521::bFramingUpdateTentacles' has a wrong offset!");
static_assert(offsetof(UConfig_103521, MaxFramingUpdateDeltaTime) == 0x0000E0, "Member 'UConfig_103521::MaxFramingUpdateDeltaTime' has a wrong offset!");

// Class Hero_1035.Ability_103521
// 0x0020 (0x2A18 - 0x29F8)
class UAbility_103521 : public UAbility_108
{
public:
	class UConfig_103521*                         AbilityConfig;                                     // 0x29F8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMarvelAbilityTask_WaitBindInput*       InputLeftTask;                                     // 0x2A00(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 CurrentIndex;                                      // 0x2A08(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)

public:
	void OnPressLeft(float TimeWaited);
	void OnReleaseLeft(float TimeWaited);
	void OnSpawnSuccess(class AActor* SpawnActor, const struct FGameplayAbilityTargetDataHandle& Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_103521">();
	}
	static class UAbility_103521* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_103521>();
	}
};
static_assert(alignof(UAbility_103521) == 0x000008, "Wrong alignment on UAbility_103521");
static_assert(sizeof(UAbility_103521) == 0x002A18, "Wrong size on UAbility_103521");
static_assert(offsetof(UAbility_103521, AbilityConfig) == 0x0029F8, "Member 'UAbility_103521::AbilityConfig' has a wrong offset!");
static_assert(offsetof(UAbility_103521, InputLeftTask) == 0x002A00, "Member 'UAbility_103521::InputLeftTask' has a wrong offset!");
static_assert(offsetof(UAbility_103521, CurrentIndex) == 0x002A08, "Member 'UAbility_103521::CurrentIndex' has a wrong offset!");

// Class Hero_1035.TentacleAnimInstance
// 0x0050 (0x04A0 - 0x0450)
class UTentacleAnimInstance final : public UAnimInstance
{
public:
	TArray<class UAnimSequence*>                  LoopSequences;                                     // 0x0448(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FVector                                TargetLocation;                                    // 0x0458(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BoneScale;                                         // 0x0470(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BoneName;                                          // 0x0474(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPauseMT;                                          // 0x0480(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_481[0x7];                                      // 0x0481(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          LoopSequence;                                      // 0x0488(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCheckPause;                                       // 0x0490(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_491[0xF];                                      // 0x0491(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TentacleAnimInstance">();
	}
	static class UTentacleAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTentacleAnimInstance>();
	}
};
static_assert(alignof(UTentacleAnimInstance) == 0x000010, "Wrong alignment on UTentacleAnimInstance");
static_assert(sizeof(UTentacleAnimInstance) == 0x0004A0, "Wrong size on UTentacleAnimInstance");
static_assert(offsetof(UTentacleAnimInstance, LoopSequences) == 0x000448, "Member 'UTentacleAnimInstance::LoopSequences' has a wrong offset!");
static_assert(offsetof(UTentacleAnimInstance, TargetLocation) == 0x000458, "Member 'UTentacleAnimInstance::TargetLocation' has a wrong offset!");
static_assert(offsetof(UTentacleAnimInstance, BoneScale) == 0x000470, "Member 'UTentacleAnimInstance::BoneScale' has a wrong offset!");
static_assert(offsetof(UTentacleAnimInstance, BoneName) == 0x000474, "Member 'UTentacleAnimInstance::BoneName' has a wrong offset!");
static_assert(offsetof(UTentacleAnimInstance, bPauseMT) == 0x000480, "Member 'UTentacleAnimInstance::bPauseMT' has a wrong offset!");
static_assert(offsetof(UTentacleAnimInstance, LoopSequence) == 0x000488, "Member 'UTentacleAnimInstance::LoopSequence' has a wrong offset!");
static_assert(offsetof(UTentacleAnimInstance, bCheckPause) == 0x000490, "Member 'UTentacleAnimInstance::bCheckPause' has a wrong offset!");

// Class Hero_1035.Scope_10352101
// 0x0270 (0x1D10 - 0x1AA0)
class AScope_10352101 final : public AMarvelAbilityTargetActor_Scope
{
public:
	int32                                         ScopeIndex;                                        // 0x1AA0(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1AA4[0x4];                                     // 0x1AA4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             ClientTraceResult;                                 // 0x1AA8(0x01F0)(Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FVector                                ClientImpulseTraceStart;                           // 0x1C98(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ClientImpulseTraceEnd;                             // 0x1CB0(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FHitResult>                     TracedResults;                                     // 0x1CC8(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UConfig_103521*                         AbilityConfig;                                     // 0x1CD8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1CE0[0x30];                                    // 0x1CE0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnDeactivateTentacle(int32 TentacleID);
	void ServerExecuteScopeNoActorClientImpulse(const struct FVector& InTraceStart, const struct FVector& InTraceEnd);
	void ServerSetTraceResult(const struct FHitResult& InTraceResult);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Scope_10352101">();
	}
	static class AScope_10352101* GetDefaultObj()
	{
		return GetDefaultObjImpl<AScope_10352101>();
	}
};
static_assert(alignof(AScope_10352101) == 0x000010, "Wrong alignment on AScope_10352101");
static_assert(sizeof(AScope_10352101) == 0x001D10, "Wrong size on AScope_10352101");
static_assert(offsetof(AScope_10352101, ScopeIndex) == 0x001AA0, "Member 'AScope_10352101::ScopeIndex' has a wrong offset!");
static_assert(offsetof(AScope_10352101, ClientTraceResult) == 0x001AA8, "Member 'AScope_10352101::ClientTraceResult' has a wrong offset!");
static_assert(offsetof(AScope_10352101, ClientImpulseTraceStart) == 0x001C98, "Member 'AScope_10352101::ClientImpulseTraceStart' has a wrong offset!");
static_assert(offsetof(AScope_10352101, ClientImpulseTraceEnd) == 0x001CB0, "Member 'AScope_10352101::ClientImpulseTraceEnd' has a wrong offset!");
static_assert(offsetof(AScope_10352101, TracedResults) == 0x001CC8, "Member 'AScope_10352101::TracedResults' has a wrong offset!");
static_assert(offsetof(AScope_10352101, AbilityConfig) == 0x001CD8, "Member 'AScope_10352101::AbilityConfig' has a wrong offset!");

// Class Hero_1035.MarvelGameplay_SphereTraceType_10352101
// 0x0000 (0x0030 - 0x0030)
class UMarvelGameplay_SphereTraceType_10352101 final : public UMarvelGameplay_SphereTraceType
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelGameplay_SphereTraceType_10352101">();
	}
	static class UMarvelGameplay_SphereTraceType_10352101* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMarvelGameplay_SphereTraceType_10352101>();
	}
};
static_assert(alignof(UMarvelGameplay_SphereTraceType_10352101) == 0x000008, "Wrong alignment on UMarvelGameplay_SphereTraceType_10352101");
static_assert(sizeof(UMarvelGameplay_SphereTraceType_10352101) == 0x000030, "Wrong size on UMarvelGameplay_SphereTraceType_10352101");

// Class Hero_1035.TraceComponent_10352101
// 0x0020 (0x2220 - 0x2200)
class UTraceComponent_10352101 final : public UMarvelAgentTraceComponent
{
public:
	uint8                                         Pad_2200[0x20];                                    // 0x2200(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TraceComponent_10352101">();
	}
	static class UTraceComponent_10352101* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTraceComponent_10352101>();
	}
};
static_assert(alignof(UTraceComponent_10352101) == 0x000010, "Wrong alignment on UTraceComponent_10352101");
static_assert(sizeof(UTraceComponent_10352101) == 0x002220, "Wrong size on UTraceComponent_10352101");

// Class Hero_1035.Config_103531
// 0x0050 (0x39E0 - 0x3990)
class UConfig_103531 final : public UAirdropAbilityConfig
{
public:
	int32                                         FXScopeID;                                         // 0x3988(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           DashCueTag;                                        // 0x398C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           CameraCueTag;                                      // 0x3998(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AddCueTag;                                         // 0x39A4(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           RemoveCueTag;                                      // 0x39B0(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           StartCameraInterpTag;                              // 0x39BC(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           EndCameraInterpTag;                                // 0x39C8(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39D4[0xC];                                     // 0x39D4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_103531">();
	}
	static class UConfig_103531* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_103531>();
	}
};
static_assert(alignof(UConfig_103531) == 0x000010, "Wrong alignment on UConfig_103531");
static_assert(sizeof(UConfig_103531) == 0x0039E0, "Wrong size on UConfig_103531");
static_assert(offsetof(UConfig_103531, FXScopeID) == 0x003988, "Member 'UConfig_103531::FXScopeID' has a wrong offset!");
static_assert(offsetof(UConfig_103531, DashCueTag) == 0x00398C, "Member 'UConfig_103531::DashCueTag' has a wrong offset!");
static_assert(offsetof(UConfig_103531, CameraCueTag) == 0x003998, "Member 'UConfig_103531::CameraCueTag' has a wrong offset!");
static_assert(offsetof(UConfig_103531, AddCueTag) == 0x0039A4, "Member 'UConfig_103531::AddCueTag' has a wrong offset!");
static_assert(offsetof(UConfig_103531, RemoveCueTag) == 0x0039B0, "Member 'UConfig_103531::RemoveCueTag' has a wrong offset!");
static_assert(offsetof(UConfig_103531, StartCameraInterpTag) == 0x0039BC, "Member 'UConfig_103531::StartCameraInterpTag' has a wrong offset!");
static_assert(offsetof(UConfig_103531, EndCameraInterpTag) == 0x0039C8, "Member 'UConfig_103531::EndCameraInterpTag' has a wrong offset!");

// Class Hero_1035.Ability_103531
// 0x01C8 (0x2E28 - 0x2C60)
class UAbility_103531 : public UMarvelAbility_Airdrop
{
public:
	class UConfig_103531*                         MyConfig;                                          // 0x2C60(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPredictionKey                         AddEffectPredictionKey;                            // 0x2C68(0x0070)(Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPredictionKey                         RemoveEffectPredictionKey;                         // 0x2CD8(0x0070)(Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPredictionKey                         CameraInterpPredictionKey;                         // 0x2D48(0x0070)(Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPredictionKey                         RemoveCameraInterpPredictionKey;                   // 0x2DB8(0x0070)(Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_103531">();
	}
	static class UAbility_103531* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_103531>();
	}
};
static_assert(alignof(UAbility_103531) == 0x000008, "Wrong alignment on UAbility_103531");
static_assert(sizeof(UAbility_103531) == 0x002E28, "Wrong size on UAbility_103531");
static_assert(offsetof(UAbility_103531, MyConfig) == 0x002C60, "Member 'UAbility_103531::MyConfig' has a wrong offset!");
static_assert(offsetof(UAbility_103531, AddEffectPredictionKey) == 0x002C68, "Member 'UAbility_103531::AddEffectPredictionKey' has a wrong offset!");
static_assert(offsetof(UAbility_103531, RemoveEffectPredictionKey) == 0x002CD8, "Member 'UAbility_103531::RemoveEffectPredictionKey' has a wrong offset!");
static_assert(offsetof(UAbility_103531, CameraInterpPredictionKey) == 0x002D48, "Member 'UAbility_103531::CameraInterpPredictionKey' has a wrong offset!");
static_assert(offsetof(UAbility_103531, RemoveCameraInterpPredictionKey) == 0x002DB8, "Member 'UAbility_103531::RemoveCameraInterpPredictionKey' has a wrong offset!");

// Class Hero_1035.Cue_Ability_Loop_10353102
// 0x0000 (0x11B0 - 0x11B0)
class ACue_Ability_Loop_10353102 final : public AMarvelCueNotify_Ability
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Ability_Loop_10353102">();
	}
	static class ACue_Ability_Loop_10353102* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Ability_Loop_10353102>();
	}
};
static_assert(alignof(ACue_Ability_Loop_10353102) == 0x000010, "Wrong alignment on ACue_Ability_Loop_10353102");
static_assert(sizeof(ACue_Ability_Loop_10353102) == 0x0011B0, "Wrong size on ACue_Ability_Loop_10353102");

// Class Hero_1035.Config_103541
// 0x16E8 (0x1780 - 0x0098)
class UConfig_103541 final : public UMarvelAbilityConfig
{
public:
	int32                                         ScopeID;                                           // 0x0098(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LinkBuffID;                                        // 0x009C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SlowBuffID;                                        // 0x00A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DamageBuffID;                                      // 0x00A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A8[0x8];                                       // 0x00A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMarvelAbilityTraceContext             TraceContext;                                      // 0x00B0(0x1660)(Edit, BlueprintVisible, BlueprintReadOnly, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         LinkTime;                                          // 0x1710(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Distance;                                          // 0x1714(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  CancelEffectTags;                                  // 0x1718(0x0068)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_103541">();
	}
	static class UConfig_103541* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_103541>();
	}
};
static_assert(alignof(UConfig_103541) == 0x000010, "Wrong alignment on UConfig_103541");
static_assert(sizeof(UConfig_103541) == 0x001780, "Wrong size on UConfig_103541");
static_assert(offsetof(UConfig_103541, ScopeID) == 0x000098, "Member 'UConfig_103541::ScopeID' has a wrong offset!");
static_assert(offsetof(UConfig_103541, LinkBuffID) == 0x00009C, "Member 'UConfig_103541::LinkBuffID' has a wrong offset!");
static_assert(offsetof(UConfig_103541, SlowBuffID) == 0x0000A0, "Member 'UConfig_103541::SlowBuffID' has a wrong offset!");
static_assert(offsetof(UConfig_103541, DamageBuffID) == 0x0000A4, "Member 'UConfig_103541::DamageBuffID' has a wrong offset!");
static_assert(offsetof(UConfig_103541, TraceContext) == 0x0000B0, "Member 'UConfig_103541::TraceContext' has a wrong offset!");
static_assert(offsetof(UConfig_103541, LinkTime) == 0x001710, "Member 'UConfig_103541::LinkTime' has a wrong offset!");
static_assert(offsetof(UConfig_103541, Distance) == 0x001714, "Member 'UConfig_103541::Distance' has a wrong offset!");
static_assert(offsetof(UConfig_103541, CancelEffectTags) == 0x001718, "Member 'UConfig_103541::CancelEffectTags' has a wrong offset!");

// Class Hero_1035.Ability_103541
// 0x0040 (0x2A30 - 0x29F0)
class UAbility_103541 : public UMarvelGameplayAbility
{
public:
	TArray<struct FHitResult>                     HitResults;                                        // 0x29F0(0x0010)(BlueprintVisible, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          TLHasFinished;                                     // 0x2A00(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A01[0x3];                                     // 0x2A01(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Duration;                                          // 0x2A04(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A08[0x8];                                     // 0x2A08(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           Timer;                                             // 0x2A10(0x0018)(HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A28[0x8];                                     // 0x2A28(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void RecordLog();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_103541">();
	}
	static class UAbility_103541* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_103541>();
	}
};
static_assert(alignof(UAbility_103541) == 0x000008, "Wrong alignment on UAbility_103541");
static_assert(sizeof(UAbility_103541) == 0x002A30, "Wrong size on UAbility_103541");
static_assert(offsetof(UAbility_103541, HitResults) == 0x0029F0, "Member 'UAbility_103541::HitResults' has a wrong offset!");
static_assert(offsetof(UAbility_103541, TLHasFinished) == 0x002A00, "Member 'UAbility_103541::TLHasFinished' has a wrong offset!");
static_assert(offsetof(UAbility_103541, Duration) == 0x002A04, "Member 'UAbility_103541::Duration' has a wrong offset!");
static_assert(offsetof(UAbility_103541, Timer) == 0x002A10, "Member 'UAbility_103541::Timer' has a wrong offset!");

// Class Hero_1035.EffectiveComponent_10354101
// 0x0000 (0x1C70 - 0x1C70)
class UEffectiveComponent_10354101 final : public UMarvelAgentEffectiveComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EffectiveComponent_10354101">();
	}
	static class UEffectiveComponent_10354101* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEffectiveComponent_10354101>();
	}
};
static_assert(alignof(UEffectiveComponent_10354101) == 0x000010, "Wrong alignment on UEffectiveComponent_10354101");
static_assert(sizeof(UEffectiveComponent_10354101) == 0x001C70, "Wrong size on UEffectiveComponent_10354101");

// Class Hero_1035.Cue_Buff_10354101
// 0x0600 (0x1C40 - 0x1640)
class ACue_Buff_10354101 final : public AMarvelCueNotify_Buff
{
public:
	class FName                                   SetLengthName;                                     // 0x1638(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MaxDistanceName;                                   // 0x1644(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDistance;                                       // 0x1650(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceScale;                                     // 0x1654(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceLerpSpeed;                                 // 0x1658(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SplitCenterScaleParam;                             // 0x165C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            SplitCenterScaleCurve;                             // 0x1668(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MeshBoundsScale;                                   // 0x1670(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurDistanceBias;                                   // 0x1674(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   GrowAnimName;                                      // 0x1678(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   GrowNoiseIntensityName;                            // 0x1684(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GrowAnimMax;                                       // 0x1690(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1694[0x4];                                     // 0x1694(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            GrowAnimValueCurve;                                // 0x1698(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            GrowNoiseIntensityCurve;                           // 0x16A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, class UCurveFloat*>         OtherGrowCurves;                                   // 0x16A8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         GrowMinR;                                          // 0x16F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GrowAnimTime;                                      // 0x16FC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MinRName;                                          // 0x1700(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_170C[0x4];                                     // 0x170C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            RecoveryMinRCurve;                                 // 0x1710(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, class UCurveFloat*>         OtherOutOfRangeCurves;                             // 0x1718(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class FName, class UCurveFloat*>         OtherExpiredCurves;                                // 0x1768(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class FName, class UCurveFloat*>         OtherBlockedCurves;                                // 0x17B8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  ForceRecycleTags;                                  // 0x1808(0x0068)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         RecoverySpeed;                                     // 0x1870(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoveryAnimValue;                                 // 0x1874(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoveryAnimTime;                                  // 0x1878(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   HasObstacleName;                                   // 0x187C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ObstacleSplitName;                                 // 0x1888(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ObstacleSplitRateName;                             // 0x1894(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SplitSpeed;                                        // 0x18A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18A4[0x4];                                     // 0x18A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UFXSystemAsset*                         SplitFXAsset;                                      // 0x18A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFXSystemAsset*                         TransientFXAsset;                                  // 0x18B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFXSystemAsset*                         TargetTransientFXAsset;                            // 0x18B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LerpValue;                                         // 0x18C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LerpSpeed;                                         // 0x18C4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutOfRangeLerpSpeed;                               // 0x18C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetDelayTime;                                   // 0x18CC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExpiredDelayTime;                                  // 0x18D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutOfRangeDelayTime;                               // 0x18D4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlockedDelayTime;                                  // 0x18D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxTransientFXDistance;                            // 0x18DC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SymbioteStateOffset;                               // 0x18E0(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SkeletalMeshName;                                  // 0x18F8(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PointsStartName;                                   // 0x1904(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PointsEndName;                                     // 0x1910(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TargetTransientSizeName;                           // 0x191C(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFXSystemAsset*                         RestrictFX;                                        // 0x1928(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RestrictGrowName;                                  // 0x1930(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_193C[0x4];                                     // 0x193C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            RestrictGrowCurve;                                 // 0x1940(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RestrictScaleName;                                 // 0x1948(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1954[0x4];                                     // 0x1954(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            RestrictScaleCurve;                                // 0x1958(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            ExpiredRestrictScaleCurve;                         // 0x1960(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RestrictFXDelayTime;                               // 0x1968(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_196C[0x4];                                     // 0x196C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UFXSystemAsset*                         ExpiredHitFX;                                      // 0x1970(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinBodySizeScale;                                  // 0x1978(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TentacleLoopAudioID;                               // 0x197C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SuccessAudioID;                                    // 0x1980(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FailAudioID;                                       // 0x1984(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RTPCName;                                          // 0x1988(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1994[0x4];                                     // 0x1994(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AOneShotAudioActor*                     TentacleAudioActor;                                // 0x1998(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      TransientFXComponent;                              // 0x19A0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      TargetTransientFXComponent;                        // 0x19A8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      RestrictFXComponent;                               // 0x19B0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TransientFXCurrentLerpValue;                       // 0x19B8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetTransientFXCurrentLerpValue;                 // 0x19BC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TransientDelayRecycleTime;                         // 0x19C0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetTransientDelayRecycleTime;                   // 0x19C4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentTime;                                       // 0x19C8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RestrictRecoveryTime;                              // 0x19CC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SplitLocation;                                     // 0x19D0(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CacheOwnerLocation;                                // 0x19E8(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SplitPercent;                                      // 0x1A00(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A04[0x4];                                     // 0x1A04(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             ObstacleInfo;                                      // 0x1A08(0x01F0)(Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_1BF8[0x4];                                     // 0x1BF8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AbilityID;                                         // 0x1BFC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   MeshComponent;                                     // 0x1C00(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UConfig_103541*                         AbilityConfig;                                     // 0x1C08(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ACharacter*                             OwnerCharacter;                                    // 0x1C10(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AMarvelBaseCharacter*                   InstigatorCharacter;                               // 0x1C18(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AVenomCharacter*                        VenomCharacter;                                    // 0x1C20(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 TickIntervalsOfEachLOD;                            // 0x1C28(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C38[0x8];                                     // 0x1C38(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnInstigatorCharacterEndPlay();
	void OnSymbioteStateChanged(bool InSymbioteState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Buff_10354101">();
	}
	static class ACue_Buff_10354101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Buff_10354101>();
	}
};
static_assert(alignof(ACue_Buff_10354101) == 0x000010, "Wrong alignment on ACue_Buff_10354101");
static_assert(sizeof(ACue_Buff_10354101) == 0x001C40, "Wrong size on ACue_Buff_10354101");
static_assert(offsetof(ACue_Buff_10354101, SetLengthName) == 0x001638, "Member 'ACue_Buff_10354101::SetLengthName' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, MaxDistanceName) == 0x001644, "Member 'ACue_Buff_10354101::MaxDistanceName' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, MaxDistance) == 0x001650, "Member 'ACue_Buff_10354101::MaxDistance' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, DistanceScale) == 0x001654, "Member 'ACue_Buff_10354101::DistanceScale' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, DistanceLerpSpeed) == 0x001658, "Member 'ACue_Buff_10354101::DistanceLerpSpeed' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, SplitCenterScaleParam) == 0x00165C, "Member 'ACue_Buff_10354101::SplitCenterScaleParam' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, SplitCenterScaleCurve) == 0x001668, "Member 'ACue_Buff_10354101::SplitCenterScaleCurve' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, MeshBoundsScale) == 0x001670, "Member 'ACue_Buff_10354101::MeshBoundsScale' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, CurDistanceBias) == 0x001674, "Member 'ACue_Buff_10354101::CurDistanceBias' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, GrowAnimName) == 0x001678, "Member 'ACue_Buff_10354101::GrowAnimName' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, GrowNoiseIntensityName) == 0x001684, "Member 'ACue_Buff_10354101::GrowNoiseIntensityName' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, GrowAnimMax) == 0x001690, "Member 'ACue_Buff_10354101::GrowAnimMax' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, GrowAnimValueCurve) == 0x001698, "Member 'ACue_Buff_10354101::GrowAnimValueCurve' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, GrowNoiseIntensityCurve) == 0x0016A0, "Member 'ACue_Buff_10354101::GrowNoiseIntensityCurve' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, OtherGrowCurves) == 0x0016A8, "Member 'ACue_Buff_10354101::OtherGrowCurves' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, GrowMinR) == 0x0016F8, "Member 'ACue_Buff_10354101::GrowMinR' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, GrowAnimTime) == 0x0016FC, "Member 'ACue_Buff_10354101::GrowAnimTime' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, MinRName) == 0x001700, "Member 'ACue_Buff_10354101::MinRName' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, RecoveryMinRCurve) == 0x001710, "Member 'ACue_Buff_10354101::RecoveryMinRCurve' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, OtherOutOfRangeCurves) == 0x001718, "Member 'ACue_Buff_10354101::OtherOutOfRangeCurves' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, OtherExpiredCurves) == 0x001768, "Member 'ACue_Buff_10354101::OtherExpiredCurves' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, OtherBlockedCurves) == 0x0017B8, "Member 'ACue_Buff_10354101::OtherBlockedCurves' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, ForceRecycleTags) == 0x001808, "Member 'ACue_Buff_10354101::ForceRecycleTags' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, RecoverySpeed) == 0x001870, "Member 'ACue_Buff_10354101::RecoverySpeed' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, RecoveryAnimValue) == 0x001874, "Member 'ACue_Buff_10354101::RecoveryAnimValue' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, RecoveryAnimTime) == 0x001878, "Member 'ACue_Buff_10354101::RecoveryAnimTime' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, HasObstacleName) == 0x00187C, "Member 'ACue_Buff_10354101::HasObstacleName' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, ObstacleSplitName) == 0x001888, "Member 'ACue_Buff_10354101::ObstacleSplitName' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, ObstacleSplitRateName) == 0x001894, "Member 'ACue_Buff_10354101::ObstacleSplitRateName' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, SplitSpeed) == 0x0018A0, "Member 'ACue_Buff_10354101::SplitSpeed' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, SplitFXAsset) == 0x0018A8, "Member 'ACue_Buff_10354101::SplitFXAsset' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, TransientFXAsset) == 0x0018B0, "Member 'ACue_Buff_10354101::TransientFXAsset' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, TargetTransientFXAsset) == 0x0018B8, "Member 'ACue_Buff_10354101::TargetTransientFXAsset' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, LerpValue) == 0x0018C0, "Member 'ACue_Buff_10354101::LerpValue' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, LerpSpeed) == 0x0018C4, "Member 'ACue_Buff_10354101::LerpSpeed' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, OutOfRangeLerpSpeed) == 0x0018C8, "Member 'ACue_Buff_10354101::OutOfRangeLerpSpeed' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, TargetDelayTime) == 0x0018CC, "Member 'ACue_Buff_10354101::TargetDelayTime' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, ExpiredDelayTime) == 0x0018D0, "Member 'ACue_Buff_10354101::ExpiredDelayTime' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, OutOfRangeDelayTime) == 0x0018D4, "Member 'ACue_Buff_10354101::OutOfRangeDelayTime' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, BlockedDelayTime) == 0x0018D8, "Member 'ACue_Buff_10354101::BlockedDelayTime' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, MaxTransientFXDistance) == 0x0018DC, "Member 'ACue_Buff_10354101::MaxTransientFXDistance' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, SymbioteStateOffset) == 0x0018E0, "Member 'ACue_Buff_10354101::SymbioteStateOffset' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, SkeletalMeshName) == 0x0018F8, "Member 'ACue_Buff_10354101::SkeletalMeshName' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, PointsStartName) == 0x001904, "Member 'ACue_Buff_10354101::PointsStartName' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, PointsEndName) == 0x001910, "Member 'ACue_Buff_10354101::PointsEndName' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, TargetTransientSizeName) == 0x00191C, "Member 'ACue_Buff_10354101::TargetTransientSizeName' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, RestrictFX) == 0x001928, "Member 'ACue_Buff_10354101::RestrictFX' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, RestrictGrowName) == 0x001930, "Member 'ACue_Buff_10354101::RestrictGrowName' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, RestrictGrowCurve) == 0x001940, "Member 'ACue_Buff_10354101::RestrictGrowCurve' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, RestrictScaleName) == 0x001948, "Member 'ACue_Buff_10354101::RestrictScaleName' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, RestrictScaleCurve) == 0x001958, "Member 'ACue_Buff_10354101::RestrictScaleCurve' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, ExpiredRestrictScaleCurve) == 0x001960, "Member 'ACue_Buff_10354101::ExpiredRestrictScaleCurve' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, RestrictFXDelayTime) == 0x001968, "Member 'ACue_Buff_10354101::RestrictFXDelayTime' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, ExpiredHitFX) == 0x001970, "Member 'ACue_Buff_10354101::ExpiredHitFX' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, MinBodySizeScale) == 0x001978, "Member 'ACue_Buff_10354101::MinBodySizeScale' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, TentacleLoopAudioID) == 0x00197C, "Member 'ACue_Buff_10354101::TentacleLoopAudioID' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, SuccessAudioID) == 0x001980, "Member 'ACue_Buff_10354101::SuccessAudioID' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, FailAudioID) == 0x001984, "Member 'ACue_Buff_10354101::FailAudioID' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, RTPCName) == 0x001988, "Member 'ACue_Buff_10354101::RTPCName' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, TentacleAudioActor) == 0x001998, "Member 'ACue_Buff_10354101::TentacleAudioActor' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, TransientFXComponent) == 0x0019A0, "Member 'ACue_Buff_10354101::TransientFXComponent' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, TargetTransientFXComponent) == 0x0019A8, "Member 'ACue_Buff_10354101::TargetTransientFXComponent' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, RestrictFXComponent) == 0x0019B0, "Member 'ACue_Buff_10354101::RestrictFXComponent' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, TransientFXCurrentLerpValue) == 0x0019B8, "Member 'ACue_Buff_10354101::TransientFXCurrentLerpValue' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, TargetTransientFXCurrentLerpValue) == 0x0019BC, "Member 'ACue_Buff_10354101::TargetTransientFXCurrentLerpValue' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, TransientDelayRecycleTime) == 0x0019C0, "Member 'ACue_Buff_10354101::TransientDelayRecycleTime' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, TargetTransientDelayRecycleTime) == 0x0019C4, "Member 'ACue_Buff_10354101::TargetTransientDelayRecycleTime' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, CurrentTime) == 0x0019C8, "Member 'ACue_Buff_10354101::CurrentTime' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, RestrictRecoveryTime) == 0x0019CC, "Member 'ACue_Buff_10354101::RestrictRecoveryTime' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, SplitLocation) == 0x0019D0, "Member 'ACue_Buff_10354101::SplitLocation' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, CacheOwnerLocation) == 0x0019E8, "Member 'ACue_Buff_10354101::CacheOwnerLocation' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, SplitPercent) == 0x001A00, "Member 'ACue_Buff_10354101::SplitPercent' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, ObstacleInfo) == 0x001A08, "Member 'ACue_Buff_10354101::ObstacleInfo' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, AbilityID) == 0x001BFC, "Member 'ACue_Buff_10354101::AbilityID' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, MeshComponent) == 0x001C00, "Member 'ACue_Buff_10354101::MeshComponent' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, AbilityConfig) == 0x001C08, "Member 'ACue_Buff_10354101::AbilityConfig' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, OwnerCharacter) == 0x001C10, "Member 'ACue_Buff_10354101::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, InstigatorCharacter) == 0x001C18, "Member 'ACue_Buff_10354101::InstigatorCharacter' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, VenomCharacter) == 0x001C20, "Member 'ACue_Buff_10354101::VenomCharacter' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10354101, TickIntervalsOfEachLOD) == 0x001C28, "Member 'ACue_Buff_10354101::TickIntervalsOfEachLOD' has a wrong offset!");

// Class Hero_1035.Cue_AbilityLoop_103551
// 0x02E0 (0x1490 - 0x11B0)
class ACue_AbilityLoop_103551 : public AMarvelCueNotify_Ability
{
public:
	TArray<struct FArmEffectParam>                ArmEffectParams;                                   // 0x11B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   SetLengthName;                                     // 0x11C0(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MaxDistanceName;                                   // 0x11CC(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, class UCurveFloat*>         GrowCurveMap;                                      // 0x11D8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class FName, float>                      CurveValueMap_WhenHit;                             // 0x1228(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FName                                   MinRName;                                          // 0x1278(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GrowMinR;                                          // 0x1284(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, class UCurveFloat*>         RecycleCurveMap;                                   // 0x1288(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FName                                   HasObstacleName;                                   // 0x12D8(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12E4[0x4];                                     // 0x12E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UFXSystemAsset*                         TransientFXAsset;                                  // 0x12E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LerpValue;                                         // 0x12F0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LerpSpeed;                                         // 0x12F4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxTransientFXDistance;                            // 0x12F8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PointsStartName;                                   // 0x12FC(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PointsEndName;                                     // 0x1308(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1314[0x4];                                     // 0x1314(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UFXSystemAsset*                         HitFxAsset;                                        // 0x1318(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitFxScaleValue;                                   // 0x1320(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitFxMaxLength;                                    // 0x1324(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitFxRecycleDuration;                              // 0x1328(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnablePortalMeshCopy;                             // 0x132C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_132D[0x3];                                     // 0x132D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   TentacleMeshComponent;                             // 0x1330(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AMarvelBaseCharacter*                   OwnerCharacter;                                    // 0x1338(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETentacleState103551                          TentacleState;                                     // 0x1340(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1341[0x7];                                     // 0x1341(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AMarvelAbilityTargetActor_Projectile*   AttachedProjectile;                                // 0x1348(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StartShootTime;                                    // 0x1350(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StartHandReleaseTime;                              // 0x1354(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1358[0x20];                                    // 0x1358(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UNiagaraComponent*>              ArmFXComponentArray;                               // 0x1378(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      TransientFXComponent;                              // 0x1388(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      HitEffectComponent;                                // 0x1390(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                HitEffectCurrentEndPos;                            // 0x1398(0x0018)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HitEffectRecycleSpeed;                             // 0x13B0(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_13B4[0x4];                                     // 0x13B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, float>                      TentacleStateMap;                                  // 0x13B8(0x0050)(BlueprintVisible, Transient, Protected, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     TentacleMaterial;                                  // 0x1408(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHasPassedPortal;                                  // 0x1410(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1411[0x7];                                     // 0x1411(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPortalSegments                        PortalSegments;                                    // 0x1418(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1468[0x18];                                    // 0x1468(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   PhantomTentacleMeshComponent;                      // 0x1480(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1488[0x8];                                     // 0x1488(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddArmFXComponent(class UNiagaraComponent* StartComp);
	struct FVector GetTargetLocationEXT();
	void K2_OnRecycle();
	void NoHitResultForLineTrace();
	void OnForceChangedByPortal(class APortalViewActor* InPortal);
	void OnProjectilePassPortal(class APortalViewActor* InPortal);
	void ReCorrectTargetHitResult(const struct FHitResult& InHitResult);
	void ResetDefault();
	void SetTargetHitResult(const struct FHitResult& InHitResult);
	void SetTargetLocation(const struct FVector& InTargetLocation);
	void SetTentacleMaterialParamValue(class FName InName, float InValue);

	void SetTransientFXLerpValue(class UNiagaraComponent* StartComp, const struct FVector& InTargetLocation, float InLerpValue) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_AbilityLoop_103551">();
	}
	static class ACue_AbilityLoop_103551* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_AbilityLoop_103551>();
	}
};
static_assert(alignof(ACue_AbilityLoop_103551) == 0x000010, "Wrong alignment on ACue_AbilityLoop_103551");
static_assert(sizeof(ACue_AbilityLoop_103551) == 0x001490, "Wrong size on ACue_AbilityLoop_103551");
static_assert(offsetof(ACue_AbilityLoop_103551, ArmEffectParams) == 0x0011B0, "Member 'ACue_AbilityLoop_103551::ArmEffectParams' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_103551, SetLengthName) == 0x0011C0, "Member 'ACue_AbilityLoop_103551::SetLengthName' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_103551, MaxDistanceName) == 0x0011CC, "Member 'ACue_AbilityLoop_103551::MaxDistanceName' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_103551, GrowCurveMap) == 0x0011D8, "Member 'ACue_AbilityLoop_103551::GrowCurveMap' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_103551, CurveValueMap_WhenHit) == 0x001228, "Member 'ACue_AbilityLoop_103551::CurveValueMap_WhenHit' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_103551, MinRName) == 0x001278, "Member 'ACue_AbilityLoop_103551::MinRName' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_103551, GrowMinR) == 0x001284, "Member 'ACue_AbilityLoop_103551::GrowMinR' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_103551, RecycleCurveMap) == 0x001288, "Member 'ACue_AbilityLoop_103551::RecycleCurveMap' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_103551, HasObstacleName) == 0x0012D8, "Member 'ACue_AbilityLoop_103551::HasObstacleName' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_103551, TransientFXAsset) == 0x0012E8, "Member 'ACue_AbilityLoop_103551::TransientFXAsset' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_103551, LerpValue) == 0x0012F0, "Member 'ACue_AbilityLoop_103551::LerpValue' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_103551, LerpSpeed) == 0x0012F4, "Member 'ACue_AbilityLoop_103551::LerpSpeed' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_103551, MaxTransientFXDistance) == 0x0012F8, "Member 'ACue_AbilityLoop_103551::MaxTransientFXDistance' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_103551, PointsStartName) == 0x0012FC, "Member 'ACue_AbilityLoop_103551::PointsStartName' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_103551, PointsEndName) == 0x001308, "Member 'ACue_AbilityLoop_103551::PointsEndName' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_103551, HitFxAsset) == 0x001318, "Member 'ACue_AbilityLoop_103551::HitFxAsset' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_103551, HitFxScaleValue) == 0x001320, "Member 'ACue_AbilityLoop_103551::HitFxScaleValue' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_103551, HitFxMaxLength) == 0x001324, "Member 'ACue_AbilityLoop_103551::HitFxMaxLength' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_103551, HitFxRecycleDuration) == 0x001328, "Member 'ACue_AbilityLoop_103551::HitFxRecycleDuration' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_103551, bEnablePortalMeshCopy) == 0x00132C, "Member 'ACue_AbilityLoop_103551::bEnablePortalMeshCopy' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_103551, TentacleMeshComponent) == 0x001330, "Member 'ACue_AbilityLoop_103551::TentacleMeshComponent' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_103551, OwnerCharacter) == 0x001338, "Member 'ACue_AbilityLoop_103551::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_103551, TentacleState) == 0x001340, "Member 'ACue_AbilityLoop_103551::TentacleState' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_103551, AttachedProjectile) == 0x001348, "Member 'ACue_AbilityLoop_103551::AttachedProjectile' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_103551, StartShootTime) == 0x001350, "Member 'ACue_AbilityLoop_103551::StartShootTime' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_103551, StartHandReleaseTime) == 0x001354, "Member 'ACue_AbilityLoop_103551::StartHandReleaseTime' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_103551, ArmFXComponentArray) == 0x001378, "Member 'ACue_AbilityLoop_103551::ArmFXComponentArray' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_103551, TransientFXComponent) == 0x001388, "Member 'ACue_AbilityLoop_103551::TransientFXComponent' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_103551, HitEffectComponent) == 0x001390, "Member 'ACue_AbilityLoop_103551::HitEffectComponent' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_103551, HitEffectCurrentEndPos) == 0x001398, "Member 'ACue_AbilityLoop_103551::HitEffectCurrentEndPos' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_103551, HitEffectRecycleSpeed) == 0x0013B0, "Member 'ACue_AbilityLoop_103551::HitEffectRecycleSpeed' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_103551, TentacleStateMap) == 0x0013B8, "Member 'ACue_AbilityLoop_103551::TentacleStateMap' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_103551, TentacleMaterial) == 0x001408, "Member 'ACue_AbilityLoop_103551::TentacleMaterial' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_103551, bHasPassedPortal) == 0x001410, "Member 'ACue_AbilityLoop_103551::bHasPassedPortal' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_103551, PortalSegments) == 0x001418, "Member 'ACue_AbilityLoop_103551::PortalSegments' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_103551, PhantomTentacleMeshComponent) == 0x001480, "Member 'ACue_AbilityLoop_103551::PhantomTentacleMeshComponent' has a wrong offset!");

// Class Hero_1035.Cue_Buff_10356101
// 0x00E0 (0x1720 - 0x1640)
class ACue_Buff_10356101 final : public AMarvelCueNotify_Buff
{
public:
	class UNiagaraComponent*                      NS_Buff;                                           // 0x1638(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   HideName;                                          // 0x1640(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HideSpeed;                                         // 0x164C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  AbilityTags;                                       // 0x1650(0x0068)(Edit, NativeAccessSpecifierPublic)
	class FName                                   DissolveName;                                      // 0x16B8(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16C4[0x4];                                     // 0x16C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            DissolveCurve;                                     // 0x16C8(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SymbiontOpenParameterName;                         // 0x16D0(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SymbiontIntensityParameterName;                    // 0x16DC(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EmissiveStrengthName;                              // 0x16E8(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16F4[0x4];                                     // 0x16F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            StartSymbiontCurve;                                // 0x16F8(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            EndSymbiontCurve;                                  // 0x1700(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFXSystemAsset*                         RecycleFXAsset;                                    // 0x1708(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1710[0x10];                                    // 0x1710(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Buff_10356101">();
	}
	static class ACue_Buff_10356101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Buff_10356101>();
	}
};
static_assert(alignof(ACue_Buff_10356101) == 0x000010, "Wrong alignment on ACue_Buff_10356101");
static_assert(sizeof(ACue_Buff_10356101) == 0x001720, "Wrong size on ACue_Buff_10356101");
static_assert(offsetof(ACue_Buff_10356101, NS_Buff) == 0x001638, "Member 'ACue_Buff_10356101::NS_Buff' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10356101, HideName) == 0x001640, "Member 'ACue_Buff_10356101::HideName' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10356101, HideSpeed) == 0x00164C, "Member 'ACue_Buff_10356101::HideSpeed' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10356101, AbilityTags) == 0x001650, "Member 'ACue_Buff_10356101::AbilityTags' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10356101, DissolveName) == 0x0016B8, "Member 'ACue_Buff_10356101::DissolveName' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10356101, DissolveCurve) == 0x0016C8, "Member 'ACue_Buff_10356101::DissolveCurve' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10356101, SymbiontOpenParameterName) == 0x0016D0, "Member 'ACue_Buff_10356101::SymbiontOpenParameterName' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10356101, SymbiontIntensityParameterName) == 0x0016DC, "Member 'ACue_Buff_10356101::SymbiontIntensityParameterName' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10356101, EmissiveStrengthName) == 0x0016E8, "Member 'ACue_Buff_10356101::EmissiveStrengthName' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10356101, StartSymbiontCurve) == 0x0016F8, "Member 'ACue_Buff_10356101::StartSymbiontCurve' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10356101, EndSymbiontCurve) == 0x001700, "Member 'ACue_Buff_10356101::EndSymbiontCurve' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10356101, RecycleFXAsset) == 0x001708, "Member 'ACue_Buff_10356101::RecycleFXAsset' has a wrong offset!");

// Class Hero_1035.Config_103571
// 0x0140 (0x01D8 - 0x0098)
class UConfig_103571 final : public UMarvelAbilityConfig
{
public:
	float                                         ApplyDamageToShieldRatio;                          // 0x0098(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  ApplyDamageToShieldTags;                           // 0x00A0(0x0068)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	int32                                         ScopeID;                                           // 0x0108(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinScopeRadius;                                    // 0x010C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxScopeRadius;                                    // 0x0110(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScopeSpreadDuration;                               // 0x0114(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableDragScope;                                  // 0x0118(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_119[0x3];                                      // 0x0119(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DragScopeID;                                       // 0x011C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableKnockUpScope;                               // 0x0120(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_121[0x3];                                      // 0x0121(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         KnockUpScopeID;                                    // 0x0124(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdjustedCapsuleRadius;                             // 0x0128(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdjustedCapsuleHalfHeight;                         // 0x012C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NotTreatShieldBuffID;                              // 0x0130(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           SymbioteTag;                                       // 0x0134(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ForceUpdateBoneTag;                                // 0x0140(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JumpGravityScale;                                  // 0x014C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JumpZVelocity;                                     // 0x0150(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DevouringDuration;                                 // 0x0154(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TraceDelayTime;                                    // 0x0158(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15C[0x4];                                      // 0x015C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  DevouringBlockTags;                                // 0x0160(0x0068)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	int32                                         DevouringInvincibleBuffID;                         // 0x01C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IncreaseSpeedBuffID;                               // 0x01CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DevouringOffset;                                   // 0x01D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D4[0x4];                                      // 0x01D4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_103571">();
	}
	static class UConfig_103571* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_103571>();
	}
};
static_assert(alignof(UConfig_103571) == 0x000008, "Wrong alignment on UConfig_103571");
static_assert(sizeof(UConfig_103571) == 0x0001D8, "Wrong size on UConfig_103571");
static_assert(offsetof(UConfig_103571, ApplyDamageToShieldRatio) == 0x000098, "Member 'UConfig_103571::ApplyDamageToShieldRatio' has a wrong offset!");
static_assert(offsetof(UConfig_103571, ApplyDamageToShieldTags) == 0x0000A0, "Member 'UConfig_103571::ApplyDamageToShieldTags' has a wrong offset!");
static_assert(offsetof(UConfig_103571, ScopeID) == 0x000108, "Member 'UConfig_103571::ScopeID' has a wrong offset!");
static_assert(offsetof(UConfig_103571, MinScopeRadius) == 0x00010C, "Member 'UConfig_103571::MinScopeRadius' has a wrong offset!");
static_assert(offsetof(UConfig_103571, MaxScopeRadius) == 0x000110, "Member 'UConfig_103571::MaxScopeRadius' has a wrong offset!");
static_assert(offsetof(UConfig_103571, ScopeSpreadDuration) == 0x000114, "Member 'UConfig_103571::ScopeSpreadDuration' has a wrong offset!");
static_assert(offsetof(UConfig_103571, bEnableDragScope) == 0x000118, "Member 'UConfig_103571::bEnableDragScope' has a wrong offset!");
static_assert(offsetof(UConfig_103571, DragScopeID) == 0x00011C, "Member 'UConfig_103571::DragScopeID' has a wrong offset!");
static_assert(offsetof(UConfig_103571, bEnableKnockUpScope) == 0x000120, "Member 'UConfig_103571::bEnableKnockUpScope' has a wrong offset!");
static_assert(offsetof(UConfig_103571, KnockUpScopeID) == 0x000124, "Member 'UConfig_103571::KnockUpScopeID' has a wrong offset!");
static_assert(offsetof(UConfig_103571, AdjustedCapsuleRadius) == 0x000128, "Member 'UConfig_103571::AdjustedCapsuleRadius' has a wrong offset!");
static_assert(offsetof(UConfig_103571, AdjustedCapsuleHalfHeight) == 0x00012C, "Member 'UConfig_103571::AdjustedCapsuleHalfHeight' has a wrong offset!");
static_assert(offsetof(UConfig_103571, NotTreatShieldBuffID) == 0x000130, "Member 'UConfig_103571::NotTreatShieldBuffID' has a wrong offset!");
static_assert(offsetof(UConfig_103571, SymbioteTag) == 0x000134, "Member 'UConfig_103571::SymbioteTag' has a wrong offset!");
static_assert(offsetof(UConfig_103571, ForceUpdateBoneTag) == 0x000140, "Member 'UConfig_103571::ForceUpdateBoneTag' has a wrong offset!");
static_assert(offsetof(UConfig_103571, JumpGravityScale) == 0x00014C, "Member 'UConfig_103571::JumpGravityScale' has a wrong offset!");
static_assert(offsetof(UConfig_103571, JumpZVelocity) == 0x000150, "Member 'UConfig_103571::JumpZVelocity' has a wrong offset!");
static_assert(offsetof(UConfig_103571, DevouringDuration) == 0x000154, "Member 'UConfig_103571::DevouringDuration' has a wrong offset!");
static_assert(offsetof(UConfig_103571, TraceDelayTime) == 0x000158, "Member 'UConfig_103571::TraceDelayTime' has a wrong offset!");
static_assert(offsetof(UConfig_103571, DevouringBlockTags) == 0x000160, "Member 'UConfig_103571::DevouringBlockTags' has a wrong offset!");
static_assert(offsetof(UConfig_103571, DevouringInvincibleBuffID) == 0x0001C8, "Member 'UConfig_103571::DevouringInvincibleBuffID' has a wrong offset!");
static_assert(offsetof(UConfig_103571, IncreaseSpeedBuffID) == 0x0001CC, "Member 'UConfig_103571::IncreaseSpeedBuffID' has a wrong offset!");
static_assert(offsetof(UConfig_103571, DevouringOffset) == 0x0001D0, "Member 'UConfig_103571::DevouringOffset' has a wrong offset!");

// Class Hero_1035.Ability_103571
// 0x0038 (0x2A28 - 0x29F0)
class UAbility_103571 : public UMarvelGameplayAbility
{
public:
	uint8                                         Pad_29F0[0x38];                                    // 0x29F0(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ChangeGravity(float InGravityScale);
	void ResetGravity();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_103571">();
	}
	static class UAbility_103571* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_103571>();
	}
};
static_assert(alignof(UAbility_103571) == 0x000008, "Wrong alignment on UAbility_103571");
static_assert(sizeof(UAbility_103571) == 0x002A28, "Wrong size on UAbility_103571");

// Class Hero_1035.Scope_10357101
// 0x0070 (0x1B10 - 0x1AA0)
class AScope_10357101 : public AMarvelAbilityTargetActor_Scope
{
public:
	float                                         ScopeRadius;                                       // 0x1AA0(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESymbiontScopeState                           ScopeState;                                        // 0x1AA4(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1AA5[0x3];                                     // 0x1AA5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               TargetRotator;                                     // 0x1AA8(0x0018)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              StartDevourDelegate;                               // 0x1AC0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              StopDevourDelegate;                                // 0x1AD0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UConfig_103571*                         AbilityConfig;                                     // 0x1AE0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1AE8[0x28];                                    // 0x1AE8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DevourTrace();
	void OnRep_ScopeRadius();
	void OnRep_ScopeState();
	void SetScopeRadius(float InRadius);
	void SetScopeState(ESymbiontScopeState InScopeState);
	void StartDevour();
	void StartSpread();
	void StopDevour();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Scope_10357101">();
	}
	static class AScope_10357101* GetDefaultObj()
	{
		return GetDefaultObjImpl<AScope_10357101>();
	}
};
static_assert(alignof(AScope_10357101) == 0x000010, "Wrong alignment on AScope_10357101");
static_assert(sizeof(AScope_10357101) == 0x001B10, "Wrong size on AScope_10357101");
static_assert(offsetof(AScope_10357101, ScopeRadius) == 0x001AA0, "Member 'AScope_10357101::ScopeRadius' has a wrong offset!");
static_assert(offsetof(AScope_10357101, ScopeState) == 0x001AA4, "Member 'AScope_10357101::ScopeState' has a wrong offset!");
static_assert(offsetof(AScope_10357101, TargetRotator) == 0x001AA8, "Member 'AScope_10357101::TargetRotator' has a wrong offset!");
static_assert(offsetof(AScope_10357101, StartDevourDelegate) == 0x001AC0, "Member 'AScope_10357101::StartDevourDelegate' has a wrong offset!");
static_assert(offsetof(AScope_10357101, StopDevourDelegate) == 0x001AD0, "Member 'AScope_10357101::StopDevourDelegate' has a wrong offset!");
static_assert(offsetof(AScope_10357101, AbilityConfig) == 0x001AE0, "Member 'AScope_10357101::AbilityConfig' has a wrong offset!");

// Class Hero_1035.TraceComponent_10357101
// 0x0010 (0x2210 - 0x2200)
class UTraceComponent_10357101 final : public UMarvelAgentTraceComponent
{
public:
	uint8                                         Pad_2200[0x10];                                    // 0x2200(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TraceComponent_10357101">();
	}
	static class UTraceComponent_10357101* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTraceComponent_10357101>();
	}
};
static_assert(alignof(UTraceComponent_10357101) == 0x000010, "Wrong alignment on UTraceComponent_10357101");
static_assert(sizeof(UTraceComponent_10357101) == 0x002210, "Wrong size on UTraceComponent_10357101");

// Class Hero_1035.TraceComponent_10357102
// 0x0010 (0x2210 - 0x2200)
class UTraceComponent_10357102 final : public UMarvelAgentTraceComponent
{
public:
	uint8                                         Pad_2200[0x10];                                    // 0x2200(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TraceComponent_10357102">();
	}
	static class UTraceComponent_10357102* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTraceComponent_10357102>();
	}
};
static_assert(alignof(UTraceComponent_10357102) == 0x000010, "Wrong alignment on UTraceComponent_10357102");
static_assert(sizeof(UTraceComponent_10357102) == 0x002210, "Wrong size on UTraceComponent_10357102");

// Class Hero_1035.DragAbility_103571
// 0x0018 (0x1F98 - 0x1F80)
class UDragAbility_103571 : public UMarvelDragAbility
{
public:
	struct FVector                                TargetOffset;                                      // 0x1F80(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DragAbility_103571">();
	}
	static class UDragAbility_103571* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDragAbility_103571>();
	}
};
static_assert(alignof(UDragAbility_103571) == 0x000008, "Wrong alignment on UDragAbility_103571");
static_assert(sizeof(UDragAbility_103571) == 0x001F98, "Wrong size on UDragAbility_103571");
static_assert(offsetof(UDragAbility_103571, TargetOffset) == 0x001F80, "Member 'UDragAbility_103571::TargetOffset' has a wrong offset!");

// Class Hero_1035.SymbioteAnimInstance
// 0x0000 (0x0450 - 0x0450)
class USymbioteAnimInstance final : public UAnimInstance
{
public:
	bool                                          bIsRunning;                                        // 0x0448(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_449[0x7];                                      // 0x0449(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SymbioteAnimInstance">();
	}
	static class USymbioteAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<USymbioteAnimInstance>();
	}
};
static_assert(alignof(USymbioteAnimInstance) == 0x000010, "Wrong alignment on USymbioteAnimInstance");
static_assert(sizeof(USymbioteAnimInstance) == 0x000450, "Wrong size on USymbioteAnimInstance");
static_assert(offsetof(USymbioteAnimInstance, bIsRunning) == 0x000448, "Member 'USymbioteAnimInstance::bIsRunning' has a wrong offset!");

// Class Hero_1035.Cue_Scope_Loop_10357101
// 0x0220 (0x1300 - 0x10E0)
class ACue_Scope_Loop_10357101 final : public AMarvelCueNotify_Scope
{
public:
	class USkeletalMeshComponent*                 SymbioteComponent;                                 // 0x10E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 SymbioteTentacleComponent;                         // 0x10E8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      NS_Loop;                                           // 0x10F0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      NS_Tentacle;                                       // 0x10F8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  RegisterHiddenTags;                                // 0x1100(0x0068)(Edit, NativeAccessSpecifierPublic)
	uint8                                         Pad_1168[0x50];                                    // 0x1168(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AbilityID;                                         // 0x11B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GroundTraceHeight;                                 // 0x11BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           DevourMontage;                                     // 0x11C0(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AttachOffset;                                      // 0x11C8(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UFXSystemAsset*>                 StartDevourFXAssets;                               // 0x11E0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   TentacleAlphaName;                                 // 0x11F0(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11FC[0x4];                                     // 0x11FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            TentacleAlphaCurve;                                // 0x1200(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   VelocityRatioName;                                 // 0x1208(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VelocityRatioSpeed;                                // 0x1214(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   IsRotateName;                                      // 0x1218(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinVelocityRatio;                                  // 0x1224(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LoopFXSizeName;                                    // 0x1228(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultFXSize;                                     // 0x1234(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TentacleFXOnThrowableName;                         // 0x1238(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StartMoveAudioID;                                  // 0x1244(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StopMoveAudioID;                                   // 0x1248(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_124C[0x4];                                     // 0x124C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCameraInterp*                          DevouringCameraInterp;                             // 0x1250(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UConfig_103571*                         AbilityConfig;                                     // 0x1258(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AScope_10357101*                        TargetScope;                                       // 0x1260(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class AActor*, struct FSpringArmControlHandler> SpringArmHandlers;                          // 0x1268(0x0050)(Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_12B8[0x48];                                    // 0x12B8(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnGenericGameplayTagUpdate(const struct FGameplayTag& InTag, int32 Count);
	void OnMontageEnded(class UAnimMontage* InMontage, bool bIsInterrupted);
	void StartDevour();
	void StopDevour();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Scope_Loop_10357101">();
	}
	static class ACue_Scope_Loop_10357101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Scope_Loop_10357101>();
	}
};
static_assert(alignof(ACue_Scope_Loop_10357101) == 0x000010, "Wrong alignment on ACue_Scope_Loop_10357101");
static_assert(sizeof(ACue_Scope_Loop_10357101) == 0x001300, "Wrong size on ACue_Scope_Loop_10357101");
static_assert(offsetof(ACue_Scope_Loop_10357101, SymbioteComponent) == 0x0010E0, "Member 'ACue_Scope_Loop_10357101::SymbioteComponent' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10357101, SymbioteTentacleComponent) == 0x0010E8, "Member 'ACue_Scope_Loop_10357101::SymbioteTentacleComponent' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10357101, NS_Loop) == 0x0010F0, "Member 'ACue_Scope_Loop_10357101::NS_Loop' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10357101, NS_Tentacle) == 0x0010F8, "Member 'ACue_Scope_Loop_10357101::NS_Tentacle' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10357101, RegisterHiddenTags) == 0x001100, "Member 'ACue_Scope_Loop_10357101::RegisterHiddenTags' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10357101, AbilityID) == 0x0011B8, "Member 'ACue_Scope_Loop_10357101::AbilityID' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10357101, GroundTraceHeight) == 0x0011BC, "Member 'ACue_Scope_Loop_10357101::GroundTraceHeight' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10357101, DevourMontage) == 0x0011C0, "Member 'ACue_Scope_Loop_10357101::DevourMontage' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10357101, AttachOffset) == 0x0011C8, "Member 'ACue_Scope_Loop_10357101::AttachOffset' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10357101, StartDevourFXAssets) == 0x0011E0, "Member 'ACue_Scope_Loop_10357101::StartDevourFXAssets' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10357101, TentacleAlphaName) == 0x0011F0, "Member 'ACue_Scope_Loop_10357101::TentacleAlphaName' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10357101, TentacleAlphaCurve) == 0x001200, "Member 'ACue_Scope_Loop_10357101::TentacleAlphaCurve' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10357101, VelocityRatioName) == 0x001208, "Member 'ACue_Scope_Loop_10357101::VelocityRatioName' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10357101, VelocityRatioSpeed) == 0x001214, "Member 'ACue_Scope_Loop_10357101::VelocityRatioSpeed' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10357101, IsRotateName) == 0x001218, "Member 'ACue_Scope_Loop_10357101::IsRotateName' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10357101, MinVelocityRatio) == 0x001224, "Member 'ACue_Scope_Loop_10357101::MinVelocityRatio' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10357101, LoopFXSizeName) == 0x001228, "Member 'ACue_Scope_Loop_10357101::LoopFXSizeName' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10357101, DefaultFXSize) == 0x001234, "Member 'ACue_Scope_Loop_10357101::DefaultFXSize' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10357101, TentacleFXOnThrowableName) == 0x001238, "Member 'ACue_Scope_Loop_10357101::TentacleFXOnThrowableName' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10357101, StartMoveAudioID) == 0x001244, "Member 'ACue_Scope_Loop_10357101::StartMoveAudioID' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10357101, StopMoveAudioID) == 0x001248, "Member 'ACue_Scope_Loop_10357101::StopMoveAudioID' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10357101, DevouringCameraInterp) == 0x001250, "Member 'ACue_Scope_Loop_10357101::DevouringCameraInterp' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10357101, AbilityConfig) == 0x001258, "Member 'ACue_Scope_Loop_10357101::AbilityConfig' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10357101, TargetScope) == 0x001260, "Member 'ACue_Scope_Loop_10357101::TargetScope' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10357101, SpringArmHandlers) == 0x001268, "Member 'ACue_Scope_Loop_10357101::SpringArmHandlers' has a wrong offset!");

// Class Hero_1035.EpicMomentAction_1035
// 0x0040 (0x0160 - 0x0120)
class UEpicMomentAction_1035 : public UEpicMomentBaseAction
{
public:
	uint8                                         Pad_120[0x10];                                     // 0x0120(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UMarvelGameplayAbility*                 EAbility;                                          // 0x0130(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FEpicMomentNodeInfo                    CtrlConfig;                                        // 0x0138(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FEpicMomentNodeInfo                    EConfig;                                           // 0x0144(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         CtrlBuffID;                                        // 0x0150(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CtrlBuffCount;                                     // 0x0154(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EAbilityID;                                        // 0x0158(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EHealthThreshold;                                  // 0x015C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void OnEAbilityActivate();
	void OnGameplayEffectAppliedToTarget(class UAbilitySystemComponent* ASC, const struct FGameplayEffectSpecStackHandle& GameplayEffectSpecHandle, const struct FActiveGameplayEffectHandle& ActiveGameplayEffectHandle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EpicMomentAction_1035">();
	}
	static class UEpicMomentAction_1035* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEpicMomentAction_1035>();
	}
};
static_assert(alignof(UEpicMomentAction_1035) == 0x000008, "Wrong alignment on UEpicMomentAction_1035");
static_assert(sizeof(UEpicMomentAction_1035) == 0x000160, "Wrong size on UEpicMomentAction_1035");
static_assert(offsetof(UEpicMomentAction_1035, EAbility) == 0x000130, "Member 'UEpicMomentAction_1035::EAbility' has a wrong offset!");
static_assert(offsetof(UEpicMomentAction_1035, CtrlConfig) == 0x000138, "Member 'UEpicMomentAction_1035::CtrlConfig' has a wrong offset!");
static_assert(offsetof(UEpicMomentAction_1035, EConfig) == 0x000144, "Member 'UEpicMomentAction_1035::EConfig' has a wrong offset!");
static_assert(offsetof(UEpicMomentAction_1035, CtrlBuffID) == 0x000150, "Member 'UEpicMomentAction_1035::CtrlBuffID' has a wrong offset!");
static_assert(offsetof(UEpicMomentAction_1035, CtrlBuffCount) == 0x000154, "Member 'UEpicMomentAction_1035::CtrlBuffCount' has a wrong offset!");
static_assert(offsetof(UEpicMomentAction_1035, EAbilityID) == 0x000158, "Member 'UEpicMomentAction_1035::EAbilityID' has a wrong offset!");
static_assert(offsetof(UEpicMomentAction_1035, EHealthThreshold) == 0x00015C, "Member 'UEpicMomentAction_1035::EHealthThreshold' has a wrong offset!");

// Class Hero_1035.VenomAnimInstance
// 0x00A0 (0x1660 - 0x15C0)
class UVenomAnimInstance final : public USpiderManBaseAnimInstance
{
public:
	bool                                          bStartWallIdle_To_OnWallRunning;                   // 0x15C0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEndWallIdle_To_OnWallRunning;                     // 0x15C1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_15C2[0x9E];                                    // 0x15C2(0x009E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VenomAnimInstance">();
	}
	static class UVenomAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVenomAnimInstance>();
	}
};
static_assert(alignof(UVenomAnimInstance) == 0x000010, "Wrong alignment on UVenomAnimInstance");
static_assert(sizeof(UVenomAnimInstance) == 0x001660, "Wrong size on UVenomAnimInstance");
static_assert(offsetof(UVenomAnimInstance, bStartWallIdle_To_OnWallRunning) == 0x0015C0, "Member 'UVenomAnimInstance::bStartWallIdle_To_OnWallRunning' has a wrong offset!");
static_assert(offsetof(UVenomAnimInstance, bEndWallIdle_To_OnWallRunning) == 0x0015C1, "Member 'UVenomAnimInstance::bEndWallIdle_To_OnWallRunning' has a wrong offset!");

// Class Hero_1035.VenomCakeNiagaraComponent
// 0x0090 (0x0B90 - 0x0B00)
class UVenomCakeNiagaraComponent final : public UNiagaraComponent
{
public:
	struct FVector                                MaxOffset;                                         // 0x0AF8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ParticleOffsetParamName;                           // 0x0B10(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   VelocityParamName;                                 // 0x0B1C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Stiffness;                                         // 0x0B28(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CriticalDampingFactor;                             // 0x0B2C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetVelocityAmount;                              // 0x0B30(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B34[0x5C];                                     // 0x0B34(0x005C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VenomCakeNiagaraComponent">();
	}
	static class UVenomCakeNiagaraComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVenomCakeNiagaraComponent>();
	}
};
static_assert(alignof(UVenomCakeNiagaraComponent) == 0x000010, "Wrong alignment on UVenomCakeNiagaraComponent");
static_assert(sizeof(UVenomCakeNiagaraComponent) == 0x000B90, "Wrong size on UVenomCakeNiagaraComponent");
static_assert(offsetof(UVenomCakeNiagaraComponent, MaxOffset) == 0x000AF8, "Member 'UVenomCakeNiagaraComponent::MaxOffset' has a wrong offset!");
static_assert(offsetof(UVenomCakeNiagaraComponent, ParticleOffsetParamName) == 0x000B10, "Member 'UVenomCakeNiagaraComponent::ParticleOffsetParamName' has a wrong offset!");
static_assert(offsetof(UVenomCakeNiagaraComponent, VelocityParamName) == 0x000B1C, "Member 'UVenomCakeNiagaraComponent::VelocityParamName' has a wrong offset!");
static_assert(offsetof(UVenomCakeNiagaraComponent, Stiffness) == 0x000B28, "Member 'UVenomCakeNiagaraComponent::Stiffness' has a wrong offset!");
static_assert(offsetof(UVenomCakeNiagaraComponent, CriticalDampingFactor) == 0x000B2C, "Member 'UVenomCakeNiagaraComponent::CriticalDampingFactor' has a wrong offset!");
static_assert(offsetof(UVenomCakeNiagaraComponent, TargetVelocityAmount) == 0x000B30, "Member 'UVenomCakeNiagaraComponent::TargetVelocityAmount' has a wrong offset!");

// Class Hero_1035.VenomCharacter
// 0x0050 (0x2220 - 0x21D0)
class AVenomCharacter : public ASpiderManBaseCharacter
{
public:
	class UCapsuleComponent*                      SymbioteCapsuleComponent;                          // 0x21C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCapsuleComponent*                      SymbioteHitShapeComponent;                         // 0x21D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SymbioteInterpSpeed;                               // 0x21D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SymbioteFallingInterpSpeed;                        // 0x21DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TriggerRotateSpeed;                                // 0x21E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21E4[0x4];                                     // 0x21E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UVenomMoveLogicBaseComponent*           VenomMoveLogic;                                    // 0x21E8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bLoopAnim;                                         // 0x21F0(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsEnableSymbioteCollision;                        // 0x21F1(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21F2[0x6];                                     // 0x21F2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(bool Value)>    OnSymbioteStateChanged;                            // 0x21F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2208[0x18];                                    // 0x2208(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EnableSymbioteCollision(bool bIsEnable);
	void OnRep_IsEnableSymbioteCollision();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VenomCharacter">();
	}
	static class AVenomCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVenomCharacter>();
	}
};
static_assert(alignof(AVenomCharacter) == 0x000010, "Wrong alignment on AVenomCharacter");
static_assert(sizeof(AVenomCharacter) == 0x002220, "Wrong size on AVenomCharacter");
static_assert(offsetof(AVenomCharacter, SymbioteCapsuleComponent) == 0x0021C8, "Member 'AVenomCharacter::SymbioteCapsuleComponent' has a wrong offset!");
static_assert(offsetof(AVenomCharacter, SymbioteHitShapeComponent) == 0x0021D0, "Member 'AVenomCharacter::SymbioteHitShapeComponent' has a wrong offset!");
static_assert(offsetof(AVenomCharacter, SymbioteInterpSpeed) == 0x0021D8, "Member 'AVenomCharacter::SymbioteInterpSpeed' has a wrong offset!");
static_assert(offsetof(AVenomCharacter, SymbioteFallingInterpSpeed) == 0x0021DC, "Member 'AVenomCharacter::SymbioteFallingInterpSpeed' has a wrong offset!");
static_assert(offsetof(AVenomCharacter, TriggerRotateSpeed) == 0x0021E0, "Member 'AVenomCharacter::TriggerRotateSpeed' has a wrong offset!");
static_assert(offsetof(AVenomCharacter, VenomMoveLogic) == 0x0021E8, "Member 'AVenomCharacter::VenomMoveLogic' has a wrong offset!");
static_assert(offsetof(AVenomCharacter, bLoopAnim) == 0x0021F0, "Member 'AVenomCharacter::bLoopAnim' has a wrong offset!");
static_assert(offsetof(AVenomCharacter, bIsEnableSymbioteCollision) == 0x0021F1, "Member 'AVenomCharacter::bIsEnableSymbioteCollision' has a wrong offset!");
static_assert(offsetof(AVenomCharacter, OnSymbioteStateChanged) == 0x0021F8, "Member 'AVenomCharacter::OnSymbioteStateChanged' has a wrong offset!");

// Class Hero_1035.VenomChildActor
// 0x1A40 (0x2860 - 0x0E20)
class AVenomChildActor : public AMarvelCharacterChildActor
{
public:
	class USkeletalMeshComponent*                 Tentacle1;                                         // 0x0E18(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 Tentacle2;                                         // 0x0E20(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 Tentacle3;                                         // 0x0E28(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 Tentacle4;                                         // 0x0E30(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      BodyFX;                                            // 0x0E38(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFXSystemAsset*                         TransitionFXAsset;                                 // 0x0E40(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTentacleAnimInfo>              TentacleAnimInfos;                                 // 0x0E48(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         TraceDistance;                                     // 0x0E58(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E5C[0x4];                                      // 0x0E5C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           TransitionFXDissolveParameterNames;                // 0x0E60(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         DefaultDissolveValue;                              // 0x0E70(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TentacleSpeedName;                                 // 0x0E74(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TentacleSpeedDeltaValue;                           // 0x0E80(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinTentacleSpeed;                                  // 0x0E84(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxTentacleSpeed;                                  // 0x0E88(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   HideName;                                          // 0x0E8C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HideSpeed;                                         // 0x0E98(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E9C[0x4];                                      // 0x0E9C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  AbilityTags;                                       // 0x0EA0(0x0068)(Edit, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  StopFXImmediatelyTags;                             // 0x0F08(0x0068)(Edit, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(int32 Value)>   DeactivateTentacleDelegate;                        // 0x0F70(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      TransitionFXComponent;                             // 0x0F80(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class USkeletalMeshComponent*>         Tentacles;                                         // 0x0F88(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<int32>                                 CurrentAnimIndex;                                  // 0x0F98(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	float                                         CurTentacleSpeed;                                  // 0x0FA8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FAC[0x4];                                      // 0x0FAC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UConfig_103521*                         TentacleAbilityConfig;                             // 0x0FB0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDeclarationHolder                     DeclarePlayerViewSideHolder;                       // 0x0FB8(0x0010)(Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_FC8[0x8];                                      // 0x0FC8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMarvelAbilityTraceContext             TraceContext;                                      // 0x0FD0(0x1660)(Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FHitResult                             CameraAimResult;                                   // 0x2630(0x01F0)(Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UNiagaraComponent*>              BodyNiagaraComponents;                             // 0x2820(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_2830[0x18];                                    // 0x2830(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UVenomCakeNiagaraComponent*>     CakeNiagaraComponents;                             // 0x2848(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_2858[0x8];                                     // 0x2858(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HideTentacle(class UAnimMontage* AnimMontage, bool bInterrupted);
	void OnComponentMaterialChanged(class UActorComponent* InActorComponent);
	void OnPlayerViewSideChanged(EClientPlayerViewSide InViewSide);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VenomChildActor">();
	}
	static class AVenomChildActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVenomChildActor>();
	}
};
static_assert(alignof(AVenomChildActor) == 0x000010, "Wrong alignment on AVenomChildActor");
static_assert(sizeof(AVenomChildActor) == 0x002860, "Wrong size on AVenomChildActor");
static_assert(offsetof(AVenomChildActor, Tentacle1) == 0x000E18, "Member 'AVenomChildActor::Tentacle1' has a wrong offset!");
static_assert(offsetof(AVenomChildActor, Tentacle2) == 0x000E20, "Member 'AVenomChildActor::Tentacle2' has a wrong offset!");
static_assert(offsetof(AVenomChildActor, Tentacle3) == 0x000E28, "Member 'AVenomChildActor::Tentacle3' has a wrong offset!");
static_assert(offsetof(AVenomChildActor, Tentacle4) == 0x000E30, "Member 'AVenomChildActor::Tentacle4' has a wrong offset!");
static_assert(offsetof(AVenomChildActor, BodyFX) == 0x000E38, "Member 'AVenomChildActor::BodyFX' has a wrong offset!");
static_assert(offsetof(AVenomChildActor, TransitionFXAsset) == 0x000E40, "Member 'AVenomChildActor::TransitionFXAsset' has a wrong offset!");
static_assert(offsetof(AVenomChildActor, TentacleAnimInfos) == 0x000E48, "Member 'AVenomChildActor::TentacleAnimInfos' has a wrong offset!");
static_assert(offsetof(AVenomChildActor, TraceDistance) == 0x000E58, "Member 'AVenomChildActor::TraceDistance' has a wrong offset!");
static_assert(offsetof(AVenomChildActor, TransitionFXDissolveParameterNames) == 0x000E60, "Member 'AVenomChildActor::TransitionFXDissolveParameterNames' has a wrong offset!");
static_assert(offsetof(AVenomChildActor, DefaultDissolveValue) == 0x000E70, "Member 'AVenomChildActor::DefaultDissolveValue' has a wrong offset!");
static_assert(offsetof(AVenomChildActor, TentacleSpeedName) == 0x000E74, "Member 'AVenomChildActor::TentacleSpeedName' has a wrong offset!");
static_assert(offsetof(AVenomChildActor, TentacleSpeedDeltaValue) == 0x000E80, "Member 'AVenomChildActor::TentacleSpeedDeltaValue' has a wrong offset!");
static_assert(offsetof(AVenomChildActor, MinTentacleSpeed) == 0x000E84, "Member 'AVenomChildActor::MinTentacleSpeed' has a wrong offset!");
static_assert(offsetof(AVenomChildActor, MaxTentacleSpeed) == 0x000E88, "Member 'AVenomChildActor::MaxTentacleSpeed' has a wrong offset!");
static_assert(offsetof(AVenomChildActor, HideName) == 0x000E8C, "Member 'AVenomChildActor::HideName' has a wrong offset!");
static_assert(offsetof(AVenomChildActor, HideSpeed) == 0x000E98, "Member 'AVenomChildActor::HideSpeed' has a wrong offset!");
static_assert(offsetof(AVenomChildActor, AbilityTags) == 0x000EA0, "Member 'AVenomChildActor::AbilityTags' has a wrong offset!");
static_assert(offsetof(AVenomChildActor, StopFXImmediatelyTags) == 0x000F08, "Member 'AVenomChildActor::StopFXImmediatelyTags' has a wrong offset!");
static_assert(offsetof(AVenomChildActor, DeactivateTentacleDelegate) == 0x000F70, "Member 'AVenomChildActor::DeactivateTentacleDelegate' has a wrong offset!");
static_assert(offsetof(AVenomChildActor, TransitionFXComponent) == 0x000F80, "Member 'AVenomChildActor::TransitionFXComponent' has a wrong offset!");
static_assert(offsetof(AVenomChildActor, Tentacles) == 0x000F88, "Member 'AVenomChildActor::Tentacles' has a wrong offset!");
static_assert(offsetof(AVenomChildActor, CurrentAnimIndex) == 0x000F98, "Member 'AVenomChildActor::CurrentAnimIndex' has a wrong offset!");
static_assert(offsetof(AVenomChildActor, CurTentacleSpeed) == 0x000FA8, "Member 'AVenomChildActor::CurTentacleSpeed' has a wrong offset!");
static_assert(offsetof(AVenomChildActor, TentacleAbilityConfig) == 0x000FB0, "Member 'AVenomChildActor::TentacleAbilityConfig' has a wrong offset!");
static_assert(offsetof(AVenomChildActor, DeclarePlayerViewSideHolder) == 0x000FB8, "Member 'AVenomChildActor::DeclarePlayerViewSideHolder' has a wrong offset!");
static_assert(offsetof(AVenomChildActor, TraceContext) == 0x000FD0, "Member 'AVenomChildActor::TraceContext' has a wrong offset!");
static_assert(offsetof(AVenomChildActor, CameraAimResult) == 0x002630, "Member 'AVenomChildActor::CameraAimResult' has a wrong offset!");
static_assert(offsetof(AVenomChildActor, BodyNiagaraComponents) == 0x002820, "Member 'AVenomChildActor::BodyNiagaraComponents' has a wrong offset!");
static_assert(offsetof(AVenomChildActor, CakeNiagaraComponents) == 0x002848, "Member 'AVenomChildActor::CakeNiagaraComponents' has a wrong offset!");

// Class Hero_1035.VenomMoveLogicBaseComponent
// 0x0000 (0x0400 - 0x0400)
class UVenomMoveLogicBaseComponent final : public UMarvelMoveLogicBaseComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VenomMoveLogicBaseComponent">();
	}
	static class UVenomMoveLogicBaseComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVenomMoveLogicBaseComponent>();
	}
};
static_assert(alignof(UVenomMoveLogicBaseComponent) == 0x000008, "Wrong alignment on UVenomMoveLogicBaseComponent");
static_assert(sizeof(UVenomMoveLogicBaseComponent) == 0x000400, "Wrong size on UVenomMoveLogicBaseComponent");

// Class Hero_1035.VenomMovementComponent
// 0x0040 (0x3C60 - 0x3C20)
class UVenomMovementComponent final : public UCharacterWallRunningComponent
{
public:
	bool                                          bEnableAvoidMeshPenetrationTrace;                  // 0x3C18(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C19[0x3];                                     // 0x3C19(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AwayFromWallScale;                                 // 0x3C1C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinBetweenAngleToTrace;                            // 0x3C20(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C24[0x4];                                     // 0x3C24(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                HandSocketOffset;                                  // 0x3C28(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AngleThresholdToForceSlideUpInSwinging;            // 0x3C40(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C44[0x4];                                     // 0x3C44(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UActorComponent*>                TraceComponentArray;                               // 0x3C48(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class AVenomCharacter*                        VenomCharacter;                                    // 0x3C58(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VenomMovementComponent">();
	}
	static class UVenomMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVenomMovementComponent>();
	}
};
static_assert(alignof(UVenomMovementComponent) == 0x000010, "Wrong alignment on UVenomMovementComponent");
static_assert(sizeof(UVenomMovementComponent) == 0x003C60, "Wrong size on UVenomMovementComponent");
static_assert(offsetof(UVenomMovementComponent, bEnableAvoidMeshPenetrationTrace) == 0x003C18, "Member 'UVenomMovementComponent::bEnableAvoidMeshPenetrationTrace' has a wrong offset!");
static_assert(offsetof(UVenomMovementComponent, AwayFromWallScale) == 0x003C1C, "Member 'UVenomMovementComponent::AwayFromWallScale' has a wrong offset!");
static_assert(offsetof(UVenomMovementComponent, MinBetweenAngleToTrace) == 0x003C20, "Member 'UVenomMovementComponent::MinBetweenAngleToTrace' has a wrong offset!");
static_assert(offsetof(UVenomMovementComponent, HandSocketOffset) == 0x003C28, "Member 'UVenomMovementComponent::HandSocketOffset' has a wrong offset!");
static_assert(offsetof(UVenomMovementComponent, AngleThresholdToForceSlideUpInSwinging) == 0x003C40, "Member 'UVenomMovementComponent::AngleThresholdToForceSlideUpInSwinging' has a wrong offset!");
static_assert(offsetof(UVenomMovementComponent, TraceComponentArray) == 0x003C48, "Member 'UVenomMovementComponent::TraceComponentArray' has a wrong offset!");
static_assert(offsetof(UVenomMovementComponent, VenomCharacter) == 0x003C58, "Member 'UVenomMovementComponent::VenomCharacter' has a wrong offset!");

}

