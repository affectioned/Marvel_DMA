#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Hero_1037

#include "Basic.hpp"

#include "GameplayTags_structs.hpp"
#include "Hero_1037_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "Marvel_structs.hpp"
#include "Marvel_classes.hpp"
#include "DeclarativeUnreal_structs.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"


namespace SDK
{

// Class Hero_1037.Config_103701
// 0x0020 (0x1970 - 0x1950)
class UConfig_103701 final : public UMarvelSelectTargetConfig
{
public:
	struct FGameplayTag                           Iron01CueTag;                                      // 0x1948(0x000C)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1954[0x4];                                     // 0x1954(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FIronInfo_103701>               IronInfos;                                         // 0x1958(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1968[0x8];                                     // 0x1968(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_103701">();
	}
	static class UConfig_103701* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_103701>();
	}
};
static_assert(alignof(UConfig_103701) == 0x000010, "Wrong alignment on UConfig_103701");
static_assert(sizeof(UConfig_103701) == 0x001970, "Wrong size on UConfig_103701");
static_assert(offsetof(UConfig_103701, Iron01CueTag) == 0x001948, "Member 'UConfig_103701::Iron01CueTag' has a wrong offset!");
static_assert(offsetof(UConfig_103701, IronInfos) == 0x001958, "Member 'UConfig_103701::IronInfos' has a wrong offset!");

// Class Hero_1037.Ability_103701
// 0x0080 (0x2A70 - 0x29F0)
class UAbility_103701 : public UMarvelGameplayAbility
{
public:
	TMulticastInlineDelegate<void(int32 IronCount)> IronCountChangedDispatcher;                      // 0x29F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMap<int32, class FName>                      ActivateAbilityEventNameMap;                       // 0x2A00(0x0050)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class AMagnetoCharacter*                      OwnerChar;                                         // 0x2A50(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableIronRecover;                                // 0x2A58(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A59[0x3];                                     // 0x2A59(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LastTimeIronCount;                                 // 0x2A5C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UConfig_103701*                         Config_103701;                                     // 0x2A60(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCapsuleComponent*                      OwnerCharacterCapsuleComponent;                    // 0x2A68(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void AddIronByValue(float Value, EIronRecoverType NewRecoverType);
	void AddIronCount(int32 AddCount, EIronRecoverType NewRecoverType);
	void AddIronCue();
	void CheckIfNewIronGenerated(EIronRecoverType RecoverType);
	void DisableIronRecover();
	void DrawDebugShape(const struct FTraceShape& ShapeA, const struct FTraceShape& ShapeB, const struct FTransform& TransformA, const struct FTransform& TransformB);
	void EnableIronRecover();
	struct FGameplayTag GetAbilityCostType();
	int32 GetCurrentIronCount();
	int32 GetFireIronIndex();
	void OnIronCountChange();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_103701">();
	}
	static class UAbility_103701* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_103701>();
	}
};
static_assert(alignof(UAbility_103701) == 0x000008, "Wrong alignment on UAbility_103701");
static_assert(sizeof(UAbility_103701) == 0x002A70, "Wrong size on UAbility_103701");
static_assert(offsetof(UAbility_103701, IronCountChangedDispatcher) == 0x0029F0, "Member 'UAbility_103701::IronCountChangedDispatcher' has a wrong offset!");
static_assert(offsetof(UAbility_103701, ActivateAbilityEventNameMap) == 0x002A00, "Member 'UAbility_103701::ActivateAbilityEventNameMap' has a wrong offset!");
static_assert(offsetof(UAbility_103701, OwnerChar) == 0x002A50, "Member 'UAbility_103701::OwnerChar' has a wrong offset!");
static_assert(offsetof(UAbility_103701, bEnableIronRecover) == 0x002A58, "Member 'UAbility_103701::bEnableIronRecover' has a wrong offset!");
static_assert(offsetof(UAbility_103701, LastTimeIronCount) == 0x002A5C, "Member 'UAbility_103701::LastTimeIronCount' has a wrong offset!");
static_assert(offsetof(UAbility_103701, Config_103701) == 0x002A60, "Member 'UAbility_103701::Config_103701' has a wrong offset!");
static_assert(offsetof(UAbility_103701, OwnerCharacterCapsuleComponent) == 0x002A68, "Member 'UAbility_103701::OwnerCharacterCapsuleComponent' has a wrong offset!");

// Class Hero_1037.Config_103702
// 0x0020 (0x0118 - 0x00F8)
class UConfig_103702 final : public UConfig_AeroBase
{
public:
	struct FGameplayTag                           LoopAudioCue;                                      // 0x00F8(0x000C)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LoopCueDelay;                                      // 0x0104(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           EndAudioCue;                                       // 0x0108(0x000C)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndCueDelay;                                       // 0x0114(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_103702">();
	}
	static class UConfig_103702* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_103702>();
	}
};
static_assert(alignof(UConfig_103702) == 0x000008, "Wrong alignment on UConfig_103702");
static_assert(sizeof(UConfig_103702) == 0x000118, "Wrong size on UConfig_103702");
static_assert(offsetof(UConfig_103702, LoopAudioCue) == 0x0000F8, "Member 'UConfig_103702::LoopAudioCue' has a wrong offset!");
static_assert(offsetof(UConfig_103702, LoopCueDelay) == 0x000104, "Member 'UConfig_103702::LoopCueDelay' has a wrong offset!");
static_assert(offsetof(UConfig_103702, EndAudioCue) == 0x000108, "Member 'UConfig_103702::EndAudioCue' has a wrong offset!");
static_assert(offsetof(UConfig_103702, EndCueDelay) == 0x000114, "Member 'UConfig_103702::EndCueDelay' has a wrong offset!");

// Class Hero_1037.Config_103711
// 0x0000 (0x0098 - 0x0098)
class UConfig_103711 final : public UMarvelAbilityConfig
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_103711">();
	}
	static class UConfig_103711* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_103711>();
	}
};
static_assert(alignof(UConfig_103711) == 0x000008, "Wrong alignment on UConfig_103711");
static_assert(sizeof(UConfig_103711) == 0x000098, "Wrong size on UConfig_103711");

// Class Hero_1037.Projectile_10371101
// 0x0030 (0x3BC0 - 0x3B90)
class AProjectile_10371101 : public AMarvelAbilityTargetActor_Projectile
{
public:
	int32                                         EffectiveScopeID;                                  // 0x3B88(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3B8C[0x4];                                     // 0x3B8C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            ProjectileRadiusCurveByTime;                       // 0x3B90(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            ProjectileDamageCurveByTime;                       // 0x3B98(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            ScopeRadiusCurveByTime;                            // 0x3BA0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            NewProjectileRadiusCurveByTime;                    // 0x3BA8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            NewScopeRadiusCurveByTime;                         // 0x3BB0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            ScopeDamageCurveByTime;                            // 0x3BB8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	float GetScopeScaleByTime(float InScopeBaseRadius) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Projectile_10371101">();
	}
	static class AProjectile_10371101* GetDefaultObj()
	{
		return GetDefaultObjImpl<AProjectile_10371101>();
	}
};
static_assert(alignof(AProjectile_10371101) == 0x000010, "Wrong alignment on AProjectile_10371101");
static_assert(sizeof(AProjectile_10371101) == 0x003BC0, "Wrong size on AProjectile_10371101");
static_assert(offsetof(AProjectile_10371101, EffectiveScopeID) == 0x003B88, "Member 'AProjectile_10371101::EffectiveScopeID' has a wrong offset!");
static_assert(offsetof(AProjectile_10371101, ProjectileRadiusCurveByTime) == 0x003B90, "Member 'AProjectile_10371101::ProjectileRadiusCurveByTime' has a wrong offset!");
static_assert(offsetof(AProjectile_10371101, ProjectileDamageCurveByTime) == 0x003B98, "Member 'AProjectile_10371101::ProjectileDamageCurveByTime' has a wrong offset!");
static_assert(offsetof(AProjectile_10371101, ScopeRadiusCurveByTime) == 0x003BA0, "Member 'AProjectile_10371101::ScopeRadiusCurveByTime' has a wrong offset!");
static_assert(offsetof(AProjectile_10371101, NewProjectileRadiusCurveByTime) == 0x003BA8, "Member 'AProjectile_10371101::NewProjectileRadiusCurveByTime' has a wrong offset!");
static_assert(offsetof(AProjectile_10371101, NewScopeRadiusCurveByTime) == 0x003BB0, "Member 'AProjectile_10371101::NewScopeRadiusCurveByTime' has a wrong offset!");
static_assert(offsetof(AProjectile_10371101, ScopeDamageCurveByTime) == 0x003BB8, "Member 'AProjectile_10371101::ScopeDamageCurveByTime' has a wrong offset!");

// Class Hero_1037.TraceComponent_10371101_Base
// 0x0000 (0x2200 - 0x2200)
class UTraceComponent_10371101_Base final : public UMarvelAgentTraceComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TraceComponent_10371101_Base">();
	}
	static class UTraceComponent_10371101_Base* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTraceComponent_10371101_Base>();
	}
};
static_assert(alignof(UTraceComponent_10371101_Base) == 0x000010, "Wrong alignment on UTraceComponent_10371101_Base");
static_assert(sizeof(UTraceComponent_10371101_Base) == 0x002200, "Wrong size on UTraceComponent_10371101_Base");

// Class Hero_1037.EffectiveComponent_10371101
// 0x0000 (0x1C70 - 0x1C70)
class UEffectiveComponent_10371101 final : public UMarvelAgentEffectiveComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EffectiveComponent_10371101">();
	}
	static class UEffectiveComponent_10371101* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEffectiveComponent_10371101>();
	}
};
static_assert(alignof(UEffectiveComponent_10371101) == 0x000010, "Wrong alignment on UEffectiveComponent_10371101");
static_assert(sizeof(UEffectiveComponent_10371101) == 0x001C70, "Wrong size on UEffectiveComponent_10371101");

// Class Hero_1037.Scope_10371101
// 0x0000 (0x1AA0 - 0x1AA0)
class AScope_10371101 final : public AMarvelAbilityTargetActor_Scope
{
public:
	float GetScopeScaleByTime(float InScopeBaseRadius) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Scope_10371101">();
	}
	static class AScope_10371101* GetDefaultObj()
	{
		return GetDefaultObjImpl<AScope_10371101>();
	}
};
static_assert(alignof(AScope_10371101) == 0x000010, "Wrong alignment on AScope_10371101");
static_assert(sizeof(AScope_10371101) == 0x001AA0, "Wrong size on AScope_10371101");

// Class Hero_1037.Projectile_10372101_Base
// 0x0000 (0x3B90 - 0x3B90)
class AProjectile_10372101_Base final : public AMarvelAbilityTargetActor_Projectile
{
public:
	class UBoxComponent*                          BoxCollisionComponent;                             // 0x3B88(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Projectile_10372101_Base">();
	}
	static class AProjectile_10372101_Base* GetDefaultObj()
	{
		return GetDefaultObjImpl<AProjectile_10372101_Base>();
	}
};
static_assert(alignof(AProjectile_10372101_Base) == 0x000010, "Wrong alignment on AProjectile_10372101_Base");
static_assert(sizeof(AProjectile_10372101_Base) == 0x003B90, "Wrong size on AProjectile_10372101_Base");
static_assert(offsetof(AProjectile_10372101_Base, BoxCollisionComponent) == 0x003B88, "Member 'AProjectile_10372101_Base::BoxCollisionComponent' has a wrong offset!");

// Class Hero_1037.Magneto_ANSTimedAttachment
// 0x0000 (0x0060 - 0x0060)
class UMagneto_ANSTimedAttachment final : public UAnimNotifyState_TimedAttachment
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Magneto_ANSTimedAttachment">();
	}
	static class UMagneto_ANSTimedAttachment* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMagneto_ANSTimedAttachment>();
	}
};
static_assert(alignof(UMagneto_ANSTimedAttachment) == 0x000008, "Wrong alignment on UMagneto_ANSTimedAttachment");
static_assert(sizeof(UMagneto_ANSTimedAttachment) == 0x000060, "Wrong size on UMagneto_ANSTimedAttachment");

// Class Hero_1037.Config_103731
// 0x0008 (0x00A0 - 0x0098)
class UConfig_103731 : public UMarvelAbilityConfig
{
public:
	float                                         MaxManipulationTime;                               // 0x0098(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_103731">();
	}
	static class UConfig_103731* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_103731>();
	}
};
static_assert(alignof(UConfig_103731) == 0x000008, "Wrong alignment on UConfig_103731");
static_assert(sizeof(UConfig_103731) == 0x0000A0, "Wrong size on UConfig_103731");
static_assert(offsetof(UConfig_103731, MaxManipulationTime) == 0x000098, "Member 'UConfig_103731::MaxManipulationTime' has a wrong offset!");

// Class Hero_1037.SummonedComp_10373101
// 0x0010 (0x0DC0 - 0x0DB0)
class USummonedComp_10373101 final : public UMarvelSummonedComponent
{
public:
	class ASummoned_10373101*                     CastedOwnerSummoned;                               // 0x0DB0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ServerEndAgentTaskTime;                            // 0x0DB8(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DBC[0x4];                                      // 0x0DBC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SummonedComp_10373101">();
	}
	static class USummonedComp_10373101* GetDefaultObj()
	{
		return GetDefaultObjImpl<USummonedComp_10373101>();
	}
};
static_assert(alignof(USummonedComp_10373101) == 0x000008, "Wrong alignment on USummonedComp_10373101");
static_assert(sizeof(USummonedComp_10373101) == 0x000DC0, "Wrong size on USummonedComp_10373101");
static_assert(offsetof(USummonedComp_10373101, CastedOwnerSummoned) == 0x000DB0, "Member 'USummonedComp_10373101::CastedOwnerSummoned' has a wrong offset!");
static_assert(offsetof(USummonedComp_10373101, ServerEndAgentTaskTime) == 0x000DB8, "Member 'USummonedComp_10373101::ServerEndAgentTaskTime' has a wrong offset!");

// Class Hero_1037.HitImpactCueOverrideModifier_Summoned10373101
// 0x0008 (0x0048 - 0x0040)
class UHitImpactCueOverrideModifier_Summoned10373101 final : public UHitImpactCueOverrideModifier
{
public:
	float                                         HitNSBoundsLimit;                                  // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HitFXScale;                                        // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HitImpactCueOverrideModifier_Summoned10373101">();
	}
	static class UHitImpactCueOverrideModifier_Summoned10373101* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHitImpactCueOverrideModifier_Summoned10373101>();
	}
};
static_assert(alignof(UHitImpactCueOverrideModifier_Summoned10373101) == 0x000008, "Wrong alignment on UHitImpactCueOverrideModifier_Summoned10373101");
static_assert(sizeof(UHitImpactCueOverrideModifier_Summoned10373101) == 0x000048, "Wrong size on UHitImpactCueOverrideModifier_Summoned10373101");
static_assert(offsetof(UHitImpactCueOverrideModifier_Summoned10373101, HitNSBoundsLimit) == 0x000040, "Member 'UHitImpactCueOverrideModifier_Summoned10373101::HitNSBoundsLimit' has a wrong offset!");
static_assert(offsetof(UHitImpactCueOverrideModifier_Summoned10373101, HitFXScale) == 0x000044, "Member 'UHitImpactCueOverrideModifier_Summoned10373101::HitFXScale' has a wrong offset!");

// Class Hero_1037.Summoned_10373101
// 0x01C0 (0x0D00 - 0x0B40)
class ASummoned_10373101 : public AMarvelSummonerBase
{
public:
	uint8                                         Pad_B40[0x90];                                     // 0x0B40(0x0090)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PitchInterpSpeed;                                  // 0x0BD0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PitchCompensation;                                 // 0x0BD4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ProjectileManipulationTime;                        // 0x0BD8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_BDC[0x4];                                      // 0x0BDC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMarvelGameplayTagRequirements         ManipulationRequirements;                          // 0x0BE0(0x00D0)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         CachedOffsetXZ;                                    // 0x0CB0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ShieldResistDamage;                                // 0x0CB4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class AMarvelAbilityTargetActor_Projectile*> LocalManipulatedProjectiles;                 // 0x0CB8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_CC8[0x28];                                     // 0x0CC8(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class UHitImpactCueOverrideModifier_Summoned10373101* HitImpactCueOverrideModifier;              // 0x0CF0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_CF8[0x8];                                      // 0x0CF8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnManipulatedProjectileRecycle(class AActor* InTarget);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Summoned_10373101">();
	}
	static class ASummoned_10373101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASummoned_10373101>();
	}
};
static_assert(alignof(ASummoned_10373101) == 0x000010, "Wrong alignment on ASummoned_10373101");
static_assert(sizeof(ASummoned_10373101) == 0x000D00, "Wrong size on ASummoned_10373101");
static_assert(offsetof(ASummoned_10373101, PitchInterpSpeed) == 0x000BD0, "Member 'ASummoned_10373101::PitchInterpSpeed' has a wrong offset!");
static_assert(offsetof(ASummoned_10373101, PitchCompensation) == 0x000BD4, "Member 'ASummoned_10373101::PitchCompensation' has a wrong offset!");
static_assert(offsetof(ASummoned_10373101, ProjectileManipulationTime) == 0x000BD8, "Member 'ASummoned_10373101::ProjectileManipulationTime' has a wrong offset!");
static_assert(offsetof(ASummoned_10373101, ManipulationRequirements) == 0x000BE0, "Member 'ASummoned_10373101::ManipulationRequirements' has a wrong offset!");
static_assert(offsetof(ASummoned_10373101, CachedOffsetXZ) == 0x000CB0, "Member 'ASummoned_10373101::CachedOffsetXZ' has a wrong offset!");
static_assert(offsetof(ASummoned_10373101, ShieldResistDamage) == 0x000CB4, "Member 'ASummoned_10373101::ShieldResistDamage' has a wrong offset!");
static_assert(offsetof(ASummoned_10373101, LocalManipulatedProjectiles) == 0x000CB8, "Member 'ASummoned_10373101::LocalManipulatedProjectiles' has a wrong offset!");
static_assert(offsetof(ASummoned_10373101, HitImpactCueOverrideModifier) == 0x000CF0, "Member 'ASummoned_10373101::HitImpactCueOverrideModifier' has a wrong offset!");

// Class Hero_1037.Cue_Summoned_Loop_10373101
// 0x0150 (0x1350 - 0x1200)
class ACue_Summoned_Loop_10373101 : public AMarvelCueNotify_Summoned
{
public:
	int32                                         MaxAmmoManipulationLimit;                          // 0x11F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxProjectileManipulationLimit;                    // 0x11FC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HoveringTimeForDefault;                            // 0x1200(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HoveringTimeForFastFalling;                        // 0x1204(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BulletVisualSizeForDefault;                        // 0x1208(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ProjectileRecycleDelayAfterHit;                    // 0x120C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   StopParticleParameterName;                         // 0x1210(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   PhysicsParameterName;                              // 0x121C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   MagicEntityDissolveParameterName;                  // 0x1228(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1234[0x4];                                     // 0x1234(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCueUserData_FloatCurve*                MagicEntityDissolveCueData;                        // 0x1238(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MagicEntityDissolveDuration;                       // 0x1240(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFXSystemReleaseMethod                        MagicEntityReleaseMethod;                          // 0x1244(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1245[0x3];                                     // 0x1245(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AmmoPhysicsForceDestroyTime;                       // 0x1248(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_124C[0x4];                                     // 0x124C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FManipulationPhysicsSpec>       ProjectilePhysicsSpecs;                            // 0x1250(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         EnergyFieldBaseSize;                               // 0x1260(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EnergyFieldScaleMin;                               // 0x1264(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EnergyFieldScaleMax;                               // 0x1268(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_126C[0x4];                                     // 0x126C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UFXSystemAsset*                         EnergyFieldLoopFX;                                 // 0x1270(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFXSystemAsset*                         EnergyFieldStartFX;                                // 0x1278(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFXSystemAsset*                         EnergyFieldEndFX;                                  // 0x1280(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EnergyFieldDeactiveDelay;                          // 0x1288(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         OverlapEnergyFieldRadius;                          // 0x128C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         OverlapEnergyFieldLimit;                           // 0x1290(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1294[0x4];                                     // 0x1294(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USphereComponent*                       SimColliderTemplate;                               // 0x1298(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class USphereComponent*>               ProjectileSimColliders;                            // 0x12A0(0x0010)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<struct FManipulationActiveSimulation>  ActiveSimulations;                                 // 0x12B0(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class FString>                         ActiveAmmoFXNames;                                 // 0x12C0(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	TArray<class FString>                         ActiveProjectileFXNames;                           // 0x12D0(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	TMap<struct FVector, int32>                   OverlapEnergyFieldMap;                             // 0x12E0(0x0050)(BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1330[0x20];                                    // 0x1330(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CheckIfNeedSetEnergyFieldActive(const struct FVector& InHitLocation);
	void FXBeginFadeOut(class UFXSystemComponent* FXComponent);
	void HandleActiveFXComponentOnExecute(struct FManipulationActiveSimulation* InActiveSimulation);
	void OnFXFadeOutEnd(class UFXSystemComponent* FXComponent, class UCueDataProcessor_FloatCurve* InProcessor);
	void OnManipulatedProjectileNoForceEnd(class AMarvelAbilityTargetActor_Projectile* InProjectile);
	void OnProjectileCueAttached(class USceneComponent* InComponent, class USceneComponent* InChildComponent);
	void OnProjectileRecycle(class AActor* ProjectileActor);
	void OnSimColliderHit(class UPrimitiveComponent* InComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& InHit);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Summoned_Loop_10373101">();
	}
	static class ACue_Summoned_Loop_10373101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Summoned_Loop_10373101>();
	}
};
static_assert(alignof(ACue_Summoned_Loop_10373101) == 0x000010, "Wrong alignment on ACue_Summoned_Loop_10373101");
static_assert(sizeof(ACue_Summoned_Loop_10373101) == 0x001350, "Wrong size on ACue_Summoned_Loop_10373101");
static_assert(offsetof(ACue_Summoned_Loop_10373101, MaxAmmoManipulationLimit) == 0x0011F8, "Member 'ACue_Summoned_Loop_10373101::MaxAmmoManipulationLimit' has a wrong offset!");
static_assert(offsetof(ACue_Summoned_Loop_10373101, MaxProjectileManipulationLimit) == 0x0011FC, "Member 'ACue_Summoned_Loop_10373101::MaxProjectileManipulationLimit' has a wrong offset!");
static_assert(offsetof(ACue_Summoned_Loop_10373101, HoveringTimeForDefault) == 0x001200, "Member 'ACue_Summoned_Loop_10373101::HoveringTimeForDefault' has a wrong offset!");
static_assert(offsetof(ACue_Summoned_Loop_10373101, HoveringTimeForFastFalling) == 0x001204, "Member 'ACue_Summoned_Loop_10373101::HoveringTimeForFastFalling' has a wrong offset!");
static_assert(offsetof(ACue_Summoned_Loop_10373101, BulletVisualSizeForDefault) == 0x001208, "Member 'ACue_Summoned_Loop_10373101::BulletVisualSizeForDefault' has a wrong offset!");
static_assert(offsetof(ACue_Summoned_Loop_10373101, ProjectileRecycleDelayAfterHit) == 0x00120C, "Member 'ACue_Summoned_Loop_10373101::ProjectileRecycleDelayAfterHit' has a wrong offset!");
static_assert(offsetof(ACue_Summoned_Loop_10373101, StopParticleParameterName) == 0x001210, "Member 'ACue_Summoned_Loop_10373101::StopParticleParameterName' has a wrong offset!");
static_assert(offsetof(ACue_Summoned_Loop_10373101, PhysicsParameterName) == 0x00121C, "Member 'ACue_Summoned_Loop_10373101::PhysicsParameterName' has a wrong offset!");
static_assert(offsetof(ACue_Summoned_Loop_10373101, MagicEntityDissolveParameterName) == 0x001228, "Member 'ACue_Summoned_Loop_10373101::MagicEntityDissolveParameterName' has a wrong offset!");
static_assert(offsetof(ACue_Summoned_Loop_10373101, MagicEntityDissolveCueData) == 0x001238, "Member 'ACue_Summoned_Loop_10373101::MagicEntityDissolveCueData' has a wrong offset!");
static_assert(offsetof(ACue_Summoned_Loop_10373101, MagicEntityDissolveDuration) == 0x001240, "Member 'ACue_Summoned_Loop_10373101::MagicEntityDissolveDuration' has a wrong offset!");
static_assert(offsetof(ACue_Summoned_Loop_10373101, MagicEntityReleaseMethod) == 0x001244, "Member 'ACue_Summoned_Loop_10373101::MagicEntityReleaseMethod' has a wrong offset!");
static_assert(offsetof(ACue_Summoned_Loop_10373101, AmmoPhysicsForceDestroyTime) == 0x001248, "Member 'ACue_Summoned_Loop_10373101::AmmoPhysicsForceDestroyTime' has a wrong offset!");
static_assert(offsetof(ACue_Summoned_Loop_10373101, ProjectilePhysicsSpecs) == 0x001250, "Member 'ACue_Summoned_Loop_10373101::ProjectilePhysicsSpecs' has a wrong offset!");
static_assert(offsetof(ACue_Summoned_Loop_10373101, EnergyFieldBaseSize) == 0x001260, "Member 'ACue_Summoned_Loop_10373101::EnergyFieldBaseSize' has a wrong offset!");
static_assert(offsetof(ACue_Summoned_Loop_10373101, EnergyFieldScaleMin) == 0x001264, "Member 'ACue_Summoned_Loop_10373101::EnergyFieldScaleMin' has a wrong offset!");
static_assert(offsetof(ACue_Summoned_Loop_10373101, EnergyFieldScaleMax) == 0x001268, "Member 'ACue_Summoned_Loop_10373101::EnergyFieldScaleMax' has a wrong offset!");
static_assert(offsetof(ACue_Summoned_Loop_10373101, EnergyFieldLoopFX) == 0x001270, "Member 'ACue_Summoned_Loop_10373101::EnergyFieldLoopFX' has a wrong offset!");
static_assert(offsetof(ACue_Summoned_Loop_10373101, EnergyFieldStartFX) == 0x001278, "Member 'ACue_Summoned_Loop_10373101::EnergyFieldStartFX' has a wrong offset!");
static_assert(offsetof(ACue_Summoned_Loop_10373101, EnergyFieldEndFX) == 0x001280, "Member 'ACue_Summoned_Loop_10373101::EnergyFieldEndFX' has a wrong offset!");
static_assert(offsetof(ACue_Summoned_Loop_10373101, EnergyFieldDeactiveDelay) == 0x001288, "Member 'ACue_Summoned_Loop_10373101::EnergyFieldDeactiveDelay' has a wrong offset!");
static_assert(offsetof(ACue_Summoned_Loop_10373101, OverlapEnergyFieldRadius) == 0x00128C, "Member 'ACue_Summoned_Loop_10373101::OverlapEnergyFieldRadius' has a wrong offset!");
static_assert(offsetof(ACue_Summoned_Loop_10373101, OverlapEnergyFieldLimit) == 0x001290, "Member 'ACue_Summoned_Loop_10373101::OverlapEnergyFieldLimit' has a wrong offset!");
static_assert(offsetof(ACue_Summoned_Loop_10373101, SimColliderTemplate) == 0x001298, "Member 'ACue_Summoned_Loop_10373101::SimColliderTemplate' has a wrong offset!");
static_assert(offsetof(ACue_Summoned_Loop_10373101, ProjectileSimColliders) == 0x0012A0, "Member 'ACue_Summoned_Loop_10373101::ProjectileSimColliders' has a wrong offset!");
static_assert(offsetof(ACue_Summoned_Loop_10373101, ActiveSimulations) == 0x0012B0, "Member 'ACue_Summoned_Loop_10373101::ActiveSimulations' has a wrong offset!");
static_assert(offsetof(ACue_Summoned_Loop_10373101, ActiveAmmoFXNames) == 0x0012C0, "Member 'ACue_Summoned_Loop_10373101::ActiveAmmoFXNames' has a wrong offset!");
static_assert(offsetof(ACue_Summoned_Loop_10373101, ActiveProjectileFXNames) == 0x0012D0, "Member 'ACue_Summoned_Loop_10373101::ActiveProjectileFXNames' has a wrong offset!");
static_assert(offsetof(ACue_Summoned_Loop_10373101, OverlapEnergyFieldMap) == 0x0012E0, "Member 'ACue_Summoned_Loop_10373101::OverlapEnergyFieldMap' has a wrong offset!");

// Class Hero_1037.Config_103741
// 0x0020 (0x18A0 - 0x1880)
class UConfig_103741 : public USelectAbilityConfigBase
{
public:
	float                                         DamageTransformRate;                               // 0x1878(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StandardCapsuleHalfHeight;                         // 0x187C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StandardCapsuleRadius;                             // 0x1880(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1884[0x4];                                     // 0x1884(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 ApplyBuffIDs;                                      // 0x1888(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         Pad_1898[0x8];                                     // 0x1898(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_103741">();
	}
	static class UConfig_103741* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_103741>();
	}
};
static_assert(alignof(UConfig_103741) == 0x000010, "Wrong alignment on UConfig_103741");
static_assert(sizeof(UConfig_103741) == 0x0018A0, "Wrong size on UConfig_103741");
static_assert(offsetof(UConfig_103741, DamageTransformRate) == 0x001878, "Member 'UConfig_103741::DamageTransformRate' has a wrong offset!");
static_assert(offsetof(UConfig_103741, StandardCapsuleHalfHeight) == 0x00187C, "Member 'UConfig_103741::StandardCapsuleHalfHeight' has a wrong offset!");
static_assert(offsetof(UConfig_103741, StandardCapsuleRadius) == 0x001880, "Member 'UConfig_103741::StandardCapsuleRadius' has a wrong offset!");
static_assert(offsetof(UConfig_103741, ApplyBuffIDs) == 0x001888, "Member 'UConfig_103741::ApplyBuffIDs' has a wrong offset!");

// Class Hero_1037.Summoned_10374101
// 0x0000 (0x0C20 - 0x0C20)
class ASummoned_10374101 : public AProtectiveSummoner
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Summoned_10374101">();
	}
	static class ASummoned_10374101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASummoned_10374101>();
	}
};
static_assert(alignof(ASummoned_10374101) == 0x000010, "Wrong alignment on ASummoned_10374101");
static_assert(sizeof(ASummoned_10374101) == 0x000C20, "Wrong size on ASummoned_10374101");

// Class Hero_1037.CueSummonerLoopCue_10374101
// 0x0000 (0x1200 - 0x1200)
class ACueSummonerLoopCue_10374101 : public AMarvelCueNotify_Summoned
{
public:
	class UNiagaraComponent*                      ShieldNiagara;                                     // 0x11F8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CueSummonerLoopCue_10374101">();
	}
	static class ACueSummonerLoopCue_10374101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACueSummonerLoopCue_10374101>();
	}
};
static_assert(alignof(ACueSummonerLoopCue_10374101) == 0x000010, "Wrong alignment on ACueSummonerLoopCue_10374101");
static_assert(sizeof(ACueSummonerLoopCue_10374101) == 0x001200, "Wrong size on ACueSummonerLoopCue_10374101");
static_assert(offsetof(ACueSummonerLoopCue_10374101, ShieldNiagara) == 0x0011F8, "Member 'ACueSummonerLoopCue_10374101::ShieldNiagara' has a wrong offset!");

// Class Hero_1037.Ability_103751
// 0x0008 (0x2C48 - 0x2C40)
class UAbility_103751 : public UMarvelSelectTargetAbility
{
public:
	bool                                          bEnterMissile;                                     // 0x2C40(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNeedRecover;                                      // 0x2C41(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsAdsorbing;                                      // 0x2C42(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C43[0x5];                                     // 0x2C43(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class APhysicsSummoner* GetSelectTarget();
	bool IsAdsorbing();
	bool IsAdsorbSucceed();
	void RegisterPhysicsSummoner(class AActor* SelectTarget);
	void UnRegisterPhysicsSummoner(class AActor* SelectTarget);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_103751">();
	}
	static class UAbility_103751* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_103751>();
	}
};
static_assert(alignof(UAbility_103751) == 0x000008, "Wrong alignment on UAbility_103751");
static_assert(sizeof(UAbility_103751) == 0x002C48, "Wrong size on UAbility_103751");
static_assert(offsetof(UAbility_103751, bEnterMissile) == 0x002C40, "Member 'UAbility_103751::bEnterMissile' has a wrong offset!");
static_assert(offsetof(UAbility_103751, bNeedRecover) == 0x002C41, "Member 'UAbility_103751::bNeedRecover' has a wrong offset!");
static_assert(offsetof(UAbility_103751, bIsAdsorbing) == 0x002C42, "Member 'UAbility_103751::bIsAdsorbing' has a wrong offset!");

// Class Hero_1037.Config_103751
// 0x0000 (0x1950 - 0x1950)
class UConfig_103751 : public UMarvelSelectTargetConfig
{
public:
	float                                         AbsorbDuration;                                    // 0x1948(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_194C[0x4];                                     // 0x194C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_103751">();
	}
	static class UConfig_103751* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_103751>();
	}
};
static_assert(alignof(UConfig_103751) == 0x000010, "Wrong alignment on UConfig_103751");
static_assert(sizeof(UConfig_103751) == 0x001950, "Wrong size on UConfig_103751");
static_assert(offsetof(UConfig_103751, AbsorbDuration) == 0x001948, "Member 'UConfig_103751::AbsorbDuration' has a wrong offset!");

// Class Hero_1037.Cue_Ability_Loop_103751
// 0x0050 (0x1200 - 0x11B0)
class ACue_Ability_Loop_103751 final : public AMarvelCueNotify_Ability
{
public:
	class UCurveFloat*                            DissolveCurve;                                     // 0x11B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableMaterialLerpRecover;                        // 0x11B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11B9[0x3];                                     // 0x11B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LerpRecoverTime;                                   // 0x11BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DissolveOriginValue;                               // 0x11C0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TotalDissolveTime;                                 // 0x11C4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentDissolveTime;                               // 0x11C8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurDissolveVal;                                    // 0x11CC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HighestDissolveVal;                                // 0x11D0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11D4[0x4];                                     // 0x11D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class APhysicsSummoner*                       TargetActor;                                       // 0x11D8(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AMarvelBaseCharacter*                   OwnerCharacter;                                    // 0x11E0(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAbility_103751*                        OwningAbility;                                     // 0x11E8(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DissolveParamName;                                 // 0x11F0(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11FC[0x4];                                     // 0x11FC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetCurveValue(float CurTime);
	void RecoverTargetActorMaterial();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Ability_Loop_103751">();
	}
	static class ACue_Ability_Loop_103751* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Ability_Loop_103751>();
	}
};
static_assert(alignof(ACue_Ability_Loop_103751) == 0x000010, "Wrong alignment on ACue_Ability_Loop_103751");
static_assert(sizeof(ACue_Ability_Loop_103751) == 0x001200, "Wrong size on ACue_Ability_Loop_103751");
static_assert(offsetof(ACue_Ability_Loop_103751, DissolveCurve) == 0x0011B0, "Member 'ACue_Ability_Loop_103751::DissolveCurve' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_103751, bEnableMaterialLerpRecover) == 0x0011B8, "Member 'ACue_Ability_Loop_103751::bEnableMaterialLerpRecover' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_103751, LerpRecoverTime) == 0x0011BC, "Member 'ACue_Ability_Loop_103751::LerpRecoverTime' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_103751, DissolveOriginValue) == 0x0011C0, "Member 'ACue_Ability_Loop_103751::DissolveOriginValue' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_103751, TotalDissolveTime) == 0x0011C4, "Member 'ACue_Ability_Loop_103751::TotalDissolveTime' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_103751, CurrentDissolveTime) == 0x0011C8, "Member 'ACue_Ability_Loop_103751::CurrentDissolveTime' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_103751, CurDissolveVal) == 0x0011CC, "Member 'ACue_Ability_Loop_103751::CurDissolveVal' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_103751, HighestDissolveVal) == 0x0011D0, "Member 'ACue_Ability_Loop_103751::HighestDissolveVal' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_103751, TargetActor) == 0x0011D8, "Member 'ACue_Ability_Loop_103751::TargetActor' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_103751, OwnerCharacter) == 0x0011E0, "Member 'ACue_Ability_Loop_103751::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_103751, OwningAbility) == 0x0011E8, "Member 'ACue_Ability_Loop_103751::OwningAbility' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_103751, DissolveParamName) == 0x0011F0, "Member 'ACue_Ability_Loop_103751::DissolveParamName' has a wrong offset!");

// Class Hero_1037.MeteoriteInteractorSubsystem
// 0x0030 (0x0068 - 0x0038)
class UMeteoriteInteractorSubsystem final : public UWorldSubsystem
{
public:
	TArray<class AActor*>                         TotalInteractiveActors;                            // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	struct FTimerHandle                           TimerHandle;                                       // 0x0048(0x0018)(HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UConfig_103761*                         Config;                                            // 0x0060(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UMeteoriteInteractorSubsystem* Get(class UObject* WorldObject);

	void AddInteractiveActor(class AActor* InActor);
	void CheckInteractorAutoDestroy();
	float GetMinDistToCharacter(class AActor* InActor, const TArray<class AMarvelBaseCharacter*>& InCharacters);
	const int32 GetTotalNum();
	void RemoveInteractiveActor(class AActor* InActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MeteoriteInteractorSubsystem">();
	}
	static class UMeteoriteInteractorSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMeteoriteInteractorSubsystem>();
	}
};
static_assert(alignof(UMeteoriteInteractorSubsystem) == 0x000008, "Wrong alignment on UMeteoriteInteractorSubsystem");
static_assert(sizeof(UMeteoriteInteractorSubsystem) == 0x000068, "Wrong size on UMeteoriteInteractorSubsystem");
static_assert(offsetof(UMeteoriteInteractorSubsystem, TotalInteractiveActors) == 0x000038, "Member 'UMeteoriteInteractorSubsystem::TotalInteractiveActors' has a wrong offset!");
static_assert(offsetof(UMeteoriteInteractorSubsystem, TimerHandle) == 0x000048, "Member 'UMeteoriteInteractorSubsystem::TimerHandle' has a wrong offset!");
static_assert(offsetof(UMeteoriteInteractorSubsystem, Config) == 0x000060, "Member 'UMeteoriteInteractorSubsystem::Config' has a wrong offset!");

// Class Hero_1037.Config_103761
// 0x1D68 (0x1E60 - 0x00F8)
class UConfig_103761 : public UConfig_AeroBase
{
public:
	float                                         LoopDuration;                                      // 0x00F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageToPowerRatio;                                // 0x00FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxPowerValue;                                     // 0x0100(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultProjectileDamage;                           // 0x0104(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<int32, float>                            SpecialProjectileDamageMap;                        // 0x0108(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UCurveFloat*                            FXGrowCurve;                                       // 0x0158(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            SummonedGrowCurve;                                 // 0x0160(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            HomingAccelerationCurve;                           // 0x0168(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            HomingCaptureFactorCurve;                          // 0x0170(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxHomingSpeed;                                    // 0x0178(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxTangentSpeed;                                   // 0x017C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EPhysicsWeaponType, int32>               GenTypeCountMap;                                   // 0x0180(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FWeaponUseInfo>                 WeaponUseInfos;                                    // 0x01D0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         ScopeID;                                           // 0x01E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E4[0xC];                                      // 0x01E4(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLoopAdsorbTaskParameters              AdsorbParameters;                                  // 0x01F0(0x1780)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	int32                                         PointNum;                                          // 0x1970(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1974[0x4];                                     // 0x1974(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                SummonedOffset;                                    // 0x1978(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            SummonedOffsetCurve;                               // 0x1990(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SummonedMoveDuration;                              // 0x1998(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinSummonedOffsetX;                                // 0x199C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSummonedOffsetX;                                // 0x19A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SummonedID;                                        // 0x19A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SummonedID1;                                       // 0x19A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19AC[0x4];                                     // 0x19AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMarvelTraceRule                       SummonedCollisionTrace;                            // 0x19B0(0x0398)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         SphereRadius;                                      // 0x1D48(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D4C[0x4];                                     // 0x1D4C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EPhysicsWeaponType, TSoftClassPtr<class UClass>> PhysicsSummonerAssets;                     // 0x1D50(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	struct FGameplayTag                           NoAdsorbTag;                                       // 0x1DA0(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1DAC[0x4];                                     // 0x1DAC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  NoForceEndTags;                                    // 0x1DB0(0x0068)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         CheckDistance;                                     // 0x1E18(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CheckDistanceXPos;                                 // 0x1E1C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CheckDistanceXNeg;                                 // 0x1E20(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CheckDistanceYPos;                                 // 0x1E24(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CheckDistanceYNeg;                                 // 0x1E28(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bResetLiftSpan;                                    // 0x1E2C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bResetMaxFlyDistance;                              // 0x1E2D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E2E[0x2];                                     // 0x1E2E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LiftTime;                                          // 0x1E30(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NewLocalVelocity;                                  // 0x1E34(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ControlPointDistance;                              // 0x1E38(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxTotalInteractorNum;                             // 0x1E3C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InteractorNumToCheck;                              // 0x1E40(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InteractorNumToDestroy;                            // 0x1E44(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimerInterval;                                     // 0x1E48(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SummonedReplicatedMovementTolerance;               // 0x1E4C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdsorbLargePhysicsSummonerAudioID;                 // 0x1E50(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdsorbOtherPhysicsSummonerAudioID;                 // 0x1E54(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E58[0x8];                                     // 0x1E58(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_103761">();
	}
	static class UConfig_103761* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_103761>();
	}
};
static_assert(alignof(UConfig_103761) == 0x000010, "Wrong alignment on UConfig_103761");
static_assert(sizeof(UConfig_103761) == 0x001E60, "Wrong size on UConfig_103761");
static_assert(offsetof(UConfig_103761, LoopDuration) == 0x0000F8, "Member 'UConfig_103761::LoopDuration' has a wrong offset!");
static_assert(offsetof(UConfig_103761, DamageToPowerRatio) == 0x0000FC, "Member 'UConfig_103761::DamageToPowerRatio' has a wrong offset!");
static_assert(offsetof(UConfig_103761, MaxPowerValue) == 0x000100, "Member 'UConfig_103761::MaxPowerValue' has a wrong offset!");
static_assert(offsetof(UConfig_103761, DefaultProjectileDamage) == 0x000104, "Member 'UConfig_103761::DefaultProjectileDamage' has a wrong offset!");
static_assert(offsetof(UConfig_103761, SpecialProjectileDamageMap) == 0x000108, "Member 'UConfig_103761::SpecialProjectileDamageMap' has a wrong offset!");
static_assert(offsetof(UConfig_103761, FXGrowCurve) == 0x000158, "Member 'UConfig_103761::FXGrowCurve' has a wrong offset!");
static_assert(offsetof(UConfig_103761, SummonedGrowCurve) == 0x000160, "Member 'UConfig_103761::SummonedGrowCurve' has a wrong offset!");
static_assert(offsetof(UConfig_103761, HomingAccelerationCurve) == 0x000168, "Member 'UConfig_103761::HomingAccelerationCurve' has a wrong offset!");
static_assert(offsetof(UConfig_103761, HomingCaptureFactorCurve) == 0x000170, "Member 'UConfig_103761::HomingCaptureFactorCurve' has a wrong offset!");
static_assert(offsetof(UConfig_103761, MaxHomingSpeed) == 0x000178, "Member 'UConfig_103761::MaxHomingSpeed' has a wrong offset!");
static_assert(offsetof(UConfig_103761, MaxTangentSpeed) == 0x00017C, "Member 'UConfig_103761::MaxTangentSpeed' has a wrong offset!");
static_assert(offsetof(UConfig_103761, GenTypeCountMap) == 0x000180, "Member 'UConfig_103761::GenTypeCountMap' has a wrong offset!");
static_assert(offsetof(UConfig_103761, WeaponUseInfos) == 0x0001D0, "Member 'UConfig_103761::WeaponUseInfos' has a wrong offset!");
static_assert(offsetof(UConfig_103761, ScopeID) == 0x0001E0, "Member 'UConfig_103761::ScopeID' has a wrong offset!");
static_assert(offsetof(UConfig_103761, AdsorbParameters) == 0x0001F0, "Member 'UConfig_103761::AdsorbParameters' has a wrong offset!");
static_assert(offsetof(UConfig_103761, PointNum) == 0x001970, "Member 'UConfig_103761::PointNum' has a wrong offset!");
static_assert(offsetof(UConfig_103761, SummonedOffset) == 0x001978, "Member 'UConfig_103761::SummonedOffset' has a wrong offset!");
static_assert(offsetof(UConfig_103761, SummonedOffsetCurve) == 0x001990, "Member 'UConfig_103761::SummonedOffsetCurve' has a wrong offset!");
static_assert(offsetof(UConfig_103761, SummonedMoveDuration) == 0x001998, "Member 'UConfig_103761::SummonedMoveDuration' has a wrong offset!");
static_assert(offsetof(UConfig_103761, MinSummonedOffsetX) == 0x00199C, "Member 'UConfig_103761::MinSummonedOffsetX' has a wrong offset!");
static_assert(offsetof(UConfig_103761, MaxSummonedOffsetX) == 0x0019A0, "Member 'UConfig_103761::MaxSummonedOffsetX' has a wrong offset!");
static_assert(offsetof(UConfig_103761, SummonedID) == 0x0019A4, "Member 'UConfig_103761::SummonedID' has a wrong offset!");
static_assert(offsetof(UConfig_103761, SummonedID1) == 0x0019A8, "Member 'UConfig_103761::SummonedID1' has a wrong offset!");
static_assert(offsetof(UConfig_103761, SummonedCollisionTrace) == 0x0019B0, "Member 'UConfig_103761::SummonedCollisionTrace' has a wrong offset!");
static_assert(offsetof(UConfig_103761, SphereRadius) == 0x001D48, "Member 'UConfig_103761::SphereRadius' has a wrong offset!");
static_assert(offsetof(UConfig_103761, PhysicsSummonerAssets) == 0x001D50, "Member 'UConfig_103761::PhysicsSummonerAssets' has a wrong offset!");
static_assert(offsetof(UConfig_103761, NoAdsorbTag) == 0x001DA0, "Member 'UConfig_103761::NoAdsorbTag' has a wrong offset!");
static_assert(offsetof(UConfig_103761, NoForceEndTags) == 0x001DB0, "Member 'UConfig_103761::NoForceEndTags' has a wrong offset!");
static_assert(offsetof(UConfig_103761, CheckDistance) == 0x001E18, "Member 'UConfig_103761::CheckDistance' has a wrong offset!");
static_assert(offsetof(UConfig_103761, CheckDistanceXPos) == 0x001E1C, "Member 'UConfig_103761::CheckDistanceXPos' has a wrong offset!");
static_assert(offsetof(UConfig_103761, CheckDistanceXNeg) == 0x001E20, "Member 'UConfig_103761::CheckDistanceXNeg' has a wrong offset!");
static_assert(offsetof(UConfig_103761, CheckDistanceYPos) == 0x001E24, "Member 'UConfig_103761::CheckDistanceYPos' has a wrong offset!");
static_assert(offsetof(UConfig_103761, CheckDistanceYNeg) == 0x001E28, "Member 'UConfig_103761::CheckDistanceYNeg' has a wrong offset!");
static_assert(offsetof(UConfig_103761, bResetLiftSpan) == 0x001E2C, "Member 'UConfig_103761::bResetLiftSpan' has a wrong offset!");
static_assert(offsetof(UConfig_103761, bResetMaxFlyDistance) == 0x001E2D, "Member 'UConfig_103761::bResetMaxFlyDistance' has a wrong offset!");
static_assert(offsetof(UConfig_103761, LiftTime) == 0x001E30, "Member 'UConfig_103761::LiftTime' has a wrong offset!");
static_assert(offsetof(UConfig_103761, NewLocalVelocity) == 0x001E34, "Member 'UConfig_103761::NewLocalVelocity' has a wrong offset!");
static_assert(offsetof(UConfig_103761, ControlPointDistance) == 0x001E38, "Member 'UConfig_103761::ControlPointDistance' has a wrong offset!");
static_assert(offsetof(UConfig_103761, MaxTotalInteractorNum) == 0x001E3C, "Member 'UConfig_103761::MaxTotalInteractorNum' has a wrong offset!");
static_assert(offsetof(UConfig_103761, InteractorNumToCheck) == 0x001E40, "Member 'UConfig_103761::InteractorNumToCheck' has a wrong offset!");
static_assert(offsetof(UConfig_103761, InteractorNumToDestroy) == 0x001E44, "Member 'UConfig_103761::InteractorNumToDestroy' has a wrong offset!");
static_assert(offsetof(UConfig_103761, TimerInterval) == 0x001E48, "Member 'UConfig_103761::TimerInterval' has a wrong offset!");
static_assert(offsetof(UConfig_103761, SummonedReplicatedMovementTolerance) == 0x001E4C, "Member 'UConfig_103761::SummonedReplicatedMovementTolerance' has a wrong offset!");
static_assert(offsetof(UConfig_103761, AdsorbLargePhysicsSummonerAudioID) == 0x001E50, "Member 'UConfig_103761::AdsorbLargePhysicsSummonerAudioID' has a wrong offset!");
static_assert(offsetof(UConfig_103761, AdsorbOtherPhysicsSummonerAudioID) == 0x001E54, "Member 'UConfig_103761::AdsorbOtherPhysicsSummonerAudioID' has a wrong offset!");

// Class Hero_1037.Ability_103761
// 0x0098 (0x2A88 - 0x29F0)
class UAbility_103761 : public UMarvelGameplayAbility
{
public:
	class UMarvelGameplayAbility*                 AeroAbility;                                       // 0x29F0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EPhysicsWeaponType, int32>               TypeCountMap;                                      // 0x29F8(0x0050)(BlueprintVisible, NativeAccessSpecifierPublic)
	class UConfig_103761*                         AbilityConfig;                                     // 0x2A48(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AMagnetoCharacter*                      AbilityOwner;                                      // 0x2A50(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ASummoned_10376101*                     OwnerSummoned;                                     // 0x2A58(0x0008)(BlueprintVisible, Net, ZeroConstructor, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SummonedTargetLocation;                            // 0x2A60(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanEnterDistanceCheck;                            // 0x2A78(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A79[0x7];                                     // 0x2A79(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UMarvelCharacterMovementComponent*      CharacterMovement;                                 // 0x2A80(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void K2_OnRepOwnerSummoned();
	void OnRep_OwnerSummoned();
	void OnSummonedExceedDistance();
	void StartFly(int32 InFlyModeID);
	void StopFly(int32 InFlyModeID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_103761">();
	}
	static class UAbility_103761* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_103761>();
	}
};
static_assert(alignof(UAbility_103761) == 0x000008, "Wrong alignment on UAbility_103761");
static_assert(sizeof(UAbility_103761) == 0x002A88, "Wrong size on UAbility_103761");
static_assert(offsetof(UAbility_103761, AeroAbility) == 0x0029F0, "Member 'UAbility_103761::AeroAbility' has a wrong offset!");
static_assert(offsetof(UAbility_103761, TypeCountMap) == 0x0029F8, "Member 'UAbility_103761::TypeCountMap' has a wrong offset!");
static_assert(offsetof(UAbility_103761, AbilityConfig) == 0x002A48, "Member 'UAbility_103761::AbilityConfig' has a wrong offset!");
static_assert(offsetof(UAbility_103761, AbilityOwner) == 0x002A50, "Member 'UAbility_103761::AbilityOwner' has a wrong offset!");
static_assert(offsetof(UAbility_103761, OwnerSummoned) == 0x002A58, "Member 'UAbility_103761::OwnerSummoned' has a wrong offset!");
static_assert(offsetof(UAbility_103761, SummonedTargetLocation) == 0x002A60, "Member 'UAbility_103761::SummonedTargetLocation' has a wrong offset!");
static_assert(offsetof(UAbility_103761, bCanEnterDistanceCheck) == 0x002A78, "Member 'UAbility_103761::bCanEnterDistanceCheck' has a wrong offset!");
static_assert(offsetof(UAbility_103761, CharacterMovement) == 0x002A80, "Member 'UAbility_103761::CharacterMovement' has a wrong offset!");

// Class Hero_1037.SummonedDefaultSphereRootComp_103761
// 0x0000 (0x08A0 - 0x08A0)
class USummonedDefaultSphereRootComp_103761 final : public USummonedDefaultSphereRootComp
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SummonedDefaultSphereRootComp_103761">();
	}
	static class USummonedDefaultSphereRootComp_103761* GetDefaultObj()
	{
		return GetDefaultObjImpl<USummonedDefaultSphereRootComp_103761>();
	}
};
static_assert(alignof(USummonedDefaultSphereRootComp_103761) == 0x000010, "Wrong alignment on USummonedDefaultSphereRootComp_103761");
static_assert(sizeof(USummonedDefaultSphereRootComp_103761) == 0x0008A0, "Wrong size on USummonedDefaultSphereRootComp_103761");

// Class Hero_1037.Summoned_10376101
// 0x00B0 (0x0BF0 - 0x0B40)
class ASummoned_10376101 : public AMarvelSummonerBase
{
public:
	uint8                                         Pad_B40[0x18];                                     // 0x0B40(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UAbility_103761*                        OwnerAbility;                                      // 0x0B58(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UConfig_103761*                         AbilityConfig;                                     // 0x0B60(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AccumulateTime;                                    // 0x0B68(0x0004)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B6C[0x4];                                      // 0x0B6C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EPhysicsWeaponType, int32>               TypeCountMap;                                      // 0x0B70(0x0050)(BlueprintVisible, NativeAccessSpecifierPublic)
	class USummonedComp_10376101*                 SummonedComp;                                      // 0x0BC0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMarvelPhysicsHandleComponent*          OwnerPhysicsHandle;                                // 0x0BC8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AMagnetoCharacter*                      OwnerCharacter;                                    // 0x0BD0(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USplineComponent*                       SplineComponent;                                   // 0x0BD8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BE0[0x4];                                      // 0x0BE0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SplineMoveTime;                                    // 0x0BE4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BE8[0x8];                                      // 0x0BE8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddAndCheckPowerValue(float ProjectileDamage, int32 ProjectileID);
	void AddCollisionToSummoned();
	void OnCharacterTranslatedByPortal(const struct FVector& LastPos, const struct FVector& NewPos);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Summoned_10376101">();
	}
	static class ASummoned_10376101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASummoned_10376101>();
	}
};
static_assert(alignof(ASummoned_10376101) == 0x000010, "Wrong alignment on ASummoned_10376101");
static_assert(sizeof(ASummoned_10376101) == 0x000BF0, "Wrong size on ASummoned_10376101");
static_assert(offsetof(ASummoned_10376101, OwnerAbility) == 0x000B58, "Member 'ASummoned_10376101::OwnerAbility' has a wrong offset!");
static_assert(offsetof(ASummoned_10376101, AbilityConfig) == 0x000B60, "Member 'ASummoned_10376101::AbilityConfig' has a wrong offset!");
static_assert(offsetof(ASummoned_10376101, AccumulateTime) == 0x000B68, "Member 'ASummoned_10376101::AccumulateTime' has a wrong offset!");
static_assert(offsetof(ASummoned_10376101, TypeCountMap) == 0x000B70, "Member 'ASummoned_10376101::TypeCountMap' has a wrong offset!");
static_assert(offsetof(ASummoned_10376101, SummonedComp) == 0x000BC0, "Member 'ASummoned_10376101::SummonedComp' has a wrong offset!");
static_assert(offsetof(ASummoned_10376101, OwnerPhysicsHandle) == 0x000BC8, "Member 'ASummoned_10376101::OwnerPhysicsHandle' has a wrong offset!");
static_assert(offsetof(ASummoned_10376101, OwnerCharacter) == 0x000BD0, "Member 'ASummoned_10376101::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(ASummoned_10376101, SplineComponent) == 0x000BD8, "Member 'ASummoned_10376101::SplineComponent' has a wrong offset!");
static_assert(offsetof(ASummoned_10376101, SplineMoveTime) == 0x000BE4, "Member 'ASummoned_10376101::SplineMoveTime' has a wrong offset!");

// Class Hero_1037.MeteoriteMovememtComponent
// 0x0000 (0x2A40 - 0x2A40)
class UMeteoriteMovememtComponent final : public UMarvelProjectileComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MeteoriteMovememtComponent">();
	}
	static class UMeteoriteMovememtComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMeteoriteMovememtComponent>();
	}
};
static_assert(alignof(UMeteoriteMovememtComponent) == 0x000010, "Wrong alignment on UMeteoriteMovememtComponent");
static_assert(sizeof(UMeteoriteMovememtComponent) == 0x002A40, "Wrong size on UMeteoriteMovememtComponent");

// Class Hero_1037.SummonedComp_10376101
// 0x0100 (0x0EB0 - 0x0DB0)
class USummonedComp_10376101 : public UMarvelSummonedComponent
{
public:
	float                                         AdsorbLoopTime;                                    // 0x0DB0(0x0004)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DB4[0x4];                                      // 0x0DB4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ASummoned_10376101*                     OwnerSummon;                                       // 0x0DB8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMarvelGameplayAbility*                 OwnerAbility;                                      // 0x0DC0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UConfig_103761*                         AbilityConfig;                                     // 0x0DC8(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMarvelAbilityTask_LoopAdsorb*          LoopAbsorbTask;                                    // 0x0DD0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ASummoned_10376102*                     ShellSummoned;                                     // 0x0DD8(0x0008)(BlueprintVisible, Net, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSummonedExplod;                                 // 0x0DE0(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DE1[0x7];                                      // 0x0DE1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EPhysicsWeaponType, int32>               AdsorbedSummonersTypeCount;                        // 0x0DE8(0x0050)(BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FPreAllowcateInfo>              PreAllowcateInfos;                                 // 0x0E38(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class APhysicsSummoner*>               AdsorbedSummoners;                                 // 0x0E48(0x0010)(BlueprintVisible, Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPublic)
	TMap<EPhysicsWeaponType, int32>               TypeCountMap;                                      // 0x0E58(0x0050)(BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bHasLaunched;                                      // 0x0EA8(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStopAdsorbLoop;                                   // 0x0EA9(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EAA[0x6];                                      // 0x0EAA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CalculatePosition(class AActor* InActor);
	struct FVector GenRelativeLocation(class AActor* InActor);
	void MulticastAdsorbSuccess(class AActor* InActor);
	void MulticastOnAdsorbTrace(class AActor* InActor);
	void NativeOnAdsorbSuccess(class AActor* InActor);
	void NativeOnAdsorbTrace(class AActor* InActor);
	void OnRep_AdsorbedSummoners();
	void OnRep_HasLaunched();
	void StopAdsorbTime();
	void UpdateGenPhysicsTypeCountMap();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SummonedComp_10376101">();
	}
	static class USummonedComp_10376101* GetDefaultObj()
	{
		return GetDefaultObjImpl<USummonedComp_10376101>();
	}
};
static_assert(alignof(USummonedComp_10376101) == 0x000008, "Wrong alignment on USummonedComp_10376101");
static_assert(sizeof(USummonedComp_10376101) == 0x000EB0, "Wrong size on USummonedComp_10376101");
static_assert(offsetof(USummonedComp_10376101, AdsorbLoopTime) == 0x000DB0, "Member 'USummonedComp_10376101::AdsorbLoopTime' has a wrong offset!");
static_assert(offsetof(USummonedComp_10376101, OwnerSummon) == 0x000DB8, "Member 'USummonedComp_10376101::OwnerSummon' has a wrong offset!");
static_assert(offsetof(USummonedComp_10376101, OwnerAbility) == 0x000DC0, "Member 'USummonedComp_10376101::OwnerAbility' has a wrong offset!");
static_assert(offsetof(USummonedComp_10376101, AbilityConfig) == 0x000DC8, "Member 'USummonedComp_10376101::AbilityConfig' has a wrong offset!");
static_assert(offsetof(USummonedComp_10376101, LoopAbsorbTask) == 0x000DD0, "Member 'USummonedComp_10376101::LoopAbsorbTask' has a wrong offset!");
static_assert(offsetof(USummonedComp_10376101, ShellSummoned) == 0x000DD8, "Member 'USummonedComp_10376101::ShellSummoned' has a wrong offset!");
static_assert(offsetof(USummonedComp_10376101, bIsSummonedExplod) == 0x000DE0, "Member 'USummonedComp_10376101::bIsSummonedExplod' has a wrong offset!");
static_assert(offsetof(USummonedComp_10376101, AdsorbedSummonersTypeCount) == 0x000DE8, "Member 'USummonedComp_10376101::AdsorbedSummonersTypeCount' has a wrong offset!");
static_assert(offsetof(USummonedComp_10376101, PreAllowcateInfos) == 0x000E38, "Member 'USummonedComp_10376101::PreAllowcateInfos' has a wrong offset!");
static_assert(offsetof(USummonedComp_10376101, AdsorbedSummoners) == 0x000E48, "Member 'USummonedComp_10376101::AdsorbedSummoners' has a wrong offset!");
static_assert(offsetof(USummonedComp_10376101, TypeCountMap) == 0x000E58, "Member 'USummonedComp_10376101::TypeCountMap' has a wrong offset!");
static_assert(offsetof(USummonedComp_10376101, bHasLaunched) == 0x000EA8, "Member 'USummonedComp_10376101::bHasLaunched' has a wrong offset!");
static_assert(offsetof(USummonedComp_10376101, bStopAdsorbLoop) == 0x000EA9, "Member 'USummonedComp_10376101::bStopAdsorbLoop' has a wrong offset!");

// Class Hero_1037.Summoned_10376102
// 0x0090 (0x0BD0 - 0x0B40)
class ASummoned_10376102 : public AMarvelSummonerBase
{
public:
	uint8                                         Pad_B40[0x18];                                     // 0x0B40(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UMarvelGameplayAbility*                 OwnerAbility;                                      // 0x0B58(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UConfig_103761*                         AbilityConfig;                                     // 0x0B60(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UReflexReceiverComponent_103761*        ReflexComponent;                                   // 0x0B68(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ASummoned_10376101*                     OwnerSummoned;                                     // 0x0B70(0x0008)(BlueprintVisible, Net, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USummonedComp_10376102*                 SummonedComp;                                      // 0x0B78(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USphereComponent*                       SphereCollisionCenter;                             // 0x0B80(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TWeakObjectPtr<class AMarvelAbilityTargetActor_Projectile>> ServerProjectiles;            // 0x0B88(0x0010)(Net, ZeroConstructor, RepNotify, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_B98[0x38];                                     // 0x0B98(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EndProjectileAfterShellEnd(class AMarvelAbilityTargetActor_Projectile* Projectile);
	void OnProjectileEndAgentTask(class AActor* InActor);
	void OnRep_Projectiles();
	void ProjectileEndHoming(class UMarvelProjectileComponent* ProjectileComponent);
	void ProjectileStartHoming(class UMarvelProjectileComponent* ProjectileComponent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Summoned_10376102">();
	}
	static class ASummoned_10376102* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASummoned_10376102>();
	}
};
static_assert(alignof(ASummoned_10376102) == 0x000010, "Wrong alignment on ASummoned_10376102");
static_assert(sizeof(ASummoned_10376102) == 0x000BD0, "Wrong size on ASummoned_10376102");
static_assert(offsetof(ASummoned_10376102, OwnerAbility) == 0x000B58, "Member 'ASummoned_10376102::OwnerAbility' has a wrong offset!");
static_assert(offsetof(ASummoned_10376102, AbilityConfig) == 0x000B60, "Member 'ASummoned_10376102::AbilityConfig' has a wrong offset!");
static_assert(offsetof(ASummoned_10376102, ReflexComponent) == 0x000B68, "Member 'ASummoned_10376102::ReflexComponent' has a wrong offset!");
static_assert(offsetof(ASummoned_10376102, OwnerSummoned) == 0x000B70, "Member 'ASummoned_10376102::OwnerSummoned' has a wrong offset!");
static_assert(offsetof(ASummoned_10376102, SummonedComp) == 0x000B78, "Member 'ASummoned_10376102::SummonedComp' has a wrong offset!");
static_assert(offsetof(ASummoned_10376102, SphereCollisionCenter) == 0x000B80, "Member 'ASummoned_10376102::SphereCollisionCenter' has a wrong offset!");
static_assert(offsetof(ASummoned_10376102, ServerProjectiles) == 0x000B88, "Member 'ASummoned_10376102::ServerProjectiles' has a wrong offset!");

// Class Hero_1037.SummonedComp_10376102
// 0x0018 (0x0DC8 - 0x0DB0)
class USummonedComp_10376102 : public UMarvelSummonedComponent
{
public:
	class ASummoned_10376101*                     MainSummon;                                        // 0x0DB0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ASummoned_10376102*                     OwnerSummon;                                       // 0x0DB8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UConfig_103761*                         AbilityConfig;                                     // 0x0DC0(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SummonedComp_10376102">();
	}
	static class USummonedComp_10376102* GetDefaultObj()
	{
		return GetDefaultObjImpl<USummonedComp_10376102>();
	}
};
static_assert(alignof(USummonedComp_10376102) == 0x000008, "Wrong alignment on USummonedComp_10376102");
static_assert(sizeof(USummonedComp_10376102) == 0x000DC8, "Wrong size on USummonedComp_10376102");
static_assert(offsetof(USummonedComp_10376102, MainSummon) == 0x000DB0, "Member 'USummonedComp_10376102::MainSummon' has a wrong offset!");
static_assert(offsetof(USummonedComp_10376102, OwnerSummon) == 0x000DB8, "Member 'USummonedComp_10376102::OwnerSummon' has a wrong offset!");
static_assert(offsetof(USummonedComp_10376102, AbilityConfig) == 0x000DC0, "Member 'USummonedComp_10376102::AbilityConfig' has a wrong offset!");

// Class Hero_1037.ReflexReceiverComponent_103761
// 0x0000 (0x0478 - 0x0478)
class UReflexReceiverComponent_103761 final : public UMarvelReflexReceiverComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReflexReceiverComponent_103761">();
	}
	static class UReflexReceiverComponent_103761* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReflexReceiverComponent_103761>();
	}
};
static_assert(alignof(UReflexReceiverComponent_103761) == 0x000008, "Wrong alignment on UReflexReceiverComponent_103761");
static_assert(sizeof(UReflexReceiverComponent_103761) == 0x000478, "Wrong size on UReflexReceiverComponent_103761");

// Class Hero_1037.MeteoritePhysic_Projectile
// 0x0000 (0x3BB0 - 0x3BB0)
class AMeteoritePhysic_Projectile final : public AMarvelPhysics_Projectile
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MeteoritePhysic_Projectile">();
	}
	static class AMeteoritePhysic_Projectile* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMeteoritePhysic_Projectile>();
	}
};
static_assert(alignof(AMeteoritePhysic_Projectile) == 0x000010, "Wrong alignment on AMeteoritePhysic_Projectile");
static_assert(sizeof(AMeteoritePhysic_Projectile) == 0x003BB0, "Wrong size on AMeteoritePhysic_Projectile");

// Class Hero_1037.Cue_Loop_103761
// 0x0040 (0x1240 - 0x1200)
class ACue_Loop_103761 : public AMarvelCueNotify_Summoned
{
public:
	class FName                                   LoopTimeParamName;                                 // 0x11F8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LoopEnergyParamName;                               // 0x1204(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   StopSpawnParamName;                                // 0x1210(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_121C[0x4];                                     // 0x121C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            LoopTimeCurve;                                     // 0x1220(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            LoopEnergyCurve;                                   // 0x1228(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 SteelStone;                                        // 0x1230(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      LoopNiagaraComp;                                   // 0x1238(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void StopSteelStonAnim();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Loop_103761">();
	}
	static class ACue_Loop_103761* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Loop_103761>();
	}
};
static_assert(alignof(ACue_Loop_103761) == 0x000010, "Wrong alignment on ACue_Loop_103761");
static_assert(sizeof(ACue_Loop_103761) == 0x001240, "Wrong size on ACue_Loop_103761");
static_assert(offsetof(ACue_Loop_103761, LoopTimeParamName) == 0x0011F8, "Member 'ACue_Loop_103761::LoopTimeParamName' has a wrong offset!");
static_assert(offsetof(ACue_Loop_103761, LoopEnergyParamName) == 0x001204, "Member 'ACue_Loop_103761::LoopEnergyParamName' has a wrong offset!");
static_assert(offsetof(ACue_Loop_103761, StopSpawnParamName) == 0x001210, "Member 'ACue_Loop_103761::StopSpawnParamName' has a wrong offset!");
static_assert(offsetof(ACue_Loop_103761, LoopTimeCurve) == 0x001220, "Member 'ACue_Loop_103761::LoopTimeCurve' has a wrong offset!");
static_assert(offsetof(ACue_Loop_103761, LoopEnergyCurve) == 0x001228, "Member 'ACue_Loop_103761::LoopEnergyCurve' has a wrong offset!");
static_assert(offsetof(ACue_Loop_103761, SteelStone) == 0x001230, "Member 'ACue_Loop_103761::SteelStone' has a wrong offset!");
static_assert(offsetof(ACue_Loop_103761, LoopNiagaraComp) == 0x001238, "Member 'ACue_Loop_103761::LoopNiagaraComp' has a wrong offset!");

// Class Hero_1037.Cue_Summoner_Loop_10376101
// 0x0020 (0x1260 - 0x1240)
class ACue_Summoner_Loop_10376101 : public ACue_Loop_103761
{
public:
	class ASummoned_10376101*                     MySummoned;                                        // 0x1240(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USummonedComp_10376101*                 SummonedComp;                                      // 0x1248(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLaunchSummoned;                                   // 0x1250(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1251[0xF];                                     // 0x1251(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Summoner_Loop_10376101">();
	}
	static class ACue_Summoner_Loop_10376101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Summoner_Loop_10376101>();
	}
};
static_assert(alignof(ACue_Summoner_Loop_10376101) == 0x000010, "Wrong alignment on ACue_Summoner_Loop_10376101");
static_assert(sizeof(ACue_Summoner_Loop_10376101) == 0x001260, "Wrong size on ACue_Summoner_Loop_10376101");
static_assert(offsetof(ACue_Summoner_Loop_10376101, MySummoned) == 0x001240, "Member 'ACue_Summoner_Loop_10376101::MySummoned' has a wrong offset!");
static_assert(offsetof(ACue_Summoner_Loop_10376101, SummonedComp) == 0x001248, "Member 'ACue_Summoner_Loop_10376101::SummonedComp' has a wrong offset!");
static_assert(offsetof(ACue_Summoner_Loop_10376101, bLaunchSummoned) == 0x001250, "Member 'ACue_Summoner_Loop_10376101::bLaunchSummoned' has a wrong offset!");

// Class Hero_1037.Cue_Summoner_Loop_10376102
// 0x0000 (0x1200 - 0x1200)
class ACue_Summoner_Loop_10376102 final : public AMarvelCueNotify_Summoned
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Summoner_Loop_10376102">();
	}
	static class ACue_Summoner_Loop_10376102* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Summoner_Loop_10376102>();
	}
};
static_assert(alignof(ACue_Summoner_Loop_10376102) == 0x000010, "Wrong alignment on ACue_Summoner_Loop_10376102");
static_assert(sizeof(ACue_Summoner_Loop_10376102) == 0x001200, "Wrong size on ACue_Summoner_Loop_10376102");

// Class Hero_1037.Cue_Ability_Loop_10376100
// 0x0020 (0x11D0 - 0x11B0)
class ACue_Ability_Loop_10376100 final : public AMarvelCueNotify_Ability
{
public:
	class UAbility_103761*                        MyAbility;                                         // 0x11B0(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ConnectBeamEndLocationParamName;                   // 0x11B8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11C4[0x4];                                     // 0x11C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraComponent*                      NS_Loop;                                           // 0x11C8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Ability_Loop_10376100">();
	}
	static class ACue_Ability_Loop_10376100* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Ability_Loop_10376100>();
	}
};
static_assert(alignof(ACue_Ability_Loop_10376100) == 0x000010, "Wrong alignment on ACue_Ability_Loop_10376100");
static_assert(sizeof(ACue_Ability_Loop_10376100) == 0x0011D0, "Wrong size on ACue_Ability_Loop_10376100");
static_assert(offsetof(ACue_Ability_Loop_10376100, MyAbility) == 0x0011B0, "Member 'ACue_Ability_Loop_10376100::MyAbility' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10376100, ConnectBeamEndLocationParamName) == 0x0011B8, "Member 'ACue_Ability_Loop_10376100::ConnectBeamEndLocationParamName' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10376100, NS_Loop) == 0x0011C8, "Member 'ACue_Ability_Loop_10376100::NS_Loop' has a wrong offset!");

// Class Hero_1037.EffectiveComponent_10376102
// 0x0000 (0x1C70 - 0x1C70)
class UEffectiveComponent_10376102 : public UMarvelAgentEffectiveComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EffectiveComponent_10376102">();
	}
	static class UEffectiveComponent_10376102* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEffectiveComponent_10376102>();
	}
};
static_assert(alignof(UEffectiveComponent_10376102) == 0x000010, "Wrong alignment on UEffectiveComponent_10376102");
static_assert(sizeof(UEffectiveComponent_10376102) == 0x001C70, "Wrong size on UEffectiveComponent_10376102");

// Class Hero_1037.Config_103781
// 0x00A0 (0x0198 - 0x00F8)
class UConfig_103781 final : public UConfig_AeroBase
{
public:
	struct FGameplayTag                           AscendingAbilityTag;                               // 0x00F8(0x000C)(Edit, BlueprintVisible, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           FlyAbilityTag;                                     // 0x0104(0x000C)(Edit, BlueprintVisible, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           DescendAbilityTag;                                 // 0x0110(0x000C)(Edit, BlueprintVisible, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11C[0x4];                                      // 0x011C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  MoveAbilityTag;                                    // 0x0120(0x0068)(Edit, BlueprintVisible, AdvancedDisplay, NativeAccessSpecifierPublic)
	int32                                         AscendingAbilityID;                                // 0x0188(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FlyAbilityID;                                      // 0x018C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GlideAbilityID;                                    // 0x0190(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_194[0x4];                                      // 0x0194(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_103781">();
	}
	static class UConfig_103781* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_103781>();
	}
};
static_assert(alignof(UConfig_103781) == 0x000008, "Wrong alignment on UConfig_103781");
static_assert(sizeof(UConfig_103781) == 0x000198, "Wrong size on UConfig_103781");
static_assert(offsetof(UConfig_103781, AscendingAbilityTag) == 0x0000F8, "Member 'UConfig_103781::AscendingAbilityTag' has a wrong offset!");
static_assert(offsetof(UConfig_103781, FlyAbilityTag) == 0x000104, "Member 'UConfig_103781::FlyAbilityTag' has a wrong offset!");
static_assert(offsetof(UConfig_103781, DescendAbilityTag) == 0x000110, "Member 'UConfig_103781::DescendAbilityTag' has a wrong offset!");
static_assert(offsetof(UConfig_103781, MoveAbilityTag) == 0x000120, "Member 'UConfig_103781::MoveAbilityTag' has a wrong offset!");
static_assert(offsetof(UConfig_103781, AscendingAbilityID) == 0x000188, "Member 'UConfig_103781::AscendingAbilityID' has a wrong offset!");
static_assert(offsetof(UConfig_103781, FlyAbilityID) == 0x00018C, "Member 'UConfig_103781::FlyAbilityID' has a wrong offset!");
static_assert(offsetof(UConfig_103781, GlideAbilityID) == 0x000190, "Member 'UConfig_103781::GlideAbilityID' has a wrong offset!");

// Class Hero_1037.Ability_103781
// 0x0030 (0x2B40 - 0x2B10)
class UAbility_103781 : public UMarvelAeroBaseAbility
{
public:
	uint8                                         Pad_2B10[0x18];                                    // 0x2B10(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(bool bOnDescend)> CanDescendDelegate;                              // 0x2B28(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          LastCanEnterDescendResult;                         // 0x2B38(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B39[0x7];                                     // 0x2B39(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnGameTagUpdate(const struct FGameplayTag& Tag, bool TagExists);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_103781">();
	}
	static class UAbility_103781* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_103781>();
	}
};
static_assert(alignof(UAbility_103781) == 0x000008, "Wrong alignment on UAbility_103781");
static_assert(sizeof(UAbility_103781) == 0x002B40, "Wrong size on UAbility_103781");
static_assert(offsetof(UAbility_103781, CanDescendDelegate) == 0x002B28, "Member 'UAbility_103781::CanDescendDelegate' has a wrong offset!");
static_assert(offsetof(UAbility_103781, LastCanEnterDescendResult) == 0x002B38, "Member 'UAbility_103781::LastCanEnterDescendResult' has a wrong offset!");

// Class Hero_1037.EpicMomentAction_1037
// 0x0048 (0x0168 - 0x0120)
class UEpicMomentAction_1037 : public UEpicMomentBaseAction
{
public:
	uint8                                         Pad_120[0x1C];                                     // 0x0120(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FEpicMomentNodeInfo                    ShieldBlockConfig;                                 // 0x013C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         ShieldSummonerID;                                  // 0x0148(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShieldSummonerBlockDamageThreshold;                // 0x014C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FEpicMomentNodeInfo                    QConfig;                                           // 0x0150(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         QProjectileID;                                     // 0x015C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         QProjectileEnergyThreshold;                        // 0x0160(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_164[0x4];                                      // 0x0164(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnActorTakeDamage(class AActor* Instigator, class AActor* Target, const struct FAttributeModifierHandle& ModifierParameterHandle, const struct FGlobalEventExtraData& ExtraData);
	void OnProjectileBegin(class AActor* SourceActor, class UMarvelGameplayAbility* SourceAbility, class AActor* Projectile, const struct FMarvelTargetActorGenerateInfo& GenerateInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EpicMomentAction_1037">();
	}
	static class UEpicMomentAction_1037* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEpicMomentAction_1037>();
	}
};
static_assert(alignof(UEpicMomentAction_1037) == 0x000008, "Wrong alignment on UEpicMomentAction_1037");
static_assert(sizeof(UEpicMomentAction_1037) == 0x000168, "Wrong size on UEpicMomentAction_1037");
static_assert(offsetof(UEpicMomentAction_1037, ShieldBlockConfig) == 0x00013C, "Member 'UEpicMomentAction_1037::ShieldBlockConfig' has a wrong offset!");
static_assert(offsetof(UEpicMomentAction_1037, ShieldSummonerID) == 0x000148, "Member 'UEpicMomentAction_1037::ShieldSummonerID' has a wrong offset!");
static_assert(offsetof(UEpicMomentAction_1037, ShieldSummonerBlockDamageThreshold) == 0x00014C, "Member 'UEpicMomentAction_1037::ShieldSummonerBlockDamageThreshold' has a wrong offset!");
static_assert(offsetof(UEpicMomentAction_1037, QConfig) == 0x000150, "Member 'UEpicMomentAction_1037::QConfig' has a wrong offset!");
static_assert(offsetof(UEpicMomentAction_1037, QProjectileID) == 0x00015C, "Member 'UEpicMomentAction_1037::QProjectileID' has a wrong offset!");
static_assert(offsetof(UEpicMomentAction_1037, QProjectileEnergyThreshold) == 0x000160, "Member 'UEpicMomentAction_1037::QProjectileEnergyThreshold' has a wrong offset!");

// Class Hero_1037.MagnetoAnimInstance
// 0x0010 (0x0A30 - 0x0A20)
class UMagnetoAnimInstance final : public UMarvelAnimInstance
{
public:
	bool                                          bEnterHover;                                       // 0x0A20(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A21[0xF];                                      // 0x0A21(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MagnetoAnimInstance">();
	}
	static class UMagnetoAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMagnetoAnimInstance>();
	}
};
static_assert(alignof(UMagnetoAnimInstance) == 0x000010, "Wrong alignment on UMagnetoAnimInstance");
static_assert(sizeof(UMagnetoAnimInstance) == 0x000A30, "Wrong size on UMagnetoAnimInstance");
static_assert(offsetof(UMagnetoAnimInstance, bEnterHover) == 0x000A20, "Member 'UMagnetoAnimInstance::bEnterHover' has a wrong offset!");

// Class Hero_1037.MagnetoRingAnimInstance
// 0x0000 (0x0450 - 0x0450)
class UMagnetoRingAnimInstance final : public UAnimInstance
{
public:
	class AMagnetoCharacter*                      OwnerChar;                                         // 0x0448(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MagnetoRingAnimInstance">();
	}
	static class UMagnetoRingAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMagnetoRingAnimInstance>();
	}
};
static_assert(alignof(UMagnetoRingAnimInstance) == 0x000010, "Wrong alignment on UMagnetoRingAnimInstance");
static_assert(sizeof(UMagnetoRingAnimInstance) == 0x000450, "Wrong size on UMagnetoRingAnimInstance");
static_assert(offsetof(UMagnetoRingAnimInstance, OwnerChar) == 0x000448, "Member 'UMagnetoRingAnimInstance::OwnerChar' has a wrong offset!");

// Class Hero_1037.MagnetoCharacter
// 0x0040 (0x21E0 - 0x21A0)
class AMagnetoCharacter : public AMarvelBaseCharacter
{
public:
	class UMarvelPhysicsHandleComponent*          PhysicsHandleComponent;                            // 0x21A0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERingState                                    RingState;                                         // 0x21A8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRingStateIdle;                                    // 0x21A9(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRingStateOne;                                     // 0x21AA(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRingStateTwo;                                     // 0x21AB(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRingStateFull;                                    // 0x21AC(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21AD[0x3];                                     // 0x21AD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AdsorbLoopTime;                                    // 0x21B0(0x0004)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SummonedPowerValue;                                // 0x21B4(0x0004)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SummonedMaxPowerValue;                             // 0x21B8(0x0004)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastShootIronCount;                                // 0x21BC(0x0004)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMagnetoMoveLogicBaseComponent*         MagnetoMoveLogic;                                  // 0x21C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDeclarationHolder                     DeclarePlayerViewSideHolder;                       // 0x21C8(0x0010)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_21D8[0x8];                                     // 0x21D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPlayerViewSideChanged(EClientPlayerViewSide InViewSide);

	bool IsPhantom() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MagnetoCharacter">();
	}
	static class AMagnetoCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMagnetoCharacter>();
	}
};
static_assert(alignof(AMagnetoCharacter) == 0x000010, "Wrong alignment on AMagnetoCharacter");
static_assert(sizeof(AMagnetoCharacter) == 0x0021E0, "Wrong size on AMagnetoCharacter");
static_assert(offsetof(AMagnetoCharacter, PhysicsHandleComponent) == 0x0021A0, "Member 'AMagnetoCharacter::PhysicsHandleComponent' has a wrong offset!");
static_assert(offsetof(AMagnetoCharacter, RingState) == 0x0021A8, "Member 'AMagnetoCharacter::RingState' has a wrong offset!");
static_assert(offsetof(AMagnetoCharacter, bRingStateIdle) == 0x0021A9, "Member 'AMagnetoCharacter::bRingStateIdle' has a wrong offset!");
static_assert(offsetof(AMagnetoCharacter, bRingStateOne) == 0x0021AA, "Member 'AMagnetoCharacter::bRingStateOne' has a wrong offset!");
static_assert(offsetof(AMagnetoCharacter, bRingStateTwo) == 0x0021AB, "Member 'AMagnetoCharacter::bRingStateTwo' has a wrong offset!");
static_assert(offsetof(AMagnetoCharacter, bRingStateFull) == 0x0021AC, "Member 'AMagnetoCharacter::bRingStateFull' has a wrong offset!");
static_assert(offsetof(AMagnetoCharacter, AdsorbLoopTime) == 0x0021B0, "Member 'AMagnetoCharacter::AdsorbLoopTime' has a wrong offset!");
static_assert(offsetof(AMagnetoCharacter, SummonedPowerValue) == 0x0021B4, "Member 'AMagnetoCharacter::SummonedPowerValue' has a wrong offset!");
static_assert(offsetof(AMagnetoCharacter, SummonedMaxPowerValue) == 0x0021B8, "Member 'AMagnetoCharacter::SummonedMaxPowerValue' has a wrong offset!");
static_assert(offsetof(AMagnetoCharacter, LastShootIronCount) == 0x0021BC, "Member 'AMagnetoCharacter::LastShootIronCount' has a wrong offset!");
static_assert(offsetof(AMagnetoCharacter, MagnetoMoveLogic) == 0x0021C0, "Member 'AMagnetoCharacter::MagnetoMoveLogic' has a wrong offset!");
static_assert(offsetof(AMagnetoCharacter, DeclarePlayerViewSideHolder) == 0x0021C8, "Member 'AMagnetoCharacter::DeclarePlayerViewSideHolder' has a wrong offset!");

// Class Hero_1037.MagnetoCharacterChildActor
// 0x0000 (0x0E20 - 0x0E20)
class AMagnetoCharacterChildActor final : public AMarvelCharacterChildActor
{
public:
	class USkeletalMeshComponent*                 RingMesh;                                          // 0x0E18(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MagnetoCharacterChildActor">();
	}
	static class AMagnetoCharacterChildActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMagnetoCharacterChildActor>();
	}
};
static_assert(alignof(AMagnetoCharacterChildActor) == 0x000010, "Wrong alignment on AMagnetoCharacterChildActor");
static_assert(sizeof(AMagnetoCharacterChildActor) == 0x000E20, "Wrong size on AMagnetoCharacterChildActor");
static_assert(offsetof(AMagnetoCharacterChildActor, RingMesh) == 0x000E18, "Member 'AMagnetoCharacterChildActor::RingMesh' has a wrong offset!");

// Class Hero_1037.MagnetoMoveLogicBaseComponent
// 0x0000 (0x0400 - 0x0400)
class UMagnetoMoveLogicBaseComponent final : public UMarvelMoveLogicBaseComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MagnetoMoveLogicBaseComponent">();
	}
	static class UMagnetoMoveLogicBaseComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMagnetoMoveLogicBaseComponent>();
	}
};
static_assert(alignof(UMagnetoMoveLogicBaseComponent) == 0x000008, "Wrong alignment on UMagnetoMoveLogicBaseComponent");
static_assert(sizeof(UMagnetoMoveLogicBaseComponent) == 0x000400, "Wrong size on UMagnetoMoveLogicBaseComponent");

// Class Hero_1037.MagnetoMovementComponent
// 0x0000 (0x2360 - 0x2360)
class UMagnetoMovementComponent final : public UMarvelCharacterMovementComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MagnetoMovementComponent">();
	}
	static class UMagnetoMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMagnetoMovementComponent>();
	}
};
static_assert(alignof(UMagnetoMovementComponent) == 0x000010, "Wrong alignment on UMagnetoMovementComponent");
static_assert(sizeof(UMagnetoMovementComponent) == 0x002360, "Wrong size on UMagnetoMovementComponent");

// Class Hero_1037.Summoned_103792
// 0x00B0 (0x2290 - 0x21E0)
class ASummoned_103792 : public AMagnetoCharacter
{
public:
	uint8                                         Pad_21E0[0x8];                                     // 0x21E0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AMarvelBaseCharacter*                   SourceActor;                                       // 0x21E8(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AMarvelBaseCharacter*                   QuoteSource;                                       // 0x21F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMarvelSummonedComponent*               SummonedComponent;                                 // 0x21F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           PhantomCueTag;                                     // 0x2200(0x000C)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxAccumulativeDamage;                             // 0x220C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint16                                        SummonedRemoteViewPitch;                           // 0x2210(0x0002)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2212[0x6];                                     // 0x2212(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AAIController>              SummonedControllerClass;                           // 0x2218(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2220[0x58];                                    // 0x2220(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	class UMarvelSummonedHiddenComponent*         SummonedHiddenComponent;                           // 0x2278(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2280[0x10];                                    // 0x2280(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DestroyPhantom();
	void OnAbilitySystemDeath(class AActor* InSourceAvatar, class AActor* InTargetAvatar, const struct FAttributeModifierHandle& ModifierParameterHandle);
	void SetSummonedRemoteViewPitch(float NewSummonedRemoteViewPitch);

	class UMarvelSummonedComponent* GetSummonedComponent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Summoned_103792">();
	}
	static class ASummoned_103792* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASummoned_103792>();
	}
};
static_assert(alignof(ASummoned_103792) == 0x000010, "Wrong alignment on ASummoned_103792");
static_assert(sizeof(ASummoned_103792) == 0x002290, "Wrong size on ASummoned_103792");
static_assert(offsetof(ASummoned_103792, SourceActor) == 0x0021E8, "Member 'ASummoned_103792::SourceActor' has a wrong offset!");
static_assert(offsetof(ASummoned_103792, QuoteSource) == 0x0021F0, "Member 'ASummoned_103792::QuoteSource' has a wrong offset!");
static_assert(offsetof(ASummoned_103792, SummonedComponent) == 0x0021F8, "Member 'ASummoned_103792::SummonedComponent' has a wrong offset!");
static_assert(offsetof(ASummoned_103792, PhantomCueTag) == 0x002200, "Member 'ASummoned_103792::PhantomCueTag' has a wrong offset!");
static_assert(offsetof(ASummoned_103792, MaxAccumulativeDamage) == 0x00220C, "Member 'ASummoned_103792::MaxAccumulativeDamage' has a wrong offset!");
static_assert(offsetof(ASummoned_103792, SummonedRemoteViewPitch) == 0x002210, "Member 'ASummoned_103792::SummonedRemoteViewPitch' has a wrong offset!");
static_assert(offsetof(ASummoned_103792, SummonedControllerClass) == 0x002218, "Member 'ASummoned_103792::SummonedControllerClass' has a wrong offset!");
static_assert(offsetof(ASummoned_103792, SummonedHiddenComponent) == 0x002278, "Member 'ASummoned_103792::SummonedHiddenComponent' has a wrong offset!");

// Class Hero_1037.TabData_1037
// 0x0000 (0x0050 - 0x0050)
class UTabData_1037 final : public UHeroTabDataBase
{
public:
	void OnActorTakeDamage(class AActor* Instigator, class AActor* Target, const struct FAttributeModifierHandle& ModifierParameterHandle, const struct FGlobalEventExtraData& ExtraData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TabData_1037">();
	}
	static class UTabData_1037* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTabData_1037>();
	}
};
static_assert(alignof(UTabData_1037) == 0x000008, "Wrong alignment on UTabData_1037");
static_assert(sizeof(UTabData_1037) == 0x000050, "Wrong size on UTabData_1037");

}

