#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Hero_1045

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "Marvel_structs.hpp"
#include "Marvel_classes.hpp"
#include "GameplayTags_structs.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "DeclarativeUnreal_structs.hpp"
#include "Hero_1045_structs.hpp"


namespace SDK
{

// Class Hero_1045.Config_104521
// 0x00B0 (0x0148 - 0x0098)
class UConfig_104521 : public UMarvelAbilityConfig
{
public:
	TArray<int32>                                 AbilityIdConfig;                                   // 0x0098(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         RecoveredEnergy;                                   // 0x00A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RecoveredEnergyAbilityID;                          // 0x00AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTeamMember                            RecoveredEnergyHitEnemyType;                       // 0x00B0(0x0007)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          NedHeadshotToTrigger;                              // 0x00B7(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  BerserkSummonTriggersCues;                         // 0x00B8(0x0068)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<int32>                                 BerserkBuffIDs;                                    // 0x0120(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<int32>                                 BerserkBuffSummonIDs;                              // 0x0130(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FTeamMember                            BerserkHitEnemyType;                               // 0x0140(0x0007)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_147[0x1];                                      // 0x0147(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_104521">();
	}
	static class UConfig_104521* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_104521>();
	}
};
static_assert(alignof(UConfig_104521) == 0x000008, "Wrong alignment on UConfig_104521");
static_assert(sizeof(UConfig_104521) == 0x000148, "Wrong size on UConfig_104521");
static_assert(offsetof(UConfig_104521, AbilityIdConfig) == 0x000098, "Member 'UConfig_104521::AbilityIdConfig' has a wrong offset!");
static_assert(offsetof(UConfig_104521, RecoveredEnergy) == 0x0000A8, "Member 'UConfig_104521::RecoveredEnergy' has a wrong offset!");
static_assert(offsetof(UConfig_104521, RecoveredEnergyAbilityID) == 0x0000AC, "Member 'UConfig_104521::RecoveredEnergyAbilityID' has a wrong offset!");
static_assert(offsetof(UConfig_104521, RecoveredEnergyHitEnemyType) == 0x0000B0, "Member 'UConfig_104521::RecoveredEnergyHitEnemyType' has a wrong offset!");
static_assert(offsetof(UConfig_104521, NedHeadshotToTrigger) == 0x0000B7, "Member 'UConfig_104521::NedHeadshotToTrigger' has a wrong offset!");
static_assert(offsetof(UConfig_104521, BerserkSummonTriggersCues) == 0x0000B8, "Member 'UConfig_104521::BerserkSummonTriggersCues' has a wrong offset!");
static_assert(offsetof(UConfig_104521, BerserkBuffIDs) == 0x000120, "Member 'UConfig_104521::BerserkBuffIDs' has a wrong offset!");
static_assert(offsetof(UConfig_104521, BerserkBuffSummonIDs) == 0x000130, "Member 'UConfig_104521::BerserkBuffSummonIDs' has a wrong offset!");
static_assert(offsetof(UConfig_104521, BerserkHitEnemyType) == 0x000140, "Member 'UConfig_104521::BerserkHitEnemyType' has a wrong offset!");

// Class Hero_1045.Ability_104521
// 0x0008 (0x2A00 - 0x29F8)
class UAbility_104521 : public UAbility_108
{
public:
	uint8                                         Pad_29F8[0x8];                                     // 0x29F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPostApplyDamage(class AActor* InSourceAvatar, class AActor* InTargetAvatar, const struct FAttributeModifierHandle& ModifierParameterHandle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_104521">();
	}
	static class UAbility_104521* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_104521>();
	}
};
static_assert(alignof(UAbility_104521) == 0x000008, "Wrong alignment on UAbility_104521");
static_assert(sizeof(UAbility_104521) == 0x002A00, "Wrong size on UAbility_104521");

// Class Hero_1045.TraceComponent_10453102
// 0x0000 (0x2200 - 0x2200)
class UTraceComponent_10453102 final : public UMarvelAgentTraceComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TraceComponent_10453102">();
	}
	static class UTraceComponent_10453102* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTraceComponent_10453102>();
	}
};
static_assert(alignof(UTraceComponent_10453102) == 0x000010, "Wrong alignment on UTraceComponent_10453102");
static_assert(sizeof(UTraceComponent_10453102) == 0x002200, "Wrong size on UTraceComponent_10453102");

// Class Hero_1045.Config_104531
// 0x0098 (0x0130 - 0x0098)
class UConfig_104531 : public UMarvelAbilityConfig
{
public:
	bool                                          IsTriggeredOnActivation;                           // 0x0098(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsTriggerOnHit;                                    // 0x0099(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTeamMember                            BerserkHitEnemyType;                               // 0x009A(0x0007)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  BerserkSummonInstigatorCues;                       // 0x00A8(0x0068)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<int32>                                 BerserkBuffIDs;                                    // 0x0110(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<int32>                                 BerserkBuffSummonIDs;                              // 0x0120(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_104531">();
	}
	static class UConfig_104531* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_104531>();
	}
};
static_assert(alignof(UConfig_104531) == 0x000008, "Wrong alignment on UConfig_104531");
static_assert(sizeof(UConfig_104531) == 0x000130, "Wrong size on UConfig_104531");
static_assert(offsetof(UConfig_104531, IsTriggeredOnActivation) == 0x000098, "Member 'UConfig_104531::IsTriggeredOnActivation' has a wrong offset!");
static_assert(offsetof(UConfig_104531, IsTriggerOnHit) == 0x000099, "Member 'UConfig_104531::IsTriggerOnHit' has a wrong offset!");
static_assert(offsetof(UConfig_104531, BerserkHitEnemyType) == 0x00009A, "Member 'UConfig_104531::BerserkHitEnemyType' has a wrong offset!");
static_assert(offsetof(UConfig_104531, BerserkSummonInstigatorCues) == 0x0000A8, "Member 'UConfig_104531::BerserkSummonInstigatorCues' has a wrong offset!");
static_assert(offsetof(UConfig_104531, BerserkBuffIDs) == 0x000110, "Member 'UConfig_104531::BerserkBuffIDs' has a wrong offset!");
static_assert(offsetof(UConfig_104531, BerserkBuffSummonIDs) == 0x000120, "Member 'UConfig_104531::BerserkBuffSummonIDs' has a wrong offset!");

// Class Hero_1045.Ability_104531
// 0x0008 (0x2A00 - 0x29F8)
class UAbility_104531 : public UAbility_108
{
public:
	class UConfig_104531*                         Config;                                            // 0x29F8(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnPostApplyDamage(class AActor* InSourceAvatar, class AActor* InTargetAvatar, const struct FAttributeModifierHandle& ModifierParameterHandle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_104531">();
	}
	static class UAbility_104531* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_104531>();
	}
};
static_assert(alignof(UAbility_104531) == 0x000008, "Wrong alignment on UAbility_104531");
static_assert(sizeof(UAbility_104531) == 0x002A00, "Wrong size on UAbility_104531");
static_assert(offsetof(UAbility_104531, Config) == 0x0029F8, "Member 'UAbility_104531::Config' has a wrong offset!");

// Class Hero_1045.Summoned_10454101
// 0x0010 (0x0B50 - 0x0B40)
class ASummoned_10454101 : public AMarvelSummonerBase
{
public:
	float                                         ShieldResistDamage;                                // 0x0B40(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B44[0xC];                                      // 0x0B44(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Summoned_10454101">();
	}
	static class ASummoned_10454101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASummoned_10454101>();
	}
};
static_assert(alignof(ASummoned_10454101) == 0x000010, "Wrong alignment on ASummoned_10454101");
static_assert(sizeof(ASummoned_10454101) == 0x000B50, "Wrong size on ASummoned_10454101");
static_assert(offsetof(ASummoned_10454101, ShieldResistDamage) == 0x000B40, "Member 'ASummoned_10454101::ShieldResistDamage' has a wrong offset!");

// Class Hero_1045.Config_104543
// 0x00E0 (0x01D8 - 0x00F8)
class UConfig_104543 final : public UConfig_AeroBase
{
public:
	struct FGameplayTagContainer                  FlyAbilityTag;                                     // 0x00F8(0x0068)(Edit, BlueprintVisible, AdvancedDisplay, NativeAccessSpecifierPublic)
	struct FGameplayTag                           GlideAbilityTag;                                   // 0x0160(0x000C)(Edit, BlueprintVisible, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16C[0x4];                                      // 0x016C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  MoveAbilityTag;                                    // 0x0170(0x0068)(Edit, BlueprintVisible, AdvancedDisplay, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_104543">();
	}
	static class UConfig_104543* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_104543>();
	}
};
static_assert(alignof(UConfig_104543) == 0x000008, "Wrong alignment on UConfig_104543");
static_assert(sizeof(UConfig_104543) == 0x0001D8, "Wrong size on UConfig_104543");
static_assert(offsetof(UConfig_104543, FlyAbilityTag) == 0x0000F8, "Member 'UConfig_104543::FlyAbilityTag' has a wrong offset!");
static_assert(offsetof(UConfig_104543, GlideAbilityTag) == 0x000160, "Member 'UConfig_104543::GlideAbilityTag' has a wrong offset!");
static_assert(offsetof(UConfig_104543, MoveAbilityTag) == 0x000170, "Member 'UConfig_104543::MoveAbilityTag' has a wrong offset!");

// Class Hero_1045.Ability_104543
// 0x0040 (0x2B50 - 0x2B10)
class UAbility_104543 : public UMarvelAeroBaseAbility
{
public:
	uint8                                         Pad_2B10[0x2C];                                    // 0x2B10(0x002C)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         FlyAbilityID;                                      // 0x2B3C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DescendAbilityID;                                  // 0x2B40(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanGlide;                                         // 0x2B44(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsBlockMove;                                      // 0x2B45(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B46[0x2];                                     // 0x2B46(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class UConfig_104543*                         Config_104543;                                     // 0x2B48(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnGameTagUpdate(const struct FGameplayTag& Tag, bool TagExists);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_104543">();
	}
	static class UAbility_104543* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_104543>();
	}
};
static_assert(alignof(UAbility_104543) == 0x000008, "Wrong alignment on UAbility_104543");
static_assert(sizeof(UAbility_104543) == 0x002B50, "Wrong size on UAbility_104543");
static_assert(offsetof(UAbility_104543, FlyAbilityID) == 0x002B3C, "Member 'UAbility_104543::FlyAbilityID' has a wrong offset!");
static_assert(offsetof(UAbility_104543, DescendAbilityID) == 0x002B40, "Member 'UAbility_104543::DescendAbilityID' has a wrong offset!");
static_assert(offsetof(UAbility_104543, bCanGlide) == 0x002B44, "Member 'UAbility_104543::bCanGlide' has a wrong offset!");
static_assert(offsetof(UAbility_104543, bIsBlockMove) == 0x002B45, "Member 'UAbility_104543::bIsBlockMove' has a wrong offset!");
static_assert(offsetof(UAbility_104543, Config_104543) == 0x002B48, "Member 'UAbility_104543::Config_104543' has a wrong offset!");

// Class Hero_1045.Ability_104551
// 0x0000 (0x29F8 - 0x29F8)
class UAbility_104551 : public UAbility_108
{
public:
	void SetMaxSkillEnergyBaseValue(float NewValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_104551">();
	}
	static class UAbility_104551* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_104551>();
	}
};
static_assert(alignof(UAbility_104551) == 0x000008, "Wrong alignment on UAbility_104551");
static_assert(sizeof(UAbility_104551) == 0x0029F8, "Wrong size on UAbility_104551");

// Class Hero_1045.Summoned_10455101
// 0x01E0 (0x1620 - 0x1440)
class ASummoned_10455101 : public ASummonedCharacterBase
{
public:
	class AActor*                                 AudioInstigator;                                   // 0x1438(0x0008)(BlueprintVisible, Net, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnOctopusBusyStateChanged;                         // 0x1440(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	bool                                          bIsOctopusBusy;                                    // 0x1450(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1451[0x7];                                     // 0x1451(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UEquipComponent*                        EquipComponent;                                    // 0x1458(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EquipID;                                           // 0x1460(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1464[0x4];                                     // 0x1464(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                CurrentLookDir;                                    // 0x1468(0x0018)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UActorComponent* Value)> OnTargetChanged;                    // 0x1480(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	float                                         LastBusyTime;                                      // 0x1490(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FireDuration;                                      // 0x1494(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerUID;                                         // 0x1498(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_149C[0x4];                                     // 0x149C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UPrimitiveComponent*                    CurrentTargetComponent;                            // 0x14A0(0x0008)(BlueprintVisible, ExportObject, Net, ZeroConstructor, InstancedReference, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CurrentTargetLocation;                             // 0x14A8(0x0018)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOctopusState                                 CurrentOctopusState;                               // 0x14C0(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOctopusState                                 LastOctopusState;                                  // 0x14C1(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14C2[0x6];                                     // 0x14C2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ValidPosRelativeLocation;                          // 0x14C8(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MeshHorizontalAngleVelocity;                       // 0x14E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HorizontalRotateInterpSpeed;                       // 0x14E4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AOUpdateVelocity;                                  // 0x14E8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotateDegreeThreshold;                             // 0x14EC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DelayTraceTime;                                    // 0x14F0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14F4[0x4];                                     // 0x14F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           BusyStateTag;                                      // 0x14F8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         BusyWindowTime;                                    // 0x1508(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_150C[0x4];                                     // 0x150C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 OctopusBuffs;                                      // 0x1510(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         AttackManageAbilityID;                             // 0x1520(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NormalAttackAbilityID;                             // 0x1524(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EnhancedAttackAbilityID;                           // 0x1528(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDead;                                           // 0x152C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_152D[0x3];                                     // 0x152D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class USpringArmComponent*                    SpringArmComponent;                                // 0x1530(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCameraComponent*                       CameraComponent;                                   // 0x1538(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CachedUpVector;                                    // 0x1540(0x0018)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DegreesBetweenMeshForwardAndLookDir;               // 0x1558(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_155C[0x4];                                     // 0x155C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDeclarationHolder                     DeclarePlayerViewSideHolder;                       // 0x1560(0x0010)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1570[0xB0];                                    // 0x1570(0x00B0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class ANamorCharacter* GetNamor();
	float GetPitchByLookVector(const struct FVector& LookVector);
	float GetRemainTime();
	void OnCurrentTargetChanged();
	void OnPlayerViewSideChanged(EClientPlayerViewSide InViewSide);
	void OnRep_bIsOctopusBusy();
	void OnRep_CurrentLookDir();
	void OnRep_OnCurrentTargetChanged();
	void OnRep_OnOctopusStateChanged();
	void OnTagAdded(class FName TagName);
	void OnTakeDamage(class AActor* InSourceAvatar, class AActor* InTargetAvatar, const struct FAttributeModifierHandle& ModifierParameterHandle);
	void SetCachedUpVector(const struct FVector& InNormalVector);
	void SetCurrentOctopusState(EOctopusState NewOctopusState);
	void SetCurrentTargetComponentAndUpdateLookDir(class UPrimitiveComponent* NewTargetComponent);
	void SetCurrentTargetLocationAndForceNetUpdate(const struct FVector& NewTargetLocation);
	bool SetIsOctopusBusy(bool bInBusy);
	void UpdateLocalRotation(float DeltaSeconds);
	void UpdateLookRotation();

	struct FVector GetCurrentTargetLookDir() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Summoned_10455101">();
	}
	static class ASummoned_10455101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASummoned_10455101>();
	}
};
static_assert(alignof(ASummoned_10455101) == 0x000010, "Wrong alignment on ASummoned_10455101");
static_assert(sizeof(ASummoned_10455101) == 0x001620, "Wrong size on ASummoned_10455101");
static_assert(offsetof(ASummoned_10455101, AudioInstigator) == 0x001438, "Member 'ASummoned_10455101::AudioInstigator' has a wrong offset!");
static_assert(offsetof(ASummoned_10455101, OnOctopusBusyStateChanged) == 0x001440, "Member 'ASummoned_10455101::OnOctopusBusyStateChanged' has a wrong offset!");
static_assert(offsetof(ASummoned_10455101, bIsOctopusBusy) == 0x001450, "Member 'ASummoned_10455101::bIsOctopusBusy' has a wrong offset!");
static_assert(offsetof(ASummoned_10455101, EquipComponent) == 0x001458, "Member 'ASummoned_10455101::EquipComponent' has a wrong offset!");
static_assert(offsetof(ASummoned_10455101, EquipID) == 0x001460, "Member 'ASummoned_10455101::EquipID' has a wrong offset!");
static_assert(offsetof(ASummoned_10455101, CurrentLookDir) == 0x001468, "Member 'ASummoned_10455101::CurrentLookDir' has a wrong offset!");
static_assert(offsetof(ASummoned_10455101, OnTargetChanged) == 0x001480, "Member 'ASummoned_10455101::OnTargetChanged' has a wrong offset!");
static_assert(offsetof(ASummoned_10455101, LastBusyTime) == 0x001490, "Member 'ASummoned_10455101::LastBusyTime' has a wrong offset!");
static_assert(offsetof(ASummoned_10455101, FireDuration) == 0x001494, "Member 'ASummoned_10455101::FireDuration' has a wrong offset!");
static_assert(offsetof(ASummoned_10455101, PlayerUID) == 0x001498, "Member 'ASummoned_10455101::PlayerUID' has a wrong offset!");
static_assert(offsetof(ASummoned_10455101, CurrentTargetComponent) == 0x0014A0, "Member 'ASummoned_10455101::CurrentTargetComponent' has a wrong offset!");
static_assert(offsetof(ASummoned_10455101, CurrentTargetLocation) == 0x0014A8, "Member 'ASummoned_10455101::CurrentTargetLocation' has a wrong offset!");
static_assert(offsetof(ASummoned_10455101, CurrentOctopusState) == 0x0014C0, "Member 'ASummoned_10455101::CurrentOctopusState' has a wrong offset!");
static_assert(offsetof(ASummoned_10455101, LastOctopusState) == 0x0014C1, "Member 'ASummoned_10455101::LastOctopusState' has a wrong offset!");
static_assert(offsetof(ASummoned_10455101, ValidPosRelativeLocation) == 0x0014C8, "Member 'ASummoned_10455101::ValidPosRelativeLocation' has a wrong offset!");
static_assert(offsetof(ASummoned_10455101, MeshHorizontalAngleVelocity) == 0x0014E0, "Member 'ASummoned_10455101::MeshHorizontalAngleVelocity' has a wrong offset!");
static_assert(offsetof(ASummoned_10455101, HorizontalRotateInterpSpeed) == 0x0014E4, "Member 'ASummoned_10455101::HorizontalRotateInterpSpeed' has a wrong offset!");
static_assert(offsetof(ASummoned_10455101, AOUpdateVelocity) == 0x0014E8, "Member 'ASummoned_10455101::AOUpdateVelocity' has a wrong offset!");
static_assert(offsetof(ASummoned_10455101, RotateDegreeThreshold) == 0x0014EC, "Member 'ASummoned_10455101::RotateDegreeThreshold' has a wrong offset!");
static_assert(offsetof(ASummoned_10455101, DelayTraceTime) == 0x0014F0, "Member 'ASummoned_10455101::DelayTraceTime' has a wrong offset!");
static_assert(offsetof(ASummoned_10455101, BusyStateTag) == 0x0014F8, "Member 'ASummoned_10455101::BusyStateTag' has a wrong offset!");
static_assert(offsetof(ASummoned_10455101, BusyWindowTime) == 0x001508, "Member 'ASummoned_10455101::BusyWindowTime' has a wrong offset!");
static_assert(offsetof(ASummoned_10455101, OctopusBuffs) == 0x001510, "Member 'ASummoned_10455101::OctopusBuffs' has a wrong offset!");
static_assert(offsetof(ASummoned_10455101, AttackManageAbilityID) == 0x001520, "Member 'ASummoned_10455101::AttackManageAbilityID' has a wrong offset!");
static_assert(offsetof(ASummoned_10455101, NormalAttackAbilityID) == 0x001524, "Member 'ASummoned_10455101::NormalAttackAbilityID' has a wrong offset!");
static_assert(offsetof(ASummoned_10455101, EnhancedAttackAbilityID) == 0x001528, "Member 'ASummoned_10455101::EnhancedAttackAbilityID' has a wrong offset!");
static_assert(offsetof(ASummoned_10455101, bIsDead) == 0x00152C, "Member 'ASummoned_10455101::bIsDead' has a wrong offset!");
static_assert(offsetof(ASummoned_10455101, SpringArmComponent) == 0x001530, "Member 'ASummoned_10455101::SpringArmComponent' has a wrong offset!");
static_assert(offsetof(ASummoned_10455101, CameraComponent) == 0x001538, "Member 'ASummoned_10455101::CameraComponent' has a wrong offset!");
static_assert(offsetof(ASummoned_10455101, CachedUpVector) == 0x001540, "Member 'ASummoned_10455101::CachedUpVector' has a wrong offset!");
static_assert(offsetof(ASummoned_10455101, DegreesBetweenMeshForwardAndLookDir) == 0x001558, "Member 'ASummoned_10455101::DegreesBetweenMeshForwardAndLookDir' has a wrong offset!");
static_assert(offsetof(ASummoned_10455101, DeclarePlayerViewSideHolder) == 0x001560, "Member 'ASummoned_10455101::DeclarePlayerViewSideHolder' has a wrong offset!");

// Class Hero_1045.SummonedComp_10455101
// 0x0000 (0x0DB0 - 0x0DB0)
class USummonedComp_10455101 final : public UMarvelSummonedComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SummonedComp_10455101">();
	}
	static class USummonedComp_10455101* GetDefaultObj()
	{
		return GetDefaultObjImpl<USummonedComp_10455101>();
	}
};
static_assert(alignof(USummonedComp_10455101) == 0x000008, "Wrong alignment on USummonedComp_10455101");
static_assert(sizeof(USummonedComp_10455101) == 0x000DB0, "Wrong size on USummonedComp_10455101");

// Class Hero_1045.OctopusSummonedChildActor
// 0x0020 (0x0E40 - 0x0E20)
class AOctopusSummonedChildActor final : public AMarvelCharacterChildActor
{
public:
	uint8                                         Pad_E18[0x8];                                      // 0x0E18(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           CurrentPlayingTurnMontage;                         // 0x0E20(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOctopusAnimData*                       OctopusAnimData;                                   // 0x0E28(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnInPlaceMontageRate;                            // 0x0E30(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AOYaw;                                             // 0x0E34(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AOPitch;                                           // 0x0E38(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E3C[0x4];                                      // 0x0E3C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsAttackDegreeValid(float InAngle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OctopusSummonedChildActor">();
	}
	static class AOctopusSummonedChildActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOctopusSummonedChildActor>();
	}
};
static_assert(alignof(AOctopusSummonedChildActor) == 0x000010, "Wrong alignment on AOctopusSummonedChildActor");
static_assert(sizeof(AOctopusSummonedChildActor) == 0x000E40, "Wrong size on AOctopusSummonedChildActor");
static_assert(offsetof(AOctopusSummonedChildActor, CurrentPlayingTurnMontage) == 0x000E20, "Member 'AOctopusSummonedChildActor::CurrentPlayingTurnMontage' has a wrong offset!");
static_assert(offsetof(AOctopusSummonedChildActor, OctopusAnimData) == 0x000E28, "Member 'AOctopusSummonedChildActor::OctopusAnimData' has a wrong offset!");
static_assert(offsetof(AOctopusSummonedChildActor, TurnInPlaceMontageRate) == 0x000E30, "Member 'AOctopusSummonedChildActor::TurnInPlaceMontageRate' has a wrong offset!");
static_assert(offsetof(AOctopusSummonedChildActor, AOYaw) == 0x000E34, "Member 'AOctopusSummonedChildActor::AOYaw' has a wrong offset!");
static_assert(offsetof(AOctopusSummonedChildActor, AOPitch) == 0x000E38, "Member 'AOctopusSummonedChildActor::AOPitch' has a wrong offset!");

// Class Hero_1045.Projectile_10453102_Base
// 0x0010 (0x3BA0 - 0x3B90)
class AProjectile_10453102_Base final : public AMarvelAbilityTargetActor_Projectile
{
public:
	bool                                          bShouldUsedForHitRate;                             // 0x3B88(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B89[0x7];                                     // 0x3B89(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 TargetActor;                                       // 0x3B90(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B98[0x8];                                     // 0x3B98(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Projectile_10453102_Base">();
	}
	static class AProjectile_10453102_Base* GetDefaultObj()
	{
		return GetDefaultObjImpl<AProjectile_10453102_Base>();
	}
};
static_assert(alignof(AProjectile_10453102_Base) == 0x000010, "Wrong alignment on AProjectile_10453102_Base");
static_assert(sizeof(AProjectile_10453102_Base) == 0x003BA0, "Wrong size on AProjectile_10453102_Base");
static_assert(offsetof(AProjectile_10453102_Base, bShouldUsedForHitRate) == 0x003B88, "Member 'AProjectile_10453102_Base::bShouldUsedForHitRate' has a wrong offset!");
static_assert(offsetof(AProjectile_10453102_Base, TargetActor) == 0x003B90, "Member 'AProjectile_10453102_Base::TargetActor' has a wrong offset!");

// Class Hero_1045.Ability_104553
// 0x0010 (0x2A08 - 0x29F8)
class UAbility_104553 : public UAbility_108
{
public:
	float                                         LastShootTime;                                     // 0x29F8(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinShootInterval;                                  // 0x29FC(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         OverrideShootInterval;                             // 0x2A00(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A04[0x4];                                     // 0x2A04(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsOnCooldown() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_104553">();
	}
	static class UAbility_104553* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_104553>();
	}
};
static_assert(alignof(UAbility_104553) == 0x000008, "Wrong alignment on UAbility_104553");
static_assert(sizeof(UAbility_104553) == 0x002A08, "Wrong size on UAbility_104553");
static_assert(offsetof(UAbility_104553, LastShootTime) == 0x0029F8, "Member 'UAbility_104553::LastShootTime' has a wrong offset!");
static_assert(offsetof(UAbility_104553, MinShootInterval) == 0x0029FC, "Member 'UAbility_104553::MinShootInterval' has a wrong offset!");
static_assert(offsetof(UAbility_104553, OverrideShootInterval) == 0x002A00, "Member 'UAbility_104553::OverrideShootInterval' has a wrong offset!");

// Class Hero_1045.InstantAmmo_104553
// 0x0000 (0x08F0 - 0x08F0)
class AInstantAmmo_104553 : public AInstantAmmo
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InstantAmmo_104553">();
	}
	static class AInstantAmmo_104553* GetDefaultObj()
	{
		return GetDefaultObjImpl<AInstantAmmo_104553>();
	}
};
static_assert(alignof(AInstantAmmo_104553) == 0x000010, "Wrong alignment on AInstantAmmo_104553");
static_assert(sizeof(AInstantAmmo_104553) == 0x0008F0, "Wrong size on AInstantAmmo_104553");

// Class Hero_1045.Ability_104554
// 0x0020 (0x2A10 - 0x29F0)
class UAbility_104554 : public UMarvelGameplayAbility
{
public:
	class UPrimitiveComponent*                    TargetActorComponent;                              // 0x29F0(0x0008)(BlueprintVisible, ExportObject, Net, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetLocation;                                    // 0x29F8(0x0018)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	struct FVector GetWaterTargetLocation() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_104554">();
	}
	static class UAbility_104554* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_104554>();
	}
};
static_assert(alignof(UAbility_104554) == 0x000008, "Wrong alignment on UAbility_104554");
static_assert(sizeof(UAbility_104554) == 0x002A10, "Wrong size on UAbility_104554");
static_assert(offsetof(UAbility_104554, TargetActorComponent) == 0x0029F0, "Member 'UAbility_104554::TargetActorComponent' has a wrong offset!");
static_assert(offsetof(UAbility_104554, TargetLocation) == 0x0029F8, "Member 'UAbility_104554::TargetLocation' has a wrong offset!");

// Class Hero_1045.TraceComponent_10455801_Base
// 0x0000 (0x2200 - 0x2200)
class UTraceComponent_10455801_Base final : public UMarvelAgentTraceComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TraceComponent_10455801_Base">();
	}
	static class UTraceComponent_10455801_Base* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTraceComponent_10455801_Base>();
	}
};
static_assert(alignof(UTraceComponent_10455801_Base) == 0x000010, "Wrong alignment on UTraceComponent_10455801_Base");
static_assert(sizeof(UTraceComponent_10455801_Base) == 0x002200, "Wrong size on UTraceComponent_10455801_Base");

// Class Hero_1045.EffectiveComponent_10455801
// 0x0010 (0x1C80 - 0x1C70)
class UEffectiveComponent_10455801 : public UMarvelAgentEffectiveComponent
{
public:
	class UCurveFloat*                            DamageCurve;                                       // 0x1C68(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AActor>                  LastHitActor;                                      // 0x1C70(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C78[0x8];                                     // 0x1C78(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	TArray<struct FHitResult> K2_OnPreApplyContainer(const TArray<struct FHitResult>& HitResults);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EffectiveComponent_10455801">();
	}
	static class UEffectiveComponent_10455801* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEffectiveComponent_10455801>();
	}
};
static_assert(alignof(UEffectiveComponent_10455801) == 0x000010, "Wrong alignment on UEffectiveComponent_10455801");
static_assert(sizeof(UEffectiveComponent_10455801) == 0x001C80, "Wrong size on UEffectiveComponent_10455801");
static_assert(offsetof(UEffectiveComponent_10455801, DamageCurve) == 0x001C68, "Member 'UEffectiveComponent_10455801::DamageCurve' has a wrong offset!");
static_assert(offsetof(UEffectiveComponent_10455801, LastHitActor) == 0x001C70, "Member 'UEffectiveComponent_10455801::LastHitActor' has a wrong offset!");

// Class Hero_1045.Cue_Scope_Loop_10455801
// 0x0270 (0x1340 - 0x10D0)
class ACue_Scope_Loop_10455801 final : public AMarvelCueNotify_TargetActor
{
public:
	class UNiagaraComponent*                      LoopNS_Main;                                       // 0x10D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      CharacterHitFx;                                    // 0x10D8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Loop2PAudioID;                                     // 0x10E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsOverrideStartLocation;                           // 0x10E4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10E5[0x3];                                     // 0x10E5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   StartSocketName;                                   // 0x10E8(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10F4[0x4];                                     // 0x10F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                StartLocationOffset;                               // 0x10F8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1110[0x18];                                    // 0x1110(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             HitResult;                                         // 0x1128(0x01F0)(Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class ASummoned_10455101>      OwnerSummoned;                                     // 0x1318(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1320[0x8];                                     // 0x1320(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AMarvelAbilityTargetActor_Scope*        OwnerScope;                                        // 0x1328(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AOneShotAudioActor*                     LaserLoopAudioActor;                               // 0x1330(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1338[0x8];                                     // 0x1338(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnTargetChanged(class UActorComponent* NewTargetComponent);
	void OnTraceHitResult(const TArray<struct FHitResult>& HitResults);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Scope_Loop_10455801">();
	}
	static class ACue_Scope_Loop_10455801* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Scope_Loop_10455801>();
	}
};
static_assert(alignof(ACue_Scope_Loop_10455801) == 0x000010, "Wrong alignment on ACue_Scope_Loop_10455801");
static_assert(sizeof(ACue_Scope_Loop_10455801) == 0x001340, "Wrong size on ACue_Scope_Loop_10455801");
static_assert(offsetof(ACue_Scope_Loop_10455801, LoopNS_Main) == 0x0010D0, "Member 'ACue_Scope_Loop_10455801::LoopNS_Main' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10455801, CharacterHitFx) == 0x0010D8, "Member 'ACue_Scope_Loop_10455801::CharacterHitFx' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10455801, Loop2PAudioID) == 0x0010E0, "Member 'ACue_Scope_Loop_10455801::Loop2PAudioID' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10455801, IsOverrideStartLocation) == 0x0010E4, "Member 'ACue_Scope_Loop_10455801::IsOverrideStartLocation' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10455801, StartSocketName) == 0x0010E8, "Member 'ACue_Scope_Loop_10455801::StartSocketName' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10455801, StartLocationOffset) == 0x0010F8, "Member 'ACue_Scope_Loop_10455801::StartLocationOffset' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10455801, HitResult) == 0x001128, "Member 'ACue_Scope_Loop_10455801::HitResult' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10455801, OwnerSummoned) == 0x001318, "Member 'ACue_Scope_Loop_10455801::OwnerSummoned' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10455801, OwnerScope) == 0x001328, "Member 'ACue_Scope_Loop_10455801::OwnerScope' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10455801, LaserLoopAudioActor) == 0x001330, "Member 'ACue_Scope_Loop_10455801::LaserLoopAudioActor' has a wrong offset!");

// Class Hero_1045.EffectiveComponent_10455901
// 0x0000 (0x1C70 - 0x1C70)
class UEffectiveComponent_10455901 : public UMarvelAgentEffectiveComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EffectiveComponent_10455901">();
	}
	static class UEffectiveComponent_10455901* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEffectiveComponent_10455901>();
	}
};
static_assert(alignof(UEffectiveComponent_10455901) == 0x000010, "Wrong alignment on UEffectiveComponent_10455901");
static_assert(sizeof(UEffectiveComponent_10455901) == 0x001C70, "Wrong size on UEffectiveComponent_10455901");

// Class Hero_1045.TraceComponent_10455901
// 0x0030 (0x2230 - 0x2200)
class UTraceComponent_10455901 : public UMarvelAgentTraceComponent
{
public:
	class FName                                   StartSocketName;                                   // 0x2200(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_220C[0x4];                                     // 0x220C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                StartLocationOffset;                               // 0x2210(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2228[0x8];                                     // 0x2228(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TraceComponent_10455901">();
	}
	static class UTraceComponent_10455901* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTraceComponent_10455901>();
	}
};
static_assert(alignof(UTraceComponent_10455901) == 0x000010, "Wrong alignment on UTraceComponent_10455901");
static_assert(sizeof(UTraceComponent_10455901) == 0x002230, "Wrong size on UTraceComponent_10455901");
static_assert(offsetof(UTraceComponent_10455901, StartSocketName) == 0x002200, "Member 'UTraceComponent_10455901::StartSocketName' has a wrong offset!");
static_assert(offsetof(UTraceComponent_10455901, StartLocationOffset) == 0x002210, "Member 'UTraceComponent_10455901::StartLocationOffset' has a wrong offset!");

// Class Hero_1045.Config_104561
// 0x0008 (0x00A0 - 0x0098)
class UConfig_104561 : public UMarvelAbilityConfig
{
public:
	float                                         WhaleFlyTime;                                      // 0x0098(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxHeight;                                         // 0x009C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_104561">();
	}
	static class UConfig_104561* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_104561>();
	}
};
static_assert(alignof(UConfig_104561) == 0x000008, "Wrong alignment on UConfig_104561");
static_assert(sizeof(UConfig_104561) == 0x0000A0, "Wrong size on UConfig_104561");
static_assert(offsetof(UConfig_104561, WhaleFlyTime) == 0x000098, "Member 'UConfig_104561::WhaleFlyTime' has a wrong offset!");
static_assert(offsetof(UConfig_104561, MaxHeight) == 0x00009C, "Member 'UConfig_104561::MaxHeight' has a wrong offset!");

// Class Hero_1045.EpicMomentAction_1045
// 0x0000 (0x0120 - 0x0120)
class UEpicMomentAction_1045 final : public UEpicMomentBaseAction
{
public:
	void OnProjectileBegin(class AActor* SourceActor, class UMarvelGameplayAbility* SourceAbility, class AActor* Projectile, const struct FMarvelTargetActorGenerateInfo& GenerateInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EpicMomentAction_1045">();
	}
	static class UEpicMomentAction_1045* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEpicMomentAction_1045>();
	}
};
static_assert(alignof(UEpicMomentAction_1045) == 0x000008, "Wrong alignment on UEpicMomentAction_1045");
static_assert(sizeof(UEpicMomentAction_1045) == 0x000120, "Wrong size on UEpicMomentAction_1045");

// Class Hero_1045.NamorAnimInstance
// 0x0010 (0x0A30 - 0x0A20)
class UNamorAnimInstance final : public UMarvelAnimInstance
{
public:
	bool                                          bIsLanding;                                        // 0x0A20(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A21[0x3];                                      // 0x0A21(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FallingForward;                                    // 0x0A24(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FallingRight;                                      // 0x0A28(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A2C[0x4];                                      // 0x0A2C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NamorAnimInstance">();
	}
	static class UNamorAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNamorAnimInstance>();
	}
};
static_assert(alignof(UNamorAnimInstance) == 0x000010, "Wrong alignment on UNamorAnimInstance");
static_assert(sizeof(UNamorAnimInstance) == 0x000A30, "Wrong size on UNamorAnimInstance");
static_assert(offsetof(UNamorAnimInstance, bIsLanding) == 0x000A20, "Member 'UNamorAnimInstance::bIsLanding' has a wrong offset!");
static_assert(offsetof(UNamorAnimInstance, FallingForward) == 0x000A24, "Member 'UNamorAnimInstance::FallingForward' has a wrong offset!");
static_assert(offsetof(UNamorAnimInstance, FallingRight) == 0x000A28, "Member 'UNamorAnimInstance::FallingRight' has a wrong offset!");

// Class Hero_1045.NamorOctopusAnimInstance
// 0x0020 (0x0470 - 0x0450)
class UNamorOctopusAnimInstance final : public UAnimInstance
{
public:
	class UOctopusAnimData*                       OctopusAnimData;                                   // 0x0448(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAimOffsetBlendSpace*                   MontageAimOffsetBlendSpace;                        // 0x0450(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          ShouldUseMontageAO;                                // 0x0458(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_459[0x3];                                      // 0x0459(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Pitch;                                             // 0x045C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Yaw;                                               // 0x0460(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsDead;                                           // 0x0464(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bBornOver;                                         // 0x0465(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_466[0xA];                                      // 0x0466(0x000A)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NamorOctopusAnimInstance">();
	}
	static class UNamorOctopusAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNamorOctopusAnimInstance>();
	}
};
static_assert(alignof(UNamorOctopusAnimInstance) == 0x000010, "Wrong alignment on UNamorOctopusAnimInstance");
static_assert(sizeof(UNamorOctopusAnimInstance) == 0x000470, "Wrong size on UNamorOctopusAnimInstance");
static_assert(offsetof(UNamorOctopusAnimInstance, OctopusAnimData) == 0x000448, "Member 'UNamorOctopusAnimInstance::OctopusAnimData' has a wrong offset!");
static_assert(offsetof(UNamorOctopusAnimInstance, MontageAimOffsetBlendSpace) == 0x000450, "Member 'UNamorOctopusAnimInstance::MontageAimOffsetBlendSpace' has a wrong offset!");
static_assert(offsetof(UNamorOctopusAnimInstance, ShouldUseMontageAO) == 0x000458, "Member 'UNamorOctopusAnimInstance::ShouldUseMontageAO' has a wrong offset!");
static_assert(offsetof(UNamorOctopusAnimInstance, Pitch) == 0x00045C, "Member 'UNamorOctopusAnimInstance::Pitch' has a wrong offset!");
static_assert(offsetof(UNamorOctopusAnimInstance, Yaw) == 0x000460, "Member 'UNamorOctopusAnimInstance::Yaw' has a wrong offset!");
static_assert(offsetof(UNamorOctopusAnimInstance, bIsDead) == 0x000464, "Member 'UNamorOctopusAnimInstance::bIsDead' has a wrong offset!");
static_assert(offsetof(UNamorOctopusAnimInstance, bBornOver) == 0x000465, "Member 'UNamorOctopusAnimInstance::bBornOver' has a wrong offset!");

// Class Hero_1045.OctopusAnimData
// 0x0018 (0x0058 - 0x0040)
class UOctopusAnimData final : public UAnimationDataCollection
{
public:
	class UAnimMontage*                           Turn_L90_MT;                                       // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           Turn_R90_MT;                                       // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          BornAnimSequence;                                  // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OctopusAnimData">();
	}
	static class UOctopusAnimData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOctopusAnimData>();
	}
};
static_assert(alignof(UOctopusAnimData) == 0x000008, "Wrong alignment on UOctopusAnimData");
static_assert(sizeof(UOctopusAnimData) == 0x000058, "Wrong size on UOctopusAnimData");
static_assert(offsetof(UOctopusAnimData, Turn_L90_MT) == 0x000040, "Member 'UOctopusAnimData::Turn_L90_MT' has a wrong offset!");
static_assert(offsetof(UOctopusAnimData, Turn_R90_MT) == 0x000048, "Member 'UOctopusAnimData::Turn_R90_MT' has a wrong offset!");
static_assert(offsetof(UOctopusAnimData, BornAnimSequence) == 0x000050, "Member 'UOctopusAnimData::BornAnimSequence' has a wrong offset!");

// Class Hero_1045.NamorOctopusAnimInstanceV2
// 0x0030 (0x0480 - 0x0450)
class UNamorOctopusAnimInstanceV2 final : public UAnimInstance
{
public:
	uint8                                         Pad_448[0x8];                                      // 0x0448(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UOctopusAnimData*                       OctopusAnimData;                                   // 0x0450(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAimOffsetBlendSpace*                   MontageAimOffsetBlendSpace;                        // 0x0458(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          ShouldUseMontageAO;                                // 0x0460(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_461[0x3];                                      // 0x0461(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Pitch;                                             // 0x0464(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Yaw;                                               // 0x0468(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         AnimState;                                         // 0x046C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_470[0x10];                                     // 0x0470(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FUpperBodyBlendSwitch GetCurrentUpperBodyBlendSwitch() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NamorOctopusAnimInstanceV2">();
	}
	static class UNamorOctopusAnimInstanceV2* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNamorOctopusAnimInstanceV2>();
	}
};
static_assert(alignof(UNamorOctopusAnimInstanceV2) == 0x000010, "Wrong alignment on UNamorOctopusAnimInstanceV2");
static_assert(sizeof(UNamorOctopusAnimInstanceV2) == 0x000480, "Wrong size on UNamorOctopusAnimInstanceV2");
static_assert(offsetof(UNamorOctopusAnimInstanceV2, OctopusAnimData) == 0x000450, "Member 'UNamorOctopusAnimInstanceV2::OctopusAnimData' has a wrong offset!");
static_assert(offsetof(UNamorOctopusAnimInstanceV2, MontageAimOffsetBlendSpace) == 0x000458, "Member 'UNamorOctopusAnimInstanceV2::MontageAimOffsetBlendSpace' has a wrong offset!");
static_assert(offsetof(UNamorOctopusAnimInstanceV2, ShouldUseMontageAO) == 0x000460, "Member 'UNamorOctopusAnimInstanceV2::ShouldUseMontageAO' has a wrong offset!");
static_assert(offsetof(UNamorOctopusAnimInstanceV2, Pitch) == 0x000464, "Member 'UNamorOctopusAnimInstanceV2::Pitch' has a wrong offset!");
static_assert(offsetof(UNamorOctopusAnimInstanceV2, Yaw) == 0x000468, "Member 'UNamorOctopusAnimInstanceV2::Yaw' has a wrong offset!");
static_assert(offsetof(UNamorOctopusAnimInstanceV2, AnimState) == 0x00046C, "Member 'UNamorOctopusAnimInstanceV2::AnimState' has a wrong offset!");

// Class Hero_1045.NamorCharacter
// 0x0040 (0x21E0 - 0x21A0)
#pragma pack(push, 0x1)
class alignas(0x10) ANamorCharacter : public AMarvelBaseCharacter
{
public:
	TMulticastInlineDelegate<void()>              OnNamorOctopusNumChange;                           // 0x21A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UPrimitiveComponent* TargetHitComponent, const struct FVector& HitPosition)> CommandOctopusAttackDelegate; // 0x21B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	int32                                         CurrentNumOfLiveOctopus;                           // 0x21C0(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21C4[0x4];                                     // 0x21C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UNamorMoveLogicBaseComponent*           NamorMoveLogic;                                    // 0x21C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_21D0[0x8];                                     // 0x21D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyBerserkBuff(const TArray<int32>& BerserkBuffIDs, const TArray<int32>& BerserkBuffSummonIDs, const struct FGameplayTagContainer& BerserkSummonTriggersCues, class UGameplayAbility* Ability);
	int32 ChangeNamorOctopusNum(int32 Delta);
	void OnRep_CurrentNumOfLiveOctopus();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NamorCharacter">();
	}
	static class ANamorCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANamorCharacter>();
	}
};
#pragma pack(pop)
static_assert(alignof(ANamorCharacter) == 0x000010, "Wrong alignment on ANamorCharacter");
static_assert(sizeof(ANamorCharacter) == 0x0021E0, "Wrong size on ANamorCharacter");
static_assert(offsetof(ANamorCharacter, OnNamorOctopusNumChange) == 0x0021A0, "Member 'ANamorCharacter::OnNamorOctopusNumChange' has a wrong offset!");
static_assert(offsetof(ANamorCharacter, CommandOctopusAttackDelegate) == 0x0021B0, "Member 'ANamorCharacter::CommandOctopusAttackDelegate' has a wrong offset!");
static_assert(offsetof(ANamorCharacter, CurrentNumOfLiveOctopus) == 0x0021C0, "Member 'ANamorCharacter::CurrentNumOfLiveOctopus' has a wrong offset!");
static_assert(offsetof(ANamorCharacter, NamorMoveLogic) == 0x0021C8, "Member 'ANamorCharacter::NamorMoveLogic' has a wrong offset!");

// Class Hero_1045.NamorChildActor
// 0x0000 (0x0E20 - 0x0E20)
class ANamorChildActor : public AMarvelCharacterChildActor
{
public:
	class USkeletalMeshComponent*                 HornMesh;                                          // 0x0E18(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NamorChildActor">();
	}
	static class ANamorChildActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANamorChildActor>();
	}
};
static_assert(alignof(ANamorChildActor) == 0x000010, "Wrong alignment on ANamorChildActor");
static_assert(sizeof(ANamorChildActor) == 0x000E20, "Wrong size on ANamorChildActor");
static_assert(offsetof(ANamorChildActor, HornMesh) == 0x000E18, "Member 'ANamorChildActor::HornMesh' has a wrong offset!");

// Class Hero_1045.NamorMoveLogicBaseComponent
// 0x0000 (0x0400 - 0x0400)
class UNamorMoveLogicBaseComponent final : public UMarvelMoveLogicBaseComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NamorMoveLogicBaseComponent">();
	}
	static class UNamorMoveLogicBaseComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNamorMoveLogicBaseComponent>();
	}
};
static_assert(alignof(UNamorMoveLogicBaseComponent) == 0x000008, "Wrong alignment on UNamorMoveLogicBaseComponent");
static_assert(sizeof(UNamorMoveLogicBaseComponent) == 0x000400, "Wrong size on UNamorMoveLogicBaseComponent");

// Class Hero_1045.NamorMovementComponent
// 0x0000 (0x2360 - 0x2360)
class UNamorMovementComponent final : public UMarvelCharacterMovementComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NamorMovementComponent">();
	}
	static class UNamorMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNamorMovementComponent>();
	}
};
static_assert(alignof(UNamorMovementComponent) == 0x000010, "Wrong alignment on UNamorMovementComponent");
static_assert(sizeof(UNamorMovementComponent) == 0x002360, "Wrong size on UNamorMovementComponent");

// Class Hero_1045.TabData_1045
// 0x0000 (0x0050 - 0x0050)
class UTabData_1045 final : public UHeroTabDataBase
{
public:
	void OnSummonedBegin(class AActor* SourceActor, class UMarvelGameplayAbility* SourceAbility, class AActor* Summoned, const struct FMarvelTargetActorGenerateInfo& GenerateInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TabData_1045">();
	}
	static class UTabData_1045* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTabData_1045>();
	}
};
static_assert(alignof(UTabData_1045) == 0x000008, "Wrong alignment on UTabData_1045");
static_assert(sizeof(UTabData_1045) == 0x000050, "Wrong size on UTabData_1045");

}

