#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Hero_1051

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "Marvel_classes.hpp"
#include "Hero_1051_structs.hpp"
#include "Hero_Synergy_classes.hpp"
#include "GameplayTags_structs.hpp"
#include "Engine_classes.hpp"


namespace SDK
{

// Class Hero_1051.Config_105131
// 0x0010 (0x00A8 - 0x0098)
class UConfig_105131 : public UMarvelAbilityConfig
{
public:
	float                                         DashAngleLimit;                                    // 0x0098(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DashOffsetRate;                                    // 0x009C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DashCameraPitchValue;                              // 0x00A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraPitchTurnSpeed;                              // 0x00A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_105131">();
	}
	static class UConfig_105131* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_105131>();
	}
};
static_assert(alignof(UConfig_105131) == 0x000008, "Wrong alignment on UConfig_105131");
static_assert(sizeof(UConfig_105131) == 0x0000A8, "Wrong size on UConfig_105131");
static_assert(offsetof(UConfig_105131, DashAngleLimit) == 0x000098, "Member 'UConfig_105131::DashAngleLimit' has a wrong offset!");
static_assert(offsetof(UConfig_105131, DashOffsetRate) == 0x00009C, "Member 'UConfig_105131::DashOffsetRate' has a wrong offset!");
static_assert(offsetof(UConfig_105131, DashCameraPitchValue) == 0x0000A0, "Member 'UConfig_105131::DashCameraPitchValue' has a wrong offset!");
static_assert(offsetof(UConfig_105131, CameraPitchTurnSpeed) == 0x0000A4, "Member 'UConfig_105131::CameraPitchTurnSpeed' has a wrong offset!");

// Class Hero_1051.Ability_105131
// 0x0020 (0x2A18 - 0x29F8)
class UAbility_105131 : public UAbility_108
{
public:
	float                                         VelocityOffsetAngle;                               // 0x29F8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RightInputOffset;                                  // 0x29FC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LeftInputOffset;                                   // 0x2A00(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsDashEnd;                                        // 0x2A04(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A05[0x3];                                     // 0x2A05(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UConfig_105131*                         Config;                                            // 0x2A08(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AMarvelBaseCharacter*                   OwnerCharacter;                                    // 0x2A10(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnDashFinish();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_105131">();
	}
	static class UAbility_105131* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_105131>();
	}
};
static_assert(alignof(UAbility_105131) == 0x000008, "Wrong alignment on UAbility_105131");
static_assert(sizeof(UAbility_105131) == 0x002A18, "Wrong size on UAbility_105131");
static_assert(offsetof(UAbility_105131, VelocityOffsetAngle) == 0x0029F8, "Member 'UAbility_105131::VelocityOffsetAngle' has a wrong offset!");
static_assert(offsetof(UAbility_105131, RightInputOffset) == 0x0029FC, "Member 'UAbility_105131::RightInputOffset' has a wrong offset!");
static_assert(offsetof(UAbility_105131, LeftInputOffset) == 0x002A00, "Member 'UAbility_105131::LeftInputOffset' has a wrong offset!");
static_assert(offsetof(UAbility_105131, bIsDashEnd) == 0x002A04, "Member 'UAbility_105131::bIsDashEnd' has a wrong offset!");
static_assert(offsetof(UAbility_105131, Config) == 0x002A08, "Member 'UAbility_105131::Config' has a wrong offset!");
static_assert(offsetof(UAbility_105131, OwnerCharacter) == 0x002A10, "Member 'UAbility_105131::OwnerCharacter' has a wrong offset!");

// Class Hero_1051.Config_105141
// 0x0000 (0x18B0 - 0x18B0)
class UConfig_105141 : public UMarvelLaunchToCharacterConfig
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_105141">();
	}
	static class UConfig_105141* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_105141>();
	}
};
static_assert(alignof(UConfig_105141) == 0x000010, "Wrong alignment on UConfig_105141");
static_assert(sizeof(UConfig_105141) == 0x0018B0, "Wrong size on UConfig_105141");

// Class Hero_1051.Ability_105141
// 0x0000 (0x2D40 - 0x2D40)
class UAbility_105141 : public UMarvelLaunchToCharacterAbility
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_105141">();
	}
	static class UAbility_105141* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_105141>();
	}
};
static_assert(alignof(UAbility_105141) == 0x000008, "Wrong alignment on UAbility_105141");
static_assert(sizeof(UAbility_105141) == 0x002D40, "Wrong size on UAbility_105141");

// Class Hero_1051.Cue_Ability_Loop_10514101
// 0x0040 (0x0FD0 - 0x0F90)
class ACue_Ability_Loop_10514101 : public AMarvelCueNotify_Actor
{
public:
	class UMaterialInterface*                     PostProcessingMaterial;                            // 0x0F88(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PostProcessTime;                                   // 0x0F90(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F94[0x4];                                      // 0x0F94(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialParameterCollectionInstance*   PostProcessingCollectionInstance;                  // 0x0F98(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               PostProcessingMaterialInstance;                    // 0x0FA0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_FA8[0x28];                                     // 0x0FA8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPostProcessEnd();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Ability_Loop_10514101">();
	}
	static class ACue_Ability_Loop_10514101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Ability_Loop_10514101>();
	}
};
static_assert(alignof(ACue_Ability_Loop_10514101) == 0x000010, "Wrong alignment on ACue_Ability_Loop_10514101");
static_assert(sizeof(ACue_Ability_Loop_10514101) == 0x000FD0, "Wrong size on ACue_Ability_Loop_10514101");
static_assert(offsetof(ACue_Ability_Loop_10514101, PostProcessingMaterial) == 0x000F88, "Member 'ACue_Ability_Loop_10514101::PostProcessingMaterial' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10514101, PostProcessTime) == 0x000F90, "Member 'ACue_Ability_Loop_10514101::PostProcessTime' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10514101, PostProcessingCollectionInstance) == 0x000F98, "Member 'ACue_Ability_Loop_10514101::PostProcessingCollectionInstance' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10514101, PostProcessingMaterialInstance) == 0x000FA0, "Member 'ACue_Ability_Loop_10514101::PostProcessingMaterialInstance' has a wrong offset!");

// Class Hero_1051.UIC_SelectTarget_105141
// 0x0000 (0x0158 - 0x0158)
class UUIC_SelectTarget_105141 final : public UUIC_SelectTarget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIC_SelectTarget_105141">();
	}
	static class UUIC_SelectTarget_105141* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIC_SelectTarget_105141>();
	}
};
static_assert(alignof(UUIC_SelectTarget_105141) == 0x000008, "Wrong alignment on UUIC_SelectTarget_105141");
static_assert(sizeof(UUIC_SelectTarget_105141) == 0x000158, "Wrong size on UUIC_SelectTarget_105141");

// Class Hero_1051.TraceComponent_10515101
// 0x0000 (0x2200 - 0x2200)
class UTraceComponent_10515101 : public UMarvelAgentTraceComponent
{
public:
	void DoTrace(const TArray<struct FVector>& ValidPoints);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TraceComponent_10515101">();
	}
	static class UTraceComponent_10515101* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTraceComponent_10515101>();
	}
};
static_assert(alignof(UTraceComponent_10515101) == 0x000010, "Wrong alignment on UTraceComponent_10515101");
static_assert(sizeof(UTraceComponent_10515101) == 0x002200, "Wrong size on UTraceComponent_10515101");

// Class Hero_1051.Ability_105151
// 0x0000 (0x29F8 - 0x29F8)
class UAbility_105151 : public UAbility_108
{
public:
	struct FRotator GetPointRotation(const struct FVector& InNormal, const struct FTransform& StandardTransform);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_105151">();
	}
	static class UAbility_105151* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_105151>();
	}
};
static_assert(alignof(UAbility_105151) == 0x000008, "Wrong alignment on UAbility_105151");
static_assert(sizeof(UAbility_105151) == 0x0029F8, "Wrong size on UAbility_105151");

// Class Hero_1051.Ability_105162
// 0x0018 (0x2A68 - 0x2A50)
class UAbility_105162 : public UAbility_100016
{
public:
	EAbilityState_105162                          CurrentAbilityState;                               // 0x2A50(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAbilityState_105162                          LastAbilityState;                                  // 0x2A51(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A52[0x6];                                     // 0x2A52(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class AMarvelBaseCharacter*                   OwnerChar;                                         // 0x2A58(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMarvelAbilityTask_PlayMontageAndWaitForEvent* TimelineTask;                               // 0x2A60(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void SwitchTimelineTask(const class FName& SectionName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_105162">();
	}
	static class UAbility_105162* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_105162>();
	}
};
static_assert(alignof(UAbility_105162) == 0x000008, "Wrong alignment on UAbility_105162");
static_assert(sizeof(UAbility_105162) == 0x002A68, "Wrong size on UAbility_105162");
static_assert(offsetof(UAbility_105162, CurrentAbilityState) == 0x002A50, "Member 'UAbility_105162::CurrentAbilityState' has a wrong offset!");
static_assert(offsetof(UAbility_105162, LastAbilityState) == 0x002A51, "Member 'UAbility_105162::LastAbilityState' has a wrong offset!");
static_assert(offsetof(UAbility_105162, OwnerChar) == 0x002A58, "Member 'UAbility_105162::OwnerChar' has a wrong offset!");
static_assert(offsetof(UAbility_105162, TimelineTask) == 0x002A60, "Member 'UAbility_105162::TimelineTask' has a wrong offset!");

// Class Hero_1051.Cue_Ability_Loop_10516202
// 0x0020 (0x11D0 - 0x11B0)
class ACue_Ability_Loop_10516202 final : public AMarvelCueNotify_Ability
{
public:
	TArray<struct FThrowMaterialInfo_105162>      ThrowMaterialInfos;                                // 0x11B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class AMarvelBaseCharacter*                   OwnerCharacter;                                    // 0x11C0(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11C8[0x8];                                     // 0x11C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Ability_Loop_10516202">();
	}
	static class ACue_Ability_Loop_10516202* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Ability_Loop_10516202>();
	}
};
static_assert(alignof(ACue_Ability_Loop_10516202) == 0x000010, "Wrong alignment on ACue_Ability_Loop_10516202");
static_assert(sizeof(ACue_Ability_Loop_10516202) == 0x0011D0, "Wrong size on ACue_Ability_Loop_10516202");
static_assert(offsetof(ACue_Ability_Loop_10516202, ThrowMaterialInfos) == 0x0011B0, "Member 'ACue_Ability_Loop_10516202::ThrowMaterialInfos' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_10516202, OwnerCharacter) == 0x0011C0, "Member 'ACue_Ability_Loop_10516202::OwnerCharacter' has a wrong offset!");

// Class Hero_1051.Config_105171
// 0x0030 (0x1B40 - 0x1B10)
class UConfig_105171 : public UConfig_100015
{
public:
	struct FVector                                AttachCylinderOffset;                              // 0x1B10(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AttachMeshOffset;                                  // 0x1B28(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_105171">();
	}
	static class UConfig_105171* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_105171>();
	}
};
static_assert(alignof(UConfig_105171) == 0x000010, "Wrong alignment on UConfig_105171");
static_assert(sizeof(UConfig_105171) == 0x001B40, "Wrong size on UConfig_105171");
static_assert(offsetof(UConfig_105171, AttachCylinderOffset) == 0x001B10, "Member 'UConfig_105171::AttachCylinderOffset' has a wrong offset!");
static_assert(offsetof(UConfig_105171, AttachMeshOffset) == 0x001B28, "Member 'UConfig_105171::AttachMeshOffset' has a wrong offset!");

// Class Hero_1051.Ability_105171
// 0x0010 (0x3270 - 0x3260)
class UAbility_105171 : public UAbility_100015
{
public:
	ESynergyState_105171                          CurrentState;                                      // 0x3260(0x0001)(BlueprintVisible, Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3261[0xF];                                     // 0x3261(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void MarkOnHumanTorch(bool bOnTarget);
	void MultiSetSpringArmIgnore(class AMarvelBaseCharacter* TargetCharacter, bool bIgnore);
	void OnRep_CurrentState();
	void ResetTimeAfterOnRep();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_105171">();
	}
	static class UAbility_105171* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_105171>();
	}
};
static_assert(alignof(UAbility_105171) == 0x000008, "Wrong alignment on UAbility_105171");
static_assert(sizeof(UAbility_105171) == 0x003270, "Wrong size on UAbility_105171");
static_assert(offsetof(UAbility_105171, CurrentState) == 0x003260, "Member 'UAbility_105171::CurrentState' has a wrong offset!");

// Class Hero_1051.Config_105172
// 0x0028 (0x00C0 - 0x0098)
class UConfig_105172 : public UMarvelAbilityConfig
{
public:
	struct FGameplayTag                           StartLaunchTag;                                    // 0x0098(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplyAttachParentVelocity;                        // 0x00A4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A5[0x3];                                       // 0x00A5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InitSpeed;                                         // 0x00A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AirControl;                                        // 0x00AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GravityScale;                                      // 0x00B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxCheckTime;                                      // 0x00B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FrameStepTime;                                     // 0x00B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_105172">();
	}
	static class UConfig_105172* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_105172>();
	}
};
static_assert(alignof(UConfig_105172) == 0x000008, "Wrong alignment on UConfig_105172");
static_assert(sizeof(UConfig_105172) == 0x0000C0, "Wrong size on UConfig_105172");
static_assert(offsetof(UConfig_105172, StartLaunchTag) == 0x000098, "Member 'UConfig_105172::StartLaunchTag' has a wrong offset!");
static_assert(offsetof(UConfig_105172, bApplyAttachParentVelocity) == 0x0000A4, "Member 'UConfig_105172::bApplyAttachParentVelocity' has a wrong offset!");
static_assert(offsetof(UConfig_105172, InitSpeed) == 0x0000A8, "Member 'UConfig_105172::InitSpeed' has a wrong offset!");
static_assert(offsetof(UConfig_105172, AirControl) == 0x0000AC, "Member 'UConfig_105172::AirControl' has a wrong offset!");
static_assert(offsetof(UConfig_105172, GravityScale) == 0x0000B0, "Member 'UConfig_105172::GravityScale' has a wrong offset!");
static_assert(offsetof(UConfig_105172, MaxCheckTime) == 0x0000B4, "Member 'UConfig_105172::MaxCheckTime' has a wrong offset!");
static_assert(offsetof(UConfig_105172, FrameStepTime) == 0x0000B8, "Member 'UConfig_105172::FrameStepTime' has a wrong offset!");

// Class Hero_1051.Ability_105172
// 0x0000 (0x29F8 - 0x29F8)
class UAbility_105172 : public UAbility_108
{
public:
	bool GetPredictHitLocation(const struct FVector& InitVelocity, struct FVector* OutLocation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_105172">();
	}
	static class UAbility_105172* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_105172>();
	}
};
static_assert(alignof(UAbility_105172) == 0x000008, "Wrong alignment on UAbility_105172");
static_assert(sizeof(UAbility_105172) == 0x0029F8, "Wrong size on UAbility_105172");

// Class Hero_1051.BenjaminGrimAnimInstance
// 0x0130 (0x0B50 - 0x0A20)
class UBenjaminGrimAnimInstance : public UMarvelAnimInstance
{
public:
	struct FGameplayTag                           SynergyRideTag;                                    // 0x0A20(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           SynergyRideGatheringTag;                           // 0x0A2C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           DashStateTag;                                      // 0x0A38(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           RushStateTag;                                      // 0x0A44(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              SynergyRideStartBlendDistanceRange;                // 0x0A50(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugDrawSocketRotation;                          // 0x0A60(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A61[0x3];                                      // 0x0A61(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           FlyingTag;                                         // 0x0A64(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           StartFlyTag;                                       // 0x0A70(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ControlATag;                                       // 0x0A7C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ControlDTag;                                       // 0x0A88(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ADControlAnimFactor;                               // 0x0A94(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlyBlendSpaceFactor;                               // 0x0A98(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInAbility31;                                      // 0x0A9C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bInAbility41;                                      // 0x0A9D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A9E[0x2];                                      // 0x0A9E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AngleWithAcceleration;                             // 0x0AA0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AngleWithVelocity;                                 // 0x0AA4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHasVelocity;                                      // 0x0AA8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bInSynergyRideState;                               // 0x0AA9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bInSynergyRideStateBlend;                          // 0x0AAA(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bInSynergyRideStartBlend;                          // 0x0AAB(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSynergyRideState_Enter;                           // 0x0AAC(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSynergyRideState_Exit;                            // 0x0AAD(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bInSynergyRideState_Gathering;                     // 0x0AAE(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          SynergyRideState_BeRide;                           // 0x0AAF(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_AB0[0x10];                                     // 0x0AB0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UAbility_105162*                        Ability_105162;                                    // 0x0AC0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_AC8[0x74];                                     // 0x0AC8(0x0074)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsSynergyStartFly;                                // 0x0B3C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B3D[0x3];                                      // 0x0B3D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SynergyRightValue;                                 // 0x0B40(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SynergyUpValue;                                    // 0x0B44(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B48[0x8];                                      // 0x0B48(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GetSynergyRideAnimation(const struct FAnimUpdateContext& PoseContext);
	void GetSynergyRideStartAnimation(const struct FAnimUpdateContext& PoseContext);
	void UpdateSynergyRideStartNode(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BenjaminGrimAnimInstance">();
	}
	static class UBenjaminGrimAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBenjaminGrimAnimInstance>();
	}
};
static_assert(alignof(UBenjaminGrimAnimInstance) == 0x000010, "Wrong alignment on UBenjaminGrimAnimInstance");
static_assert(sizeof(UBenjaminGrimAnimInstance) == 0x000B50, "Wrong size on UBenjaminGrimAnimInstance");
static_assert(offsetof(UBenjaminGrimAnimInstance, SynergyRideTag) == 0x000A20, "Member 'UBenjaminGrimAnimInstance::SynergyRideTag' has a wrong offset!");
static_assert(offsetof(UBenjaminGrimAnimInstance, SynergyRideGatheringTag) == 0x000A2C, "Member 'UBenjaminGrimAnimInstance::SynergyRideGatheringTag' has a wrong offset!");
static_assert(offsetof(UBenjaminGrimAnimInstance, DashStateTag) == 0x000A38, "Member 'UBenjaminGrimAnimInstance::DashStateTag' has a wrong offset!");
static_assert(offsetof(UBenjaminGrimAnimInstance, RushStateTag) == 0x000A44, "Member 'UBenjaminGrimAnimInstance::RushStateTag' has a wrong offset!");
static_assert(offsetof(UBenjaminGrimAnimInstance, SynergyRideStartBlendDistanceRange) == 0x000A50, "Member 'UBenjaminGrimAnimInstance::SynergyRideStartBlendDistanceRange' has a wrong offset!");
static_assert(offsetof(UBenjaminGrimAnimInstance, bDebugDrawSocketRotation) == 0x000A60, "Member 'UBenjaminGrimAnimInstance::bDebugDrawSocketRotation' has a wrong offset!");
static_assert(offsetof(UBenjaminGrimAnimInstance, FlyingTag) == 0x000A64, "Member 'UBenjaminGrimAnimInstance::FlyingTag' has a wrong offset!");
static_assert(offsetof(UBenjaminGrimAnimInstance, StartFlyTag) == 0x000A70, "Member 'UBenjaminGrimAnimInstance::StartFlyTag' has a wrong offset!");
static_assert(offsetof(UBenjaminGrimAnimInstance, ControlATag) == 0x000A7C, "Member 'UBenjaminGrimAnimInstance::ControlATag' has a wrong offset!");
static_assert(offsetof(UBenjaminGrimAnimInstance, ControlDTag) == 0x000A88, "Member 'UBenjaminGrimAnimInstance::ControlDTag' has a wrong offset!");
static_assert(offsetof(UBenjaminGrimAnimInstance, ADControlAnimFactor) == 0x000A94, "Member 'UBenjaminGrimAnimInstance::ADControlAnimFactor' has a wrong offset!");
static_assert(offsetof(UBenjaminGrimAnimInstance, FlyBlendSpaceFactor) == 0x000A98, "Member 'UBenjaminGrimAnimInstance::FlyBlendSpaceFactor' has a wrong offset!");
static_assert(offsetof(UBenjaminGrimAnimInstance, bInAbility31) == 0x000A9C, "Member 'UBenjaminGrimAnimInstance::bInAbility31' has a wrong offset!");
static_assert(offsetof(UBenjaminGrimAnimInstance, bInAbility41) == 0x000A9D, "Member 'UBenjaminGrimAnimInstance::bInAbility41' has a wrong offset!");
static_assert(offsetof(UBenjaminGrimAnimInstance, AngleWithAcceleration) == 0x000AA0, "Member 'UBenjaminGrimAnimInstance::AngleWithAcceleration' has a wrong offset!");
static_assert(offsetof(UBenjaminGrimAnimInstance, AngleWithVelocity) == 0x000AA4, "Member 'UBenjaminGrimAnimInstance::AngleWithVelocity' has a wrong offset!");
static_assert(offsetof(UBenjaminGrimAnimInstance, bHasVelocity) == 0x000AA8, "Member 'UBenjaminGrimAnimInstance::bHasVelocity' has a wrong offset!");
static_assert(offsetof(UBenjaminGrimAnimInstance, bInSynergyRideState) == 0x000AA9, "Member 'UBenjaminGrimAnimInstance::bInSynergyRideState' has a wrong offset!");
static_assert(offsetof(UBenjaminGrimAnimInstance, bInSynergyRideStateBlend) == 0x000AAA, "Member 'UBenjaminGrimAnimInstance::bInSynergyRideStateBlend' has a wrong offset!");
static_assert(offsetof(UBenjaminGrimAnimInstance, bInSynergyRideStartBlend) == 0x000AAB, "Member 'UBenjaminGrimAnimInstance::bInSynergyRideStartBlend' has a wrong offset!");
static_assert(offsetof(UBenjaminGrimAnimInstance, bSynergyRideState_Enter) == 0x000AAC, "Member 'UBenjaminGrimAnimInstance::bSynergyRideState_Enter' has a wrong offset!");
static_assert(offsetof(UBenjaminGrimAnimInstance, bSynergyRideState_Exit) == 0x000AAD, "Member 'UBenjaminGrimAnimInstance::bSynergyRideState_Exit' has a wrong offset!");
static_assert(offsetof(UBenjaminGrimAnimInstance, bInSynergyRideState_Gathering) == 0x000AAE, "Member 'UBenjaminGrimAnimInstance::bInSynergyRideState_Gathering' has a wrong offset!");
static_assert(offsetof(UBenjaminGrimAnimInstance, SynergyRideState_BeRide) == 0x000AAF, "Member 'UBenjaminGrimAnimInstance::SynergyRideState_BeRide' has a wrong offset!");
static_assert(offsetof(UBenjaminGrimAnimInstance, Ability_105162) == 0x000AC0, "Member 'UBenjaminGrimAnimInstance::Ability_105162' has a wrong offset!");
static_assert(offsetof(UBenjaminGrimAnimInstance, bIsSynergyStartFly) == 0x000B3C, "Member 'UBenjaminGrimAnimInstance::bIsSynergyStartFly' has a wrong offset!");
static_assert(offsetof(UBenjaminGrimAnimInstance, SynergyRightValue) == 0x000B40, "Member 'UBenjaminGrimAnimInstance::SynergyRightValue' has a wrong offset!");
static_assert(offsetof(UBenjaminGrimAnimInstance, SynergyUpValue) == 0x000B44, "Member 'UBenjaminGrimAnimInstance::SynergyUpValue' has a wrong offset!");

// Class Hero_1051.BanjaminAnimInstance_105161
// 0x0020 (0x0470 - 0x0450)
class UBanjaminAnimInstance_105161 final : public UAnimInstance
{
public:
	uint8                                         Pad_448[0x18];                                     // 0x0448(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          IsAccelerating;                                    // 0x0460(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInSynergyRideState;                               // 0x0461(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInSynergyRideState_Gathering;                     // 0x0462(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInSynergyRideState_Turning;                       // 0x0463(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInSynergyRideState_Gathering_Turning;             // 0x0464(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsForward;                                        // 0x0465(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_466[0x2];                                      // 0x0466(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Velocity;                                          // 0x0468(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldResetGroundDetailPost;                      // 0x046C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_46D[0x3];                                      // 0x046D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnGroundDetailPostBecomeRelevant(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);
	void OnReleantSynergyRideNode(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BanjaminAnimInstance_105161">();
	}
	static class UBanjaminAnimInstance_105161* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBanjaminAnimInstance_105161>();
	}
};
static_assert(alignof(UBanjaminAnimInstance_105161) == 0x000010, "Wrong alignment on UBanjaminAnimInstance_105161");
static_assert(sizeof(UBanjaminAnimInstance_105161) == 0x000470, "Wrong size on UBanjaminAnimInstance_105161");
static_assert(offsetof(UBanjaminAnimInstance_105161, IsAccelerating) == 0x000460, "Member 'UBanjaminAnimInstance_105161::IsAccelerating' has a wrong offset!");
static_assert(offsetof(UBanjaminAnimInstance_105161, bInSynergyRideState) == 0x000461, "Member 'UBanjaminAnimInstance_105161::bInSynergyRideState' has a wrong offset!");
static_assert(offsetof(UBanjaminAnimInstance_105161, bInSynergyRideState_Gathering) == 0x000462, "Member 'UBanjaminAnimInstance_105161::bInSynergyRideState_Gathering' has a wrong offset!");
static_assert(offsetof(UBanjaminAnimInstance_105161, bInSynergyRideState_Turning) == 0x000463, "Member 'UBanjaminAnimInstance_105161::bInSynergyRideState_Turning' has a wrong offset!");
static_assert(offsetof(UBanjaminAnimInstance_105161, bInSynergyRideState_Gathering_Turning) == 0x000464, "Member 'UBanjaminAnimInstance_105161::bInSynergyRideState_Gathering_Turning' has a wrong offset!");
static_assert(offsetof(UBanjaminAnimInstance_105161, bIsForward) == 0x000465, "Member 'UBanjaminAnimInstance_105161::bIsForward' has a wrong offset!");
static_assert(offsetof(UBanjaminAnimInstance_105161, Velocity) == 0x000468, "Member 'UBanjaminAnimInstance_105161::Velocity' has a wrong offset!");
static_assert(offsetof(UBanjaminAnimInstance_105161, bShouldResetGroundDetailPost) == 0x00046C, "Member 'UBanjaminAnimInstance_105161::bShouldResetGroundDetailPost' has a wrong offset!");

// Class Hero_1051.BenjaminGrimCharacter
// 0x0040 (0x21E0 - 0x21A0)
class ABenjaminGrimCharacter : public AMarvelBaseCharacter
{
public:
	class UBenjaminGrimMoveLogicBaseComponent*    BenjaminGrimMoveLogic;                             // 0x21A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URideOnCharacterManagementComponent*    SynergyRideManagementComponent;                    // 0x21A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMarvelMultiCapsuleComponent*           SynergyExtraCapsuleComponent;                      // 0x21B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           SynergyRideTag;                                    // 0x21B8(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_21C4[0x4];                                     // 0x21C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                SynergyExtraCapsuleRelativeLocation;               // 0x21C8(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetSynergyExtraCapsuleComponentEnabled(bool bEnabled);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BenjaminGrimCharacter">();
	}
	static class ABenjaminGrimCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABenjaminGrimCharacter>();
	}
};
static_assert(alignof(ABenjaminGrimCharacter) == 0x000010, "Wrong alignment on ABenjaminGrimCharacter");
static_assert(sizeof(ABenjaminGrimCharacter) == 0x0021E0, "Wrong size on ABenjaminGrimCharacter");
static_assert(offsetof(ABenjaminGrimCharacter, BenjaminGrimMoveLogic) == 0x0021A0, "Member 'ABenjaminGrimCharacter::BenjaminGrimMoveLogic' has a wrong offset!");
static_assert(offsetof(ABenjaminGrimCharacter, SynergyRideManagementComponent) == 0x0021A8, "Member 'ABenjaminGrimCharacter::SynergyRideManagementComponent' has a wrong offset!");
static_assert(offsetof(ABenjaminGrimCharacter, SynergyExtraCapsuleComponent) == 0x0021B0, "Member 'ABenjaminGrimCharacter::SynergyExtraCapsuleComponent' has a wrong offset!");
static_assert(offsetof(ABenjaminGrimCharacter, SynergyRideTag) == 0x0021B8, "Member 'ABenjaminGrimCharacter::SynergyRideTag' has a wrong offset!");
static_assert(offsetof(ABenjaminGrimCharacter, SynergyExtraCapsuleRelativeLocation) == 0x0021C8, "Member 'ABenjaminGrimCharacter::SynergyExtraCapsuleRelativeLocation' has a wrong offset!");

// Class Hero_1051.BenjaminGrimMoveLogicBaseComponent
// 0x0000 (0x0400 - 0x0400)
class UBenjaminGrimMoveLogicBaseComponent final : public UMarvelMoveLogicBaseComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BenjaminGrimMoveLogicBaseComponent">();
	}
	static class UBenjaminGrimMoveLogicBaseComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBenjaminGrimMoveLogicBaseComponent>();
	}
};
static_assert(alignof(UBenjaminGrimMoveLogicBaseComponent) == 0x000008, "Wrong alignment on UBenjaminGrimMoveLogicBaseComponent");
static_assert(sizeof(UBenjaminGrimMoveLogicBaseComponent) == 0x000400, "Wrong size on UBenjaminGrimMoveLogicBaseComponent");

// Class Hero_1051.BenjaminGrimMovementComponent
// 0x0020 (0x2380 - 0x2360)
class UBenjaminGrimMovementComponent final : public UMarvelCharacterMovementComponent
{
public:
	bool                                          bEnableSlideUp;                                    // 0x2360(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2361[0x7];                                     // 0x2361(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              SlideUpScale;                                      // 0x2368(0x0010)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2378[0x8];                                     // 0x2378(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BenjaminGrimMovementComponent">();
	}
	static class UBenjaminGrimMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBenjaminGrimMovementComponent>();
	}
};
static_assert(alignof(UBenjaminGrimMovementComponent) == 0x000010, "Wrong alignment on UBenjaminGrimMovementComponent");
static_assert(sizeof(UBenjaminGrimMovementComponent) == 0x002380, "Wrong size on UBenjaminGrimMovementComponent");
static_assert(offsetof(UBenjaminGrimMovementComponent, bEnableSlideUp) == 0x002360, "Member 'UBenjaminGrimMovementComponent::bEnableSlideUp' has a wrong offset!");
static_assert(offsetof(UBenjaminGrimMovementComponent, SlideUpScale) == 0x002368, "Member 'UBenjaminGrimMovementComponent::SlideUpScale' has a wrong offset!");

}

