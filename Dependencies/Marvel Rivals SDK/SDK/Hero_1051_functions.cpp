#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Hero_1051

#include "Basic.hpp"

#include "Hero_1051_classes.hpp"
#include "Hero_1051_parameters.hpp"


namespace SDK
{

// Function Hero_1051.Ability_105131.OnDashFinish
// (Event, Protected, BlueprintCallable, BlueprintEvent)

void UAbility_105131::OnDashFinish()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Ability_105131", "OnDashFinish");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Hero_1051.Cue_Ability_Loop_10514101.OnPostProcessEnd
// (Final, Native, Private)

void ACue_Ability_Loop_10514101::OnPostProcessEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Cue_Ability_Loop_10514101", "OnPostProcessEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Hero_1051.TraceComponent_10515101.DoTrace
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// const TArray<struct FVector>&           ValidPoints                                            (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void UTraceComponent_10515101::DoTrace(const TArray<struct FVector>& ValidPoints)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TraceComponent_10515101", "DoTrace");

	Params::TraceComponent_10515101_DoTrace Parms{};

	Parms.ValidPoints = std::move(ValidPoints);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Hero_1051.Ability_105151.GetPointRotation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   InNormal                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FTransform&                StandardTransform                                      (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UAbility_105151::GetPointRotation(const struct FVector& InNormal, const struct FTransform& StandardTransform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Ability_105151", "GetPointRotation");

	Params::Ability_105151_GetPointRotation Parms{};

	Parms.InNormal = std::move(InNormal);
	Parms.StandardTransform = std::move(StandardTransform);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Hero_1051.Ability_105162.SwitchTimelineTask
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FName&                      SectionName                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAbility_105162::SwitchTimelineTask(const class FName& SectionName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Ability_105162", "SwitchTimelineTask");

	Params::Ability_105162_SwitchTimelineTask Parms{};

	Parms.SectionName = SectionName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Hero_1051.Ability_105171.MarkOnHumanTorch
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bOnTarget                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAbility_105171::MarkOnHumanTorch(bool bOnTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Ability_105171", "MarkOnHumanTorch");

	Params::Ability_105171_MarkOnHumanTorch Parms{};

	Parms.bOnTarget = bOnTarget;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Hero_1051.Ability_105171.MultiSetSpringArmIgnore
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// class AMarvelBaseCharacter*             TargetCharacter                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIgnore                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAbility_105171::MultiSetSpringArmIgnore(class AMarvelBaseCharacter* TargetCharacter, bool bIgnore)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Ability_105171", "MultiSetSpringArmIgnore");

	Params::Ability_105171_MultiSetSpringArmIgnore Parms{};

	Parms.TargetCharacter = TargetCharacter;
	Parms.bIgnore = bIgnore;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Hero_1051.Ability_105171.OnRep_CurrentState
// (Final, Native, Public)

void UAbility_105171::OnRep_CurrentState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Ability_105171", "OnRep_CurrentState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Hero_1051.Ability_105171.ResetTimeAfterOnRep
// (Final, Native, Public, BlueprintCallable)

void UAbility_105171::ResetTimeAfterOnRep()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Ability_105171", "ResetTimeAfterOnRep");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Hero_1051.Ability_105172.GetPredictHitLocation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   InitVelocity                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector*                         OutLocation                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAbility_105172::GetPredictHitLocation(const struct FVector& InitVelocity, struct FVector* OutLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Ability_105172", "GetPredictHitLocation");

	Params::Ability_105172_GetPredictHitLocation Parms{};

	Parms.InitVelocity = std::move(InitVelocity);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutLocation != nullptr)
		*OutLocation = std::move(Parms.OutLocation);

	return Parms.ReturnValue;
}


// Function Hero_1051.BenjaminGrimAnimInstance.GetSynergyRideAnimation
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const struct FAnimUpdateContext&        PoseContext                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UBenjaminGrimAnimInstance::GetSynergyRideAnimation(const struct FAnimUpdateContext& PoseContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BenjaminGrimAnimInstance", "GetSynergyRideAnimation");

	Params::BenjaminGrimAnimInstance_GetSynergyRideAnimation Parms{};

	Parms.PoseContext = std::move(PoseContext);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Hero_1051.BenjaminGrimAnimInstance.GetSynergyRideStartAnimation
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const struct FAnimUpdateContext&        PoseContext                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UBenjaminGrimAnimInstance::GetSynergyRideStartAnimation(const struct FAnimUpdateContext& PoseContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BenjaminGrimAnimInstance", "GetSynergyRideStartAnimation");

	Params::BenjaminGrimAnimInstance_GetSynergyRideStartAnimation Parms{};

	Parms.PoseContext = std::move(PoseContext);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Hero_1051.BenjaminGrimAnimInstance.UpdateSynergyRideStartNode
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FAnimUpdateContext&        Context                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FAnimNodeReference&        Node                                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UBenjaminGrimAnimInstance::UpdateSynergyRideStartNode(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BenjaminGrimAnimInstance", "UpdateSynergyRideStartNode");

	Params::BenjaminGrimAnimInstance_UpdateSynergyRideStartNode Parms{};

	Parms.Context = std::move(Context);
	Parms.Node = std::move(Node);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Hero_1051.BanjaminAnimInstance_105161.OnGroundDetailPostBecomeRelevant
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FAnimUpdateContext&        Context                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FAnimNodeReference&        Node                                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UBanjaminAnimInstance_105161::OnGroundDetailPostBecomeRelevant(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BanjaminAnimInstance_105161", "OnGroundDetailPostBecomeRelevant");

	Params::BanjaminAnimInstance_105161_OnGroundDetailPostBecomeRelevant Parms{};

	Parms.Context = std::move(Context);
	Parms.Node = std::move(Node);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Hero_1051.BanjaminAnimInstance_105161.OnReleantSynergyRideNode
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FAnimUpdateContext&        Context                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FAnimNodeReference&        Node                                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UBanjaminAnimInstance_105161::OnReleantSynergyRideNode(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BanjaminAnimInstance_105161", "OnReleantSynergyRideNode");

	Params::BanjaminAnimInstance_105161_OnReleantSynergyRideNode Parms{};

	Parms.Context = std::move(Context);
	Parms.Node = std::move(Node);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Hero_1051.BenjaminGrimCharacter.SetSynergyExtraCapsuleComponentEnabled
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABenjaminGrimCharacter::SetSynergyExtraCapsuleComponentEnabled(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BenjaminGrimCharacter", "SetSynergyExtraCapsuleComponentEnabled");

	Params::BenjaminGrimCharacter_SetSynergyExtraCapsuleComponentEnabled Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}

}

