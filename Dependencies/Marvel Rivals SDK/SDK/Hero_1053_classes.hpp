#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Hero_1053

#include "Basic.hpp"

#include "Marvel_structs.hpp"
#include "Marvel_classes.hpp"
#include "Engine_structs.hpp"
#include "GameplayTags_structs.hpp"
#include "GameplayAbilities_classes.hpp"


namespace SDK
{

// Class Hero_1053.PlacementActor_10533101
// 0x1860 (0x3970 - 0x2110)
class APlacementActor_10533101 : public AMarvelAbilityTargetActor_PawnPlacement
{
public:
	class UConfig_105331*                         Config_105331;                                     // 0x2108(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FMarvelAbilityTraceContext             TraceContext;                                      // 0x2110(0x1660)(Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	float                                         CurrentLen;                                        // 0x3770(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3774[0x4];                                     // 0x3774(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             CurrentHit;                                        // 0x3778(0x01F0)(Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_3968[0x8];                                     // 0x3968(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlacementActor_10533101">();
	}
	static class APlacementActor_10533101* GetDefaultObj()
	{
		return GetDefaultObjImpl<APlacementActor_10533101>();
	}
};
static_assert(alignof(APlacementActor_10533101) == 0x000010, "Wrong alignment on APlacementActor_10533101");
static_assert(sizeof(APlacementActor_10533101) == 0x003970, "Wrong size on APlacementActor_10533101");
static_assert(offsetof(APlacementActor_10533101, Config_105331) == 0x002108, "Member 'APlacementActor_10533101::Config_105331' has a wrong offset!");
static_assert(offsetof(APlacementActor_10533101, TraceContext) == 0x002110, "Member 'APlacementActor_10533101::TraceContext' has a wrong offset!");
static_assert(offsetof(APlacementActor_10533101, CurrentLen) == 0x003770, "Member 'APlacementActor_10533101::CurrentLen' has a wrong offset!");
static_assert(offsetof(APlacementActor_10533101, CurrentHit) == 0x003778, "Member 'APlacementActor_10533101::CurrentHit' has a wrong offset!");

// Class Hero_1053.Config_105321
// 0x0010 (0x00A8 - 0x0098)
class UConfig_105321 : public UMarvelAbilityConfig
{
public:
	class UCurveFloat*                            EnergyDamageCurve;                                 // 0x0098(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            EnergyRadiusCurve;                                 // 0x00A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_105321">();
	}
	static class UConfig_105321* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_105321>();
	}
};
static_assert(alignof(UConfig_105321) == 0x000008, "Wrong alignment on UConfig_105321");
static_assert(sizeof(UConfig_105321) == 0x0000A8, "Wrong size on UConfig_105321");
static_assert(offsetof(UConfig_105321, EnergyDamageCurve) == 0x000098, "Member 'UConfig_105321::EnergyDamageCurve' has a wrong offset!");
static_assert(offsetof(UConfig_105321, EnergyRadiusCurve) == 0x0000A0, "Member 'UConfig_105321::EnergyRadiusCurve' has a wrong offset!");

// Class Hero_1053.TraceComponent_10532101
// 0x0000 (0x2200 - 0x2200)
class UTraceComponent_10532101 final : public UMarvelAgentTraceComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TraceComponent_10532101">();
	}
	static class UTraceComponent_10532101* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTraceComponent_10532101>();
	}
};
static_assert(alignof(UTraceComponent_10532101) == 0x000010, "Wrong alignment on UTraceComponent_10532101");
static_assert(sizeof(UTraceComponent_10532101) == 0x002200, "Wrong size on UTraceComponent_10532101");

// Class Hero_1053.BuffAbility_10536101
// 0x0018 (0x1388 - 0x1370)
class UBuffAbility_10536101 : public UMarvelEffectGameplayAbility
{
public:
	uint8                                         Pad_1370[0x8];                                     // 0x1370(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UConfig_105361*                         Config_105361;                                     // 0x1378(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1380[0x8];                                     // 0x1380(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnGameplayEffectStackChange(const struct FActiveGameplayEffectHandle& Handle, int32 NewCount, int32 OldCount);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuffAbility_10536101">();
	}
	static class UBuffAbility_10536101* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBuffAbility_10536101>();
	}
};
static_assert(alignof(UBuffAbility_10536101) == 0x000008, "Wrong alignment on UBuffAbility_10536101");
static_assert(sizeof(UBuffAbility_10536101) == 0x001388, "Wrong size on UBuffAbility_10536101");
static_assert(offsetof(UBuffAbility_10536101, Config_105361) == 0x001378, "Member 'UBuffAbility_10536101::Config_105361' has a wrong offset!");

// Class Hero_1053.EffectiveComponent_10532101_Base
// 0x0000 (0x1C70 - 0x1C70)
class UEffectiveComponent_10532101_Base final : public UMarvelAgentEffectiveComponent
{
public:
	TArray<struct FHitResult> K2_OnPreApplyContainer(const TArray<struct FHitResult>& HitResults);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EffectiveComponent_10532101_Base">();
	}
	static class UEffectiveComponent_10532101_Base* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEffectiveComponent_10532101_Base>();
	}
};
static_assert(alignof(UEffectiveComponent_10532101_Base) == 0x000010, "Wrong alignment on UEffectiveComponent_10532101_Base");
static_assert(sizeof(UEffectiveComponent_10532101_Base) == 0x001C70, "Wrong size on UEffectiveComponent_10532101_Base");

// Class Hero_1053.Cue_Scope_Loop_10532101
// 0x16B0 (0x4080 - 0x29D0)
#pragma pack(push, 0x1)
class alignas(0x10) ACue_Scope_Loop_10532101 : public AMarvelCueNotify_Laser
{
public:
	class UCurveFloat*                            EndScaleCurve;                                     // 0x29C8(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EnergyFullAudioID;                                 // 0x29D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FXLengthName;                                      // 0x29D4(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29E0[0x18];                                    // 0x29E0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            CachedFloatCurve;                                  // 0x29F8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A00[0x1660];                                  // 0x2A00(0x1660)(Fixing Size After Last Property [ Dumper-7 ])
	class AMarvelBaseCharacter*                   OwnerChar;                                         // 0x4060(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4068[0x10];                                    // 0x4068(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UCurveFloat* GetEnergyRadiusCurve();
	void OnManaAttributeChanged(class AActor* InSourceAvatar, const struct FAttributeModifierHandle& ModifierParameterHandle);
	void RefreshAudio();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Scope_Loop_10532101">();
	}
	static class ACue_Scope_Loop_10532101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Scope_Loop_10532101>();
	}
};
#pragma pack(pop)
static_assert(alignof(ACue_Scope_Loop_10532101) == 0x000010, "Wrong alignment on ACue_Scope_Loop_10532101");
static_assert(sizeof(ACue_Scope_Loop_10532101) == 0x004080, "Wrong size on ACue_Scope_Loop_10532101");
static_assert(offsetof(ACue_Scope_Loop_10532101, EndScaleCurve) == 0x0029C8, "Member 'ACue_Scope_Loop_10532101::EndScaleCurve' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10532101, EnergyFullAudioID) == 0x0029D0, "Member 'ACue_Scope_Loop_10532101::EnergyFullAudioID' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10532101, FXLengthName) == 0x0029D4, "Member 'ACue_Scope_Loop_10532101::FXLengthName' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10532101, CachedFloatCurve) == 0x0029F8, "Member 'ACue_Scope_Loop_10532101::CachedFloatCurve' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10532101, OwnerChar) == 0x004060, "Member 'ACue_Scope_Loop_10532101::OwnerChar' has a wrong offset!");

// Class Hero_1053.Cue_Scope_Loop_10532109
// 0x0060 (0x40E0 - 0x4080)
class ACue_Scope_Loop_10532109 : public ACue_Scope_Loop_10532101
{
public:
	TMap<class AMarvelBaseCharacter*, class UFXSystemComponent*> CharacterHitsActor2FXMap;           // 0x4078(0x0050)(ExportObject, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<ECollisionChannel>                     BlockChannels;                                     // 0x40C8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_40D8[0x8];                                     // 0x40D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Scope_Loop_10532109">();
	}
	static class ACue_Scope_Loop_10532109* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Scope_Loop_10532109>();
	}
};
static_assert(alignof(ACue_Scope_Loop_10532109) == 0x000010, "Wrong alignment on ACue_Scope_Loop_10532109");
static_assert(sizeof(ACue_Scope_Loop_10532109) == 0x0040E0, "Wrong size on ACue_Scope_Loop_10532109");
static_assert(offsetof(ACue_Scope_Loop_10532109, CharacterHitsActor2FXMap) == 0x004078, "Member 'ACue_Scope_Loop_10532109::CharacterHitsActor2FXMap' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_10532109, BlockChannels) == 0x0040C8, "Member 'ACue_Scope_Loop_10532109::BlockChannels' has a wrong offset!");

// Class Hero_1053.Config_105331
// 0x2CF8 (0x2D90 - 0x0098)
class UConfig_105331 : public UMarvelAbilityConfig
{
public:
	uint8                                         Pad_98[0x8];                                       // 0x0098(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMarvelAbilityTraceContext             TraceContext;                                      // 0x00A0(0x1660)(Edit, BlueprintVisible, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FMarvelAbilityTraceContext             SelectTraceCapsuleContext;                         // 0x1700(0x1660)(Edit, BlueprintVisible, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         SelectTargetSpeed;                                 // 0x2D60(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D64[0x4];                                     // 0x2D64(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AMarvelAbilityTargetActor_Base> TraceActorClass;                               // 0x2D68(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           CueTag;                                            // 0x2D70(0x000C)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinLen;                                            // 0x2D7C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxLen;                                            // 0x2D80(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D84[0xC];                                     // 0x2D84(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_105331">();
	}
	static class UConfig_105331* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_105331>();
	}
};
static_assert(alignof(UConfig_105331) == 0x000010, "Wrong alignment on UConfig_105331");
static_assert(sizeof(UConfig_105331) == 0x002D90, "Wrong size on UConfig_105331");
static_assert(offsetof(UConfig_105331, TraceContext) == 0x0000A0, "Member 'UConfig_105331::TraceContext' has a wrong offset!");
static_assert(offsetof(UConfig_105331, SelectTraceCapsuleContext) == 0x001700, "Member 'UConfig_105331::SelectTraceCapsuleContext' has a wrong offset!");
static_assert(offsetof(UConfig_105331, SelectTargetSpeed) == 0x002D60, "Member 'UConfig_105331::SelectTargetSpeed' has a wrong offset!");
static_assert(offsetof(UConfig_105331, TraceActorClass) == 0x002D68, "Member 'UConfig_105331::TraceActorClass' has a wrong offset!");
static_assert(offsetof(UConfig_105331, CueTag) == 0x002D70, "Member 'UConfig_105331::CueTag' has a wrong offset!");
static_assert(offsetof(UConfig_105331, MinLen) == 0x002D7C, "Member 'UConfig_105331::MinLen' has a wrong offset!");
static_assert(offsetof(UConfig_105331, MaxLen) == 0x002D80, "Member 'UConfig_105331::MaxLen' has a wrong offset!");

// Class Hero_1053.AbilityTask_105331
// 0x0000 (0x01A0 - 0x01A0)
class UAbilityTask_105331 final : public UAbilityTask
{
public:
	static class UMarvelAbilityTask_WaitAbilityTargetData* CreateAbilityTask_105331(class UMarvelGameplayAbility* OwningAbility, class FName TaskName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbilityTask_105331">();
	}
	static class UAbilityTask_105331* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityTask_105331>();
	}
};
static_assert(alignof(UAbilityTask_105331) == 0x000008, "Wrong alignment on UAbilityTask_105331");
static_assert(sizeof(UAbilityTask_105331) == 0x0001A0, "Wrong size on UAbilityTask_105331");

// Class Hero_1053.Config_105361
// 0x0010 (0x00A8 - 0x0098)
class UConfig_105361 : public UMarvelAbilityConfig
{
public:
	int32                                         SilenceBuffID;                                     // 0x0098(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SilenceFadeoutDelay;                               // 0x009C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SilenceFadeoutSpeed;                               // 0x00A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_105361">();
	}
	static class UConfig_105361* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_105361>();
	}
};
static_assert(alignof(UConfig_105361) == 0x000008, "Wrong alignment on UConfig_105361");
static_assert(sizeof(UConfig_105361) == 0x0000A8, "Wrong size on UConfig_105361");
static_assert(offsetof(UConfig_105361, SilenceBuffID) == 0x000098, "Member 'UConfig_105361::SilenceBuffID' has a wrong offset!");
static_assert(offsetof(UConfig_105361, SilenceFadeoutDelay) == 0x00009C, "Member 'UConfig_105361::SilenceFadeoutDelay' has a wrong offset!");
static_assert(offsetof(UConfig_105361, SilenceFadeoutSpeed) == 0x0000A0, "Member 'UConfig_105361::SilenceFadeoutSpeed' has a wrong offset!");

// Class Hero_1053.BuffAbility_10536102
// 0x0080 (0x1428 - 0x13A8)
class UBuffAbility_10536102 : public UAbility_136_AddMovementInput
{
public:
	struct FGameplayTagContainer                  BindTags;                                          // 0x13A8(0x0068)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         Pad_1410[0x18];                                    // 0x1410(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnGameplayTagUpdate(const struct FGameplayTag& InTag, bool bExist);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuffAbility_10536102">();
	}
	static class UBuffAbility_10536102* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBuffAbility_10536102>();
	}
};
static_assert(alignof(UBuffAbility_10536102) == 0x000008, "Wrong alignment on UBuffAbility_10536102");
static_assert(sizeof(UBuffAbility_10536102) == 0x001428, "Wrong size on UBuffAbility_10536102");
static_assert(offsetof(UBuffAbility_10536102, BindTags) == 0x0013A8, "Member 'UBuffAbility_10536102::BindTags' has a wrong offset!");

// Class Hero_1053.Cue_Scope_Loop_105361
// 0x0010 (0x10F0 - 0x10E0)
class ACue_Scope_Loop_105361 : public AMarvelCueNotify_Scope
{
public:
	class USceneComponent*                        NiagaraComp;                                       // 0x10E0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class ACharacter>              OwnerChar;                                         // 0x10E8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Scope_Loop_105361">();
	}
	static class ACue_Scope_Loop_105361* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Scope_Loop_105361>();
	}
};
static_assert(alignof(ACue_Scope_Loop_105361) == 0x000010, "Wrong alignment on ACue_Scope_Loop_105361");
static_assert(sizeof(ACue_Scope_Loop_105361) == 0x0010F0, "Wrong size on ACue_Scope_Loop_105361");
static_assert(offsetof(ACue_Scope_Loop_105361, NiagaraComp) == 0x0010E0, "Member 'ACue_Scope_Loop_105361::NiagaraComp' has a wrong offset!");
static_assert(offsetof(ACue_Scope_Loop_105361, OwnerChar) == 0x0010E8, "Member 'ACue_Scope_Loop_105361::OwnerChar' has a wrong offset!");

// Class Hero_1053.WhiteQueenAnimInstance
// 0x0000 (0x0A20 - 0x0A20)
class UWhiteQueenAnimInstance : public UMarvelAnimInstance
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WhiteQueenAnimInstance">();
	}
	static class UWhiteQueenAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWhiteQueenAnimInstance>();
	}
};
static_assert(alignof(UWhiteQueenAnimInstance) == 0x000010, "Wrong alignment on UWhiteQueenAnimInstance");
static_assert(sizeof(UWhiteQueenAnimInstance) == 0x000A20, "Wrong size on UWhiteQueenAnimInstance");

// Class Hero_1053.WhiteQueenCharacter
// 0x0010 (0x21B0 - 0x21A0)
class AWhiteQueenCharacter : public AMarvelBaseCharacter
{
public:
	class UWhiteQueenMoveLogicBaseComponent*      WhiteQueenMoveLogic;                               // 0x21A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bInThrowingState;                                  // 0x21A8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_21A9[0x7];                                     // 0x21A9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool InThrowingState() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WhiteQueenCharacter">();
	}
	static class AWhiteQueenCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWhiteQueenCharacter>();
	}
};
static_assert(alignof(AWhiteQueenCharacter) == 0x000010, "Wrong alignment on AWhiteQueenCharacter");
static_assert(sizeof(AWhiteQueenCharacter) == 0x0021B0, "Wrong size on AWhiteQueenCharacter");
static_assert(offsetof(AWhiteQueenCharacter, WhiteQueenMoveLogic) == 0x0021A0, "Member 'AWhiteQueenCharacter::WhiteQueenMoveLogic' has a wrong offset!");
static_assert(offsetof(AWhiteQueenCharacter, bInThrowingState) == 0x0021A8, "Member 'AWhiteQueenCharacter::bInThrowingState' has a wrong offset!");

// Class Hero_1053.WhiteQueenMoveLogicBaseComponent
// 0x0000 (0x0400 - 0x0400)
class UWhiteQueenMoveLogicBaseComponent final : public UMarvelMoveLogicBaseComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WhiteQueenMoveLogicBaseComponent">();
	}
	static class UWhiteQueenMoveLogicBaseComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWhiteQueenMoveLogicBaseComponent>();
	}
};
static_assert(alignof(UWhiteQueenMoveLogicBaseComponent) == 0x000008, "Wrong alignment on UWhiteQueenMoveLogicBaseComponent");
static_assert(sizeof(UWhiteQueenMoveLogicBaseComponent) == 0x000400, "Wrong size on UWhiteQueenMoveLogicBaseComponent");

// Class Hero_1053.WhiteQueenMovementComponent
// 0x0020 (0x2380 - 0x2360)
class UWhiteQueenMovementComponent final : public UMarvelCharacterMovementComponent
{
public:
	class AWhiteQueenCharacter*                   WhiteQueenCharacter;                               // 0x2360(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2368[0x18];                                    // 0x2368(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnTagUpdate(const struct FGameplayTag& Tag, bool TagExists);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WhiteQueenMovementComponent">();
	}
	static class UWhiteQueenMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWhiteQueenMovementComponent>();
	}
};
static_assert(alignof(UWhiteQueenMovementComponent) == 0x000010, "Wrong alignment on UWhiteQueenMovementComponent");
static_assert(sizeof(UWhiteQueenMovementComponent) == 0x002380, "Wrong size on UWhiteQueenMovementComponent");
static_assert(offsetof(UWhiteQueenMovementComponent, WhiteQueenCharacter) == 0x002360, "Member 'UWhiteQueenMovementComponent::WhiteQueenCharacter' has a wrong offset!");

}

