#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Hero_1056

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "Marvel_structs.hpp"
#include "Marvel_classes.hpp"
#include "GameplayAbilities_structs.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "GameplayTags_structs.hpp"
#include "Hero_1056_structs.hpp"


namespace SDK
{

// Class Hero_1056.Ability_105601
// 0x0000 (0x2B10 - 0x2B10)
class UAbility_105601 : public UMarvelAeroBaseAbility
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_105601">();
	}
	static class UAbility_105601* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_105601>();
	}
};
static_assert(alignof(UAbility_105601) == 0x000008, "Wrong alignment on UAbility_105601");
static_assert(sizeof(UAbility_105601) == 0x002B10, "Wrong size on UAbility_105601");

// Class Hero_1056.Ability_105602
// 0x0008 (0x2BE0 - 0x2BD8)
class UAbility_105602 : public UGlidingAbility
{
public:
	bool                                          bCheckTargetTagsWhenActivate;                      // 0x2BD8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BD9[0x7];                                     // 0x2BD9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_105602">();
	}
	static class UAbility_105602* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_105602>();
	}
};
static_assert(alignof(UAbility_105602) == 0x000008, "Wrong alignment on UAbility_105602");
static_assert(sizeof(UAbility_105602) == 0x002BE0, "Wrong size on UAbility_105602");
static_assert(offsetof(UAbility_105602, bCheckTargetTagsWhenActivate) == 0x002BD8, "Member 'UAbility_105602::bCheckTargetTagsWhenActivate' has a wrong offset!");

// Class Hero_1056.Cue_AbilityLoop_10560201
// 0x0020 (0x11D0 - 0x11B0)
class ACue_AbilityLoop_10560201 : public AMarvelCueNotify_Ability
{
public:
	uint8                                         Pad_11B0[0x4];                                     // 0x11B0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PlayingTimelineIndex;                              // 0x11B4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMarvelGameplayAbility*                 Ability;                                           // 0x11B8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      NiagaraLoopFX;                                     // 0x11C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11C8[0x8];                                     // 0x11C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnReceiveTimelineSectionSwitch(class UAnimTimeline* InTimeline, const class FString& SectionName);
	void OnTimelineChanged(const int32 NewIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_AbilityLoop_10560201">();
	}
	static class ACue_AbilityLoop_10560201* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_AbilityLoop_10560201>();
	}
};
static_assert(alignof(ACue_AbilityLoop_10560201) == 0x000010, "Wrong alignment on ACue_AbilityLoop_10560201");
static_assert(sizeof(ACue_AbilityLoop_10560201) == 0x0011D0, "Wrong size on ACue_AbilityLoop_10560201");
static_assert(offsetof(ACue_AbilityLoop_10560201, PlayingTimelineIndex) == 0x0011B4, "Member 'ACue_AbilityLoop_10560201::PlayingTimelineIndex' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_10560201, Ability) == 0x0011B8, "Member 'ACue_AbilityLoop_10560201::Ability' has a wrong offset!");
static_assert(offsetof(ACue_AbilityLoop_10560201, NiagaraLoopFX) == 0x0011C0, "Member 'ACue_AbilityLoop_10560201::NiagaraLoopFX' has a wrong offset!");

// Class Hero_1056.Summoned_10563101
// 0x00A0 (0x0C70 - 0x0BD0)
class ASummoned_10563101 : public AMarvelBarrierBase
{
public:
	bool                                          bEnableAttachToMesh;                               // 0x0BD0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BD1[0x3];                                      // 0x0BD1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   MeshSocket;                                        // 0x0BD4(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AttachSocketOffset_Air;                            // 0x0BE0(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AttachSocketOffset_Ground;                         // 0x0BF8(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               AttachSocketRotation_Air;                          // 0x0C10(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               AttachSocketRotation_Ground;                       // 0x0C28(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                LocalOriginCoordinates;                            // 0x0C40(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Length;                                            // 0x0C58(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxPitch;                                          // 0x0C5C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinPitch;                                          // 0x0C60(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TickAniCount;                                      // 0x0C64(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C68[0x8];                                      // 0x0C68(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Summoned_10563101">();
	}
	static class ASummoned_10563101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASummoned_10563101>();
	}
};
static_assert(alignof(ASummoned_10563101) == 0x000010, "Wrong alignment on ASummoned_10563101");
static_assert(sizeof(ASummoned_10563101) == 0x000C70, "Wrong size on ASummoned_10563101");
static_assert(offsetof(ASummoned_10563101, bEnableAttachToMesh) == 0x000BD0, "Member 'ASummoned_10563101::bEnableAttachToMesh' has a wrong offset!");
static_assert(offsetof(ASummoned_10563101, MeshSocket) == 0x000BD4, "Member 'ASummoned_10563101::MeshSocket' has a wrong offset!");
static_assert(offsetof(ASummoned_10563101, AttachSocketOffset_Air) == 0x000BE0, "Member 'ASummoned_10563101::AttachSocketOffset_Air' has a wrong offset!");
static_assert(offsetof(ASummoned_10563101, AttachSocketOffset_Ground) == 0x000BF8, "Member 'ASummoned_10563101::AttachSocketOffset_Ground' has a wrong offset!");
static_assert(offsetof(ASummoned_10563101, AttachSocketRotation_Air) == 0x000C10, "Member 'ASummoned_10563101::AttachSocketRotation_Air' has a wrong offset!");
static_assert(offsetof(ASummoned_10563101, AttachSocketRotation_Ground) == 0x000C28, "Member 'ASummoned_10563101::AttachSocketRotation_Ground' has a wrong offset!");
static_assert(offsetof(ASummoned_10563101, LocalOriginCoordinates) == 0x000C40, "Member 'ASummoned_10563101::LocalOriginCoordinates' has a wrong offset!");
static_assert(offsetof(ASummoned_10563101, Length) == 0x000C58, "Member 'ASummoned_10563101::Length' has a wrong offset!");
static_assert(offsetof(ASummoned_10563101, MaxPitch) == 0x000C5C, "Member 'ASummoned_10563101::MaxPitch' has a wrong offset!");
static_assert(offsetof(ASummoned_10563101, MinPitch) == 0x000C60, "Member 'ASummoned_10563101::MinPitch' has a wrong offset!");
static_assert(offsetof(ASummoned_10563101, TickAniCount) == 0x000C64, "Member 'ASummoned_10563101::TickAniCount' has a wrong offset!");

// Class Hero_1056.Config_105641
// 0x1680 (0x17F0 - 0x0170)
class UConfig_105641 : public UGlidingAbilityConfig
{
public:
	int32                                         GrabbedTargetCount;                                // 0x0170(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GrabbedScopeID;                                    // 0x0174(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GrabbedDistanceCheckThreshold;                     // 0x0178(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCheckBlock;                                       // 0x017C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17D[0x3];                                      // 0x017D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxBlockTime;                                      // 0x0180(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_184[0xC];                                      // 0x0184(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMarvelAbilityTraceContext             SceneTraceContext;                                 // 0x0190(0x1660)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_105641">();
	}
	static class UConfig_105641* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_105641>();
	}
};
static_assert(alignof(UConfig_105641) == 0x000010, "Wrong alignment on UConfig_105641");
static_assert(sizeof(UConfig_105641) == 0x0017F0, "Wrong size on UConfig_105641");
static_assert(offsetof(UConfig_105641, GrabbedTargetCount) == 0x000170, "Member 'UConfig_105641::GrabbedTargetCount' has a wrong offset!");
static_assert(offsetof(UConfig_105641, GrabbedScopeID) == 0x000174, "Member 'UConfig_105641::GrabbedScopeID' has a wrong offset!");
static_assert(offsetof(UConfig_105641, GrabbedDistanceCheckThreshold) == 0x000178, "Member 'UConfig_105641::GrabbedDistanceCheckThreshold' has a wrong offset!");
static_assert(offsetof(UConfig_105641, bCheckBlock) == 0x00017C, "Member 'UConfig_105641::bCheckBlock' has a wrong offset!");
static_assert(offsetof(UConfig_105641, MaxBlockTime) == 0x000180, "Member 'UConfig_105641::MaxBlockTime' has a wrong offset!");
static_assert(offsetof(UConfig_105641, SceneTraceContext) == 0x000190, "Member 'UConfig_105641::SceneTraceContext' has a wrong offset!");

// Class Hero_1056.Ability_105641
// 0x00F0 (0x2CC8 - 0x2BD8)
class UAbility_105641 : public UGlidingAbility
{
public:
	TArray<class ACharacter*>                     GrabbedTargets;                                    // 0x2BD8(0x0010)(BlueprintVisible, Net, ZeroConstructor, RepNotify, Protected, NativeAccessSpecifierProtected)
	class UMarvelAbilityTask_WaitTargetData*      ServerWaitGrabTargetTask;                          // 0x2BE8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AMarvelBaseCharacter*                   OwnerCharacter;                                    // 0x2BF0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UConfig_105641*                         Config;                                            // 0x2BF8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMarvelBaseAbilitySystemComponent*      ASC;                                               // 0x2C00(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FPredictionKey                         ServerNotifyGrabFailedRPCKey;                      // 0x2C08(0x0070)(Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class ACharacter*, float>                BlockAccumulatedTimes;                             // 0x2C78(0x0050)(BlueprintVisible, Transient, Protected, NativeAccessSpecifierProtected)

public:
	void CallServerDoGrabTarget(class ACharacter* InTarget, const int32 PinSlotIndex, const bool bNeedCollideKnockDown);
	bool DoGrabTarget(class ACharacter* InTarget, const int32 PinSlotIndex, const bool bNeedCollideKnockDown);
	TArray<class ACharacter*> GetCurrentGrabTargets();
	void OnPredictingClientGrabTargetPredictFailed(class ACharacter* InCharacter);
	void OnRep_GrabbedTargets();
	void OnServerReceiveGrabTarget(const struct FGameplayAbilityTargetDataHandle& Data);
	void RegisterGrabTarget(class ACharacter* InTarget);
	void RemoveBlockedGrabTarget(class ACharacter* InCharacter);
	void TriggerClientGrabTargetPredictFailed(class ACharacter* InCharacter);
	void TryGrabTarget(class ACharacter* InTarget, const struct FHitResult& HitRes);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_105641">();
	}
	static class UAbility_105641* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_105641>();
	}
};
static_assert(alignof(UAbility_105641) == 0x000008, "Wrong alignment on UAbility_105641");
static_assert(sizeof(UAbility_105641) == 0x002CC8, "Wrong size on UAbility_105641");
static_assert(offsetof(UAbility_105641, GrabbedTargets) == 0x002BD8, "Member 'UAbility_105641::GrabbedTargets' has a wrong offset!");
static_assert(offsetof(UAbility_105641, ServerWaitGrabTargetTask) == 0x002BE8, "Member 'UAbility_105641::ServerWaitGrabTargetTask' has a wrong offset!");
static_assert(offsetof(UAbility_105641, OwnerCharacter) == 0x002BF0, "Member 'UAbility_105641::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(UAbility_105641, Config) == 0x002BF8, "Member 'UAbility_105641::Config' has a wrong offset!");
static_assert(offsetof(UAbility_105641, ASC) == 0x002C00, "Member 'UAbility_105641::ASC' has a wrong offset!");
static_assert(offsetof(UAbility_105641, ServerNotifyGrabFailedRPCKey) == 0x002C08, "Member 'UAbility_105641::ServerNotifyGrabFailedRPCKey' has a wrong offset!");
static_assert(offsetof(UAbility_105641, BlockAccumulatedTimes) == 0x002C78, "Member 'UAbility_105641::BlockAccumulatedTimes' has a wrong offset!");

// Class Hero_1056.Ability_105651
// 0x0000 (0x29F0 - 0x29F0)
class UAbility_105651 final : public UMarvelGameplayAbility
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_105651">();
	}
	static class UAbility_105651* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_105651>();
	}
};
static_assert(alignof(UAbility_105651) == 0x000008, "Wrong alignment on UAbility_105651");
static_assert(sizeof(UAbility_105651) == 0x0029F0, "Wrong size on UAbility_105651");

// Class Hero_1056.BuffAbility_10565105
// 0x0050 (0x13C0 - 0x1370)
class UBuffAbility_10565105 : public UMarvelEffectGameplayAbility
{
public:
	TArray<int32>                                 SourceAbilityIDs;                                  // 0x1370(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         NearbyTraceScopeID;                                // 0x1380(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageToShield;                                    // 0x1384(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageToShield_Teammate;                           // 0x1388(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ShieldBuffID;                                      // 0x138C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ShieldBuffID_Teammate;                             // 0x1390(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1394[0x4];                                     // 0x1394(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 OwnerActor;                                        // 0x1398(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMarvelBaseAbilitySystemComponent*      OwnerASC;                                          // 0x13A0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         LastTraceFrame;                                    // 0x13A8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_13AC[0x4];                                     // 0x13AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FHitResult>                     CacheHitResults;                                   // 0x13B0(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	void OnOwnerApplyDamage(class AActor* Source, class AActor* InTarget, const struct FAttributeModifierHandle& ModifierParameterHandle);
	void OnTraceSth(class UObject* TraceSource, const TArray<struct FHitResult>& HitResults);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuffAbility_10565105">();
	}
	static class UBuffAbility_10565105* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBuffAbility_10565105>();
	}
};
static_assert(alignof(UBuffAbility_10565105) == 0x000008, "Wrong alignment on UBuffAbility_10565105");
static_assert(sizeof(UBuffAbility_10565105) == 0x0013C0, "Wrong size on UBuffAbility_10565105");
static_assert(offsetof(UBuffAbility_10565105, SourceAbilityIDs) == 0x001370, "Member 'UBuffAbility_10565105::SourceAbilityIDs' has a wrong offset!");
static_assert(offsetof(UBuffAbility_10565105, NearbyTraceScopeID) == 0x001380, "Member 'UBuffAbility_10565105::NearbyTraceScopeID' has a wrong offset!");
static_assert(offsetof(UBuffAbility_10565105, DamageToShield) == 0x001384, "Member 'UBuffAbility_10565105::DamageToShield' has a wrong offset!");
static_assert(offsetof(UBuffAbility_10565105, DamageToShield_Teammate) == 0x001388, "Member 'UBuffAbility_10565105::DamageToShield_Teammate' has a wrong offset!");
static_assert(offsetof(UBuffAbility_10565105, ShieldBuffID) == 0x00138C, "Member 'UBuffAbility_10565105::ShieldBuffID' has a wrong offset!");
static_assert(offsetof(UBuffAbility_10565105, ShieldBuffID_Teammate) == 0x001390, "Member 'UBuffAbility_10565105::ShieldBuffID_Teammate' has a wrong offset!");
static_assert(offsetof(UBuffAbility_10565105, OwnerActor) == 0x001398, "Member 'UBuffAbility_10565105::OwnerActor' has a wrong offset!");
static_assert(offsetof(UBuffAbility_10565105, OwnerASC) == 0x0013A0, "Member 'UBuffAbility_10565105::OwnerASC' has a wrong offset!");
static_assert(offsetof(UBuffAbility_10565105, LastTraceFrame) == 0x0013A8, "Member 'UBuffAbility_10565105::LastTraceFrame' has a wrong offset!");
static_assert(offsetof(UBuffAbility_10565105, CacheHitResults) == 0x0013B0, "Member 'UBuffAbility_10565105::CacheHitResults' has a wrong offset!");

// Class Hero_1056.Ability_105661
// 0x0000 (0x29F8 - 0x29F8)
class UAbility_105661 : public UAbility_108
{
public:
	void OnSummonedBegin();
	void OnSummonedEnd();
	void TryEndAbilityOnProjectileEnd();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_105661">();
	}
	static class UAbility_105661* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_105661>();
	}
};
static_assert(alignof(UAbility_105661) == 0x000008, "Wrong alignment on UAbility_105661");
static_assert(sizeof(UAbility_105661) == 0x0029F8, "Wrong size on UAbility_105661");

// Class Hero_1056.Projectile_10566101
// 0x0260 (0x3DF0 - 0x3B90)
class AProjectile_10566101 : public AMarvelAbilityTargetActor_Projectile
{
public:
	struct FHitResult                             ProjHitRes;                                        // 0x3B88(0x01F0)(ContainsInstancedReference, NativeAccessSpecifierPublic)
	int32                                         SummonedID;                                        // 0x3D78(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D7C[0x4];                                     // 0x3D7C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  HitActorIgnoreTags;                                // 0x3D80(0x0068)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          HasSpawnSummoned;                                  // 0x3DE8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3DE9[0x7];                                     // 0x3DE9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Projectile_10566101">();
	}
	static class AProjectile_10566101* GetDefaultObj()
	{
		return GetDefaultObjImpl<AProjectile_10566101>();
	}
};
static_assert(alignof(AProjectile_10566101) == 0x000010, "Wrong alignment on AProjectile_10566101");
static_assert(sizeof(AProjectile_10566101) == 0x003DF0, "Wrong size on AProjectile_10566101");
static_assert(offsetof(AProjectile_10566101, ProjHitRes) == 0x003B88, "Member 'AProjectile_10566101::ProjHitRes' has a wrong offset!");
static_assert(offsetof(AProjectile_10566101, SummonedID) == 0x003D78, "Member 'AProjectile_10566101::SummonedID' has a wrong offset!");
static_assert(offsetof(AProjectile_10566101, HitActorIgnoreTags) == 0x003D80, "Member 'AProjectile_10566101::HitActorIgnoreTags' has a wrong offset!");
static_assert(offsetof(AProjectile_10566101, HasSpawnSummoned) == 0x003DE8, "Member 'AProjectile_10566101::HasSpawnSummoned' has a wrong offset!");

// Class Hero_1056.Summoned_10566101
// 0x0050 (0x0B90 - 0x0B40)
class ASummoned_10566101 : public AMarvelSummonerBase
{
public:
	class UCapsuleComponent*                      MainCollisionCapsule;                              // 0x0B40(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPlayerPenetrationCheckComponent*       PenetrationCheckComponent;                         // 0x0B48(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DelayCheckTargetToEndSelf;                         // 0x0B50(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B54[0x4];                                      // 0x0B54(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTargetInfo_105661>             TargetRecorder;                                    // 0x0B58(0x0010)(BlueprintVisible, Net, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         CurrentTargets;                                    // 0x0B68(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FTimerHandle                           DelayCheckStateHandle;                             // 0x0B78(0x0018)(Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void CheckTargetState();
	bool DoesActorIsMyTarget(class AActor* InTarget);
	struct FVector GetReferLocation();
	void SetCheckTimer(bool bSet);
	void UpdateTargetState(class AActor* InTarget, bool bAdd, EEndReason_105661 LinkEndReason);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Summoned_10566101">();
	}
	static class ASummoned_10566101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASummoned_10566101>();
	}
};
static_assert(alignof(ASummoned_10566101) == 0x000010, "Wrong alignment on ASummoned_10566101");
static_assert(sizeof(ASummoned_10566101) == 0x000B90, "Wrong size on ASummoned_10566101");
static_assert(offsetof(ASummoned_10566101, MainCollisionCapsule) == 0x000B40, "Member 'ASummoned_10566101::MainCollisionCapsule' has a wrong offset!");
static_assert(offsetof(ASummoned_10566101, PenetrationCheckComponent) == 0x000B48, "Member 'ASummoned_10566101::PenetrationCheckComponent' has a wrong offset!");
static_assert(offsetof(ASummoned_10566101, DelayCheckTargetToEndSelf) == 0x000B50, "Member 'ASummoned_10566101::DelayCheckTargetToEndSelf' has a wrong offset!");
static_assert(offsetof(ASummoned_10566101, TargetRecorder) == 0x000B58, "Member 'ASummoned_10566101::TargetRecorder' has a wrong offset!");
static_assert(offsetof(ASummoned_10566101, CurrentTargets) == 0x000B68, "Member 'ASummoned_10566101::CurrentTargets' has a wrong offset!");
static_assert(offsetof(ASummoned_10566101, DelayCheckStateHandle) == 0x000B78, "Member 'ASummoned_10566101::DelayCheckStateHandle' has a wrong offset!");

// Class Hero_1056.BuffAbility_10566102
// 0x1820 (0x2B90 - 0x1370)
class UBuffAbility_10566102 : public UMarvelEffectGameplayAbility
{
public:
	float                                         TightenDist;                                       // 0x1370(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BrokenDist;                                        // 0x1374(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MarkBuff;                                          // 0x1378(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SlowDownBuff;                                      // 0x137C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ForbidMoveBuff;                                    // 0x1380(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DragKnockBuff;                                     // 0x1384(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 ExtraRemoveBuffList;                               // 0x1388(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  MoveStates;                                        // 0x1398(0x0068)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  IgnoreDragBackTags;                                // 0x1400(0x0068)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  CancelEffectTags;                                  // 0x1468(0x0068)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bNeedLinkTrace;                                    // 0x14D0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14D1[0xF];                                     // 0x14D1(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMarvelAbilityTraceContext             LinkTraceContext;                                  // 0x14E0(0x1660)(Edit, BlueprintVisible, ContainsInstancedReference, NativeAccessSpecifierPublic)
	EEndReason_105661                             LinkEndReason;                                     // 0x2B40(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B41[0x7];                                     // 0x2B41(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 AbilityOwner;                                      // 0x2B48(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AMarvelBaseCharacter*                   InstigatorChar;                                    // 0x2B50(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ASummoned_10566101*                     SourceSummoned;                                    // 0x2B58(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMarvelSummonedComponent*               SummonedComp;                                      // 0x2B60(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAbilitySystemComponent*                OwnerASC;                                          // 0x2B68(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B70[0x20];                                    // 0x2B70(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CustomHandleBuff(int32 BuffID, bool bApply);
	void OnEffectTagUpdate(const struct FGameplayTag& TagUpdated, bool TagExists);
	void OnSourceSummonedEnd(class AActor* InActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuffAbility_10566102">();
	}
	static class UBuffAbility_10566102* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBuffAbility_10566102>();
	}
};
static_assert(alignof(UBuffAbility_10566102) == 0x000010, "Wrong alignment on UBuffAbility_10566102");
static_assert(sizeof(UBuffAbility_10566102) == 0x002B90, "Wrong size on UBuffAbility_10566102");
static_assert(offsetof(UBuffAbility_10566102, TightenDist) == 0x001370, "Member 'UBuffAbility_10566102::TightenDist' has a wrong offset!");
static_assert(offsetof(UBuffAbility_10566102, BrokenDist) == 0x001374, "Member 'UBuffAbility_10566102::BrokenDist' has a wrong offset!");
static_assert(offsetof(UBuffAbility_10566102, MarkBuff) == 0x001378, "Member 'UBuffAbility_10566102::MarkBuff' has a wrong offset!");
static_assert(offsetof(UBuffAbility_10566102, SlowDownBuff) == 0x00137C, "Member 'UBuffAbility_10566102::SlowDownBuff' has a wrong offset!");
static_assert(offsetof(UBuffAbility_10566102, ForbidMoveBuff) == 0x001380, "Member 'UBuffAbility_10566102::ForbidMoveBuff' has a wrong offset!");
static_assert(offsetof(UBuffAbility_10566102, DragKnockBuff) == 0x001384, "Member 'UBuffAbility_10566102::DragKnockBuff' has a wrong offset!");
static_assert(offsetof(UBuffAbility_10566102, ExtraRemoveBuffList) == 0x001388, "Member 'UBuffAbility_10566102::ExtraRemoveBuffList' has a wrong offset!");
static_assert(offsetof(UBuffAbility_10566102, MoveStates) == 0x001398, "Member 'UBuffAbility_10566102::MoveStates' has a wrong offset!");
static_assert(offsetof(UBuffAbility_10566102, IgnoreDragBackTags) == 0x001400, "Member 'UBuffAbility_10566102::IgnoreDragBackTags' has a wrong offset!");
static_assert(offsetof(UBuffAbility_10566102, CancelEffectTags) == 0x001468, "Member 'UBuffAbility_10566102::CancelEffectTags' has a wrong offset!");
static_assert(offsetof(UBuffAbility_10566102, bNeedLinkTrace) == 0x0014D0, "Member 'UBuffAbility_10566102::bNeedLinkTrace' has a wrong offset!");
static_assert(offsetof(UBuffAbility_10566102, LinkTraceContext) == 0x0014E0, "Member 'UBuffAbility_10566102::LinkTraceContext' has a wrong offset!");
static_assert(offsetof(UBuffAbility_10566102, LinkEndReason) == 0x002B40, "Member 'UBuffAbility_10566102::LinkEndReason' has a wrong offset!");
static_assert(offsetof(UBuffAbility_10566102, AbilityOwner) == 0x002B48, "Member 'UBuffAbility_10566102::AbilityOwner' has a wrong offset!");
static_assert(offsetof(UBuffAbility_10566102, InstigatorChar) == 0x002B50, "Member 'UBuffAbility_10566102::InstigatorChar' has a wrong offset!");
static_assert(offsetof(UBuffAbility_10566102, SourceSummoned) == 0x002B58, "Member 'UBuffAbility_10566102::SourceSummoned' has a wrong offset!");
static_assert(offsetof(UBuffAbility_10566102, SummonedComp) == 0x002B60, "Member 'UBuffAbility_10566102::SummonedComp' has a wrong offset!");
static_assert(offsetof(UBuffAbility_10566102, OwnerASC) == 0x002B68, "Member 'UBuffAbility_10566102::OwnerASC' has a wrong offset!");

// Class Hero_1056.AnimNotifyState_UpdateAttachedMeshMaterial
// 0x00D0 (0x0108 - 0x0038)
class UAnimNotifyState_UpdateAttachedMeshMaterial : public UAnimNotifyState
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   TargetComponentTag;                                // 0x0040(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, struct FMeshMaterialUpdateInfo> MaterialParams;                                // 0x0050(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         ReplaceTime;                                       // 0x00A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableWhenSwitchingBetweenGlidingAndDashing;     // 0x00A4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFadeInLerp;                                       // 0x00A5(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A6[0x2];                                       // 0x00A6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   FadeInParam;                                       // 0x00A8(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B4[0x54];                                      // 0x00B4(0x0054)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_UpdateAttachedMeshMaterial">();
	}
	static class UAnimNotifyState_UpdateAttachedMeshMaterial* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_UpdateAttachedMeshMaterial>();
	}
};
static_assert(alignof(UAnimNotifyState_UpdateAttachedMeshMaterial) == 0x000008, "Wrong alignment on UAnimNotifyState_UpdateAttachedMeshMaterial");
static_assert(sizeof(UAnimNotifyState_UpdateAttachedMeshMaterial) == 0x000108, "Wrong size on UAnimNotifyState_UpdateAttachedMeshMaterial");
static_assert(offsetof(UAnimNotifyState_UpdateAttachedMeshMaterial, TargetComponentTag) == 0x000040, "Member 'UAnimNotifyState_UpdateAttachedMeshMaterial::TargetComponentTag' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_UpdateAttachedMeshMaterial, MaterialParams) == 0x000050, "Member 'UAnimNotifyState_UpdateAttachedMeshMaterial::MaterialParams' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_UpdateAttachedMeshMaterial, ReplaceTime) == 0x0000A0, "Member 'UAnimNotifyState_UpdateAttachedMeshMaterial::ReplaceTime' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_UpdateAttachedMeshMaterial, bDisableWhenSwitchingBetweenGlidingAndDashing) == 0x0000A4, "Member 'UAnimNotifyState_UpdateAttachedMeshMaterial::bDisableWhenSwitchingBetweenGlidingAndDashing' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_UpdateAttachedMeshMaterial, bFadeInLerp) == 0x0000A5, "Member 'UAnimNotifyState_UpdateAttachedMeshMaterial::bFadeInLerp' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_UpdateAttachedMeshMaterial, FadeInParam) == 0x0000A8, "Member 'UAnimNotifyState_UpdateAttachedMeshMaterial::FadeInParam' has a wrong offset!");

// Class Hero_1056.AnimNotifyState_UpdateAttachedMeshMaterial_Angela
// 0x0008 (0x0110 - 0x0108)
class UAnimNotifyState_UpdateAttachedMeshMaterial_Angela final : public UAnimNotifyState_UpdateAttachedMeshMaterial
{
public:
	EAngelaWeaponType                             TargetWeaponType;                                  // 0x0108(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_109[0x7];                                      // 0x0109(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_UpdateAttachedMeshMaterial_Angela">();
	}
	static class UAnimNotifyState_UpdateAttachedMeshMaterial_Angela* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_UpdateAttachedMeshMaterial_Angela>();
	}
};
static_assert(alignof(UAnimNotifyState_UpdateAttachedMeshMaterial_Angela) == 0x000008, "Wrong alignment on UAnimNotifyState_UpdateAttachedMeshMaterial_Angela");
static_assert(sizeof(UAnimNotifyState_UpdateAttachedMeshMaterial_Angela) == 0x000110, "Wrong size on UAnimNotifyState_UpdateAttachedMeshMaterial_Angela");
static_assert(offsetof(UAnimNotifyState_UpdateAttachedMeshMaterial_Angela, TargetWeaponType) == 0x000108, "Member 'UAnimNotifyState_UpdateAttachedMeshMaterial_Angela::TargetWeaponType' has a wrong offset!");

// Class Hero_1056.Cue_Buff_10566102
// 0x0020 (0x1660 - 0x1640)
class ACue_Buff_10566102 : public AMarvelCueNotify_Buff
{
public:
	class UNiagaraComponent*                      ChainFX;                                           // 0x1638(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ChainFXEndSocket;                                  // 0x1640(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ChainFXEndParam;                                   // 0x164C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ACharacter*                             TargetCharacter;                                   // 0x1658(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Buff_10566102">();
	}
	static class ACue_Buff_10566102* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Buff_10566102>();
	}
};
static_assert(alignof(ACue_Buff_10566102) == 0x000010, "Wrong alignment on ACue_Buff_10566102");
static_assert(sizeof(ACue_Buff_10566102) == 0x001660, "Wrong size on ACue_Buff_10566102");
static_assert(offsetof(ACue_Buff_10566102, ChainFX) == 0x001638, "Member 'ACue_Buff_10566102::ChainFX' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10566102, ChainFXEndSocket) == 0x001640, "Member 'ACue_Buff_10566102::ChainFXEndSocket' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10566102, ChainFXEndParam) == 0x00164C, "Member 'ACue_Buff_10566102::ChainFXEndParam' has a wrong offset!");
static_assert(offsetof(ACue_Buff_10566102, TargetCharacter) == 0x001658, "Member 'ACue_Buff_10566102::TargetCharacter' has a wrong offset!");

// Class Hero_1056.Config_105662
// 0x0BE0 (0x2460 - 0x1880)
class UConfig_105662 : public USelectAbilityConfigBase
{
public:
	class UCurveFloat*                            DashHeightCurve;                                   // 0x1878(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDashAbilityInfo                       DashInfo;                                          // 0x1880(0x0BC8)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTag                           TargetActorUsedStatusTag;                          // 0x2448(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2454[0xC];                                     // 0x2454(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_105662">();
	}
	static class UConfig_105662* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_105662>();
	}
};
static_assert(alignof(UConfig_105662) == 0x000010, "Wrong alignment on UConfig_105662");
static_assert(sizeof(UConfig_105662) == 0x002460, "Wrong size on UConfig_105662");
static_assert(offsetof(UConfig_105662, DashHeightCurve) == 0x001878, "Member 'UConfig_105662::DashHeightCurve' has a wrong offset!");
static_assert(offsetof(UConfig_105662, DashInfo) == 0x001880, "Member 'UConfig_105662::DashInfo' has a wrong offset!");
static_assert(offsetof(UConfig_105662, TargetActorUsedStatusTag) == 0x002448, "Member 'UConfig_105662::TargetActorUsedStatusTag' has a wrong offset!");

// Class Hero_1056.Ability_105662
// 0x0088 (0x2AF0 - 0x2A68)
class UAbility_105662 : public UMarvelAbility_SelectTarget
{
public:
	struct FVector                                SelectRawLocation;                                 // 0x2A68(0x0018)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                SelectLocation;                                    // 0x2A80(0x0018)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 SelectResult_Target;                               // 0x2A98(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FPortalSegments                        PortalSegments;                                    // 0x2AA0(0x0050)(BlueprintVisible, Transient, Protected, NativeAccessSpecifierProtected)

public:
	class UMarvelAbilityTask_Dash* ApplyDash();
	void OnDashFinish(EDashStopReason Reason);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_105662">();
	}
	static class UAbility_105662* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_105662>();
	}
};
static_assert(alignof(UAbility_105662) == 0x000008, "Wrong alignment on UAbility_105662");
static_assert(sizeof(UAbility_105662) == 0x002AF0, "Wrong size on UAbility_105662");
static_assert(offsetof(UAbility_105662, SelectRawLocation) == 0x002A68, "Member 'UAbility_105662::SelectRawLocation' has a wrong offset!");
static_assert(offsetof(UAbility_105662, SelectLocation) == 0x002A80, "Member 'UAbility_105662::SelectLocation' has a wrong offset!");
static_assert(offsetof(UAbility_105662, SelectResult_Target) == 0x002A98, "Member 'UAbility_105662::SelectResult_Target' has a wrong offset!");
static_assert(offsetof(UAbility_105662, PortalSegments) == 0x002AA0, "Member 'UAbility_105662::PortalSegments' has a wrong offset!");

// Class Hero_1056.AngelaAnimInstance
// 0x00E0 (0x0B00 - 0x0A20)
class UAngelaAnimInstance : public UMarvelAnimInstance
{
public:
	struct FAngelaGlidingAnimConfig               GlidingAnimConfig;                                 // 0x0A20(0x0020)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FAngelaGlidingAnimConfig               DashingAnimConfig;                                 // 0x0A40(0x0020)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         MinGlidePitchWhenMouseLeftActived;                 // 0x0A60(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsFlying;                                         // 0x0A64(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsGliding;                                        // 0x0A65(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsGlideLoopToEnd;                                 // 0x0A66(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsGlideLoopToStart;                               // 0x0A67(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bNeedSkipGlidingStart;                             // 0x0A68(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A69[0x3];                                      // 0x0A69(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CameraPitch;                                       // 0x0A6C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CameraYaw;                                         // 0x0A70(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A74[0x4];                                      // 0x0A74(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              GlidingLoopVector;                                 // 0x0A78(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsDashing;                                        // 0x0A88(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A89[0x3];                                      // 0x0A89(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         HitAnimIndex;                                      // 0x0A8C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAeroMotion_To_GlideStart;                         // 0x0A90(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAeroMotion_To_GlideLoop;                          // 0x0A91(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bGlideEnd_To_GlideStart;                           // 0x0A92(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A93[0x5];                                      // 0x0A93(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class AAngelaCharacter*                       AngelaCharacter;                                   // 0x0A98(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_AA0[0x60];                                     // 0x0AA0(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnGlideLoopBecomeRelevant(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AngelaAnimInstance">();
	}
	static class UAngelaAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAngelaAnimInstance>();
	}
};
static_assert(alignof(UAngelaAnimInstance) == 0x000010, "Wrong alignment on UAngelaAnimInstance");
static_assert(sizeof(UAngelaAnimInstance) == 0x000B00, "Wrong size on UAngelaAnimInstance");
static_assert(offsetof(UAngelaAnimInstance, GlidingAnimConfig) == 0x000A20, "Member 'UAngelaAnimInstance::GlidingAnimConfig' has a wrong offset!");
static_assert(offsetof(UAngelaAnimInstance, DashingAnimConfig) == 0x000A40, "Member 'UAngelaAnimInstance::DashingAnimConfig' has a wrong offset!");
static_assert(offsetof(UAngelaAnimInstance, MinGlidePitchWhenMouseLeftActived) == 0x000A60, "Member 'UAngelaAnimInstance::MinGlidePitchWhenMouseLeftActived' has a wrong offset!");
static_assert(offsetof(UAngelaAnimInstance, bIsFlying) == 0x000A64, "Member 'UAngelaAnimInstance::bIsFlying' has a wrong offset!");
static_assert(offsetof(UAngelaAnimInstance, bIsGliding) == 0x000A65, "Member 'UAngelaAnimInstance::bIsGliding' has a wrong offset!");
static_assert(offsetof(UAngelaAnimInstance, bIsGlideLoopToEnd) == 0x000A66, "Member 'UAngelaAnimInstance::bIsGlideLoopToEnd' has a wrong offset!");
static_assert(offsetof(UAngelaAnimInstance, bIsGlideLoopToStart) == 0x000A67, "Member 'UAngelaAnimInstance::bIsGlideLoopToStart' has a wrong offset!");
static_assert(offsetof(UAngelaAnimInstance, bNeedSkipGlidingStart) == 0x000A68, "Member 'UAngelaAnimInstance::bNeedSkipGlidingStart' has a wrong offset!");
static_assert(offsetof(UAngelaAnimInstance, CameraPitch) == 0x000A6C, "Member 'UAngelaAnimInstance::CameraPitch' has a wrong offset!");
static_assert(offsetof(UAngelaAnimInstance, CameraYaw) == 0x000A70, "Member 'UAngelaAnimInstance::CameraYaw' has a wrong offset!");
static_assert(offsetof(UAngelaAnimInstance, GlidingLoopVector) == 0x000A78, "Member 'UAngelaAnimInstance::GlidingLoopVector' has a wrong offset!");
static_assert(offsetof(UAngelaAnimInstance, bIsDashing) == 0x000A88, "Member 'UAngelaAnimInstance::bIsDashing' has a wrong offset!");
static_assert(offsetof(UAngelaAnimInstance, HitAnimIndex) == 0x000A8C, "Member 'UAngelaAnimInstance::HitAnimIndex' has a wrong offset!");
static_assert(offsetof(UAngelaAnimInstance, bAeroMotion_To_GlideStart) == 0x000A90, "Member 'UAngelaAnimInstance::bAeroMotion_To_GlideStart' has a wrong offset!");
static_assert(offsetof(UAngelaAnimInstance, bAeroMotion_To_GlideLoop) == 0x000A91, "Member 'UAngelaAnimInstance::bAeroMotion_To_GlideLoop' has a wrong offset!");
static_assert(offsetof(UAngelaAnimInstance, bGlideEnd_To_GlideStart) == 0x000A92, "Member 'UAngelaAnimInstance::bGlideEnd_To_GlideStart' has a wrong offset!");
static_assert(offsetof(UAngelaAnimInstance, AngelaCharacter) == 0x000A98, "Member 'UAngelaAnimInstance::AngelaCharacter' has a wrong offset!");

// Class Hero_1056.AngelaWingAnimInstance
// 0x0000 (0x0B00 - 0x0B00)
class UAngelaWingAnimInstance final : public UAngelaAnimInstance
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AngelaWingAnimInstance">();
	}
	static class UAngelaWingAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAngelaWingAnimInstance>();
	}
};
static_assert(alignof(UAngelaWingAnimInstance) == 0x000010, "Wrong alignment on UAngelaWingAnimInstance");
static_assert(sizeof(UAngelaWingAnimInstance) == 0x000B00, "Wrong size on UAngelaWingAnimInstance");

// Class Hero_1056.AngelaChildActor
// 0x0060 (0x0E80 - 0x0E20)
class AAngelaChildActor : public AMarvelCharacterChildActor
{
public:
	uint8                                         Pad_E18[0x50];                                     // 0x0E18(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaterialParamsLerpSpeed;                           // 0x0E68(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           Tag_TriggerLandingInMT;                            // 0x0E6C(0x000C)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E78[0x8];                                      // 0x0E78(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearMaterialParamFromUpdate();
	void UpdateMaterialParams(const float DeltaTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AngelaChildActor">();
	}
	static class AAngelaChildActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAngelaChildActor>();
	}
};
static_assert(alignof(AAngelaChildActor) == 0x000010, "Wrong alignment on AAngelaChildActor");
static_assert(sizeof(AAngelaChildActor) == 0x000E80, "Wrong size on AAngelaChildActor");
static_assert(offsetof(AAngelaChildActor, MaterialParamsLerpSpeed) == 0x000E68, "Member 'AAngelaChildActor::MaterialParamsLerpSpeed' has a wrong offset!");
static_assert(offsetof(AAngelaChildActor, Tag_TriggerLandingInMT) == 0x000E6C, "Member 'AAngelaChildActor::Tag_TriggerLandingInMT' has a wrong offset!");

// Class Hero_1056.AngelaCharacter
// 0x0170 (0x2310 - 0x21A0)
class AAngelaCharacter : public AMarvelBaseCharacter
{
public:
	struct FGameplayTagContainer                  AirStatusTags;                                     // 0x21A0(0x0068)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AirStatusTag;                                      // 0x2208(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           GroundStatusTag;                                   // 0x2214(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCameraInterp*                          CameraInterp_GroundStatus;                         // 0x2220(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDefaultAirStatus;                                 // 0x2228(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bClientPredictStatus;                              // 0x2229(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_222A[0x6];                                     // 0x222A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 EnergyStages;                                      // 0x2230(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         BreakWingVelocity;                                 // 0x2240(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2244[0x4];                                     // 0x2244(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EAmmoClipType>                         ListenEnergyChangeTypes;                           // 0x2248(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FGameplayAttribute& Attr, float OldValue, float NewValue)> OnAgelaEnergyAttrChanged; // 0x2258(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	class UAngelaMoveLogicBaseComponent*          AngelaMoveLogic;                                   // 0x2268(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAngelaGlidingStage                           CurrentGlidingStage;                               // 0x2270(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2271[0x37];                                    // 0x2271(0x0037)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAngelaMeshInterpInfo                  MeshInterpInfo;                                    // 0x22A8(0x0028)(Net, Transient, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_22D0[0x38];                                    // 0x22D0(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsSwitchingBetweenGlidingAndDashing;              // 0x2308(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2309[0x7];                                     // 0x2309(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	EAngelaEnergyLevel GetEnergyLevel(EAmmoClipType InEnergyType, bool bContainsFull);
	float GetEnergyPercent(EAmmoClipType InEnergyType);
	int32 GetEnergyStage(EAmmoClipType InEnergyType);
	bool GetInBreakWindStatus();
	void OnRep_CurrentGlidingStage();
	void OnRep_MeshInterpInfo();
	void RestoreMeshOffsetImmediately();
	void SetAirStatus(bool bToAir);
	void SetGlidingStage(EAngelaGlidingStage InGlidingStage);
	void SetIsDashing(bool InIsDashing);
	void SetIsGliding(bool InIsGliding);
	void SetIsMeshOffsetChanged(bool InIsMeshOffsetChanged, const struct FVector& InMeshAdditionalOffset, float InterpSpeed);

	bool GetInAirStatus() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AngelaCharacter">();
	}
	static class AAngelaCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAngelaCharacter>();
	}
};
static_assert(alignof(AAngelaCharacter) == 0x000010, "Wrong alignment on AAngelaCharacter");
static_assert(sizeof(AAngelaCharacter) == 0x002310, "Wrong size on AAngelaCharacter");
static_assert(offsetof(AAngelaCharacter, AirStatusTags) == 0x0021A0, "Member 'AAngelaCharacter::AirStatusTags' has a wrong offset!");
static_assert(offsetof(AAngelaCharacter, AirStatusTag) == 0x002208, "Member 'AAngelaCharacter::AirStatusTag' has a wrong offset!");
static_assert(offsetof(AAngelaCharacter, GroundStatusTag) == 0x002214, "Member 'AAngelaCharacter::GroundStatusTag' has a wrong offset!");
static_assert(offsetof(AAngelaCharacter, CameraInterp_GroundStatus) == 0x002220, "Member 'AAngelaCharacter::CameraInterp_GroundStatus' has a wrong offset!");
static_assert(offsetof(AAngelaCharacter, bDefaultAirStatus) == 0x002228, "Member 'AAngelaCharacter::bDefaultAirStatus' has a wrong offset!");
static_assert(offsetof(AAngelaCharacter, bClientPredictStatus) == 0x002229, "Member 'AAngelaCharacter::bClientPredictStatus' has a wrong offset!");
static_assert(offsetof(AAngelaCharacter, EnergyStages) == 0x002230, "Member 'AAngelaCharacter::EnergyStages' has a wrong offset!");
static_assert(offsetof(AAngelaCharacter, BreakWingVelocity) == 0x002240, "Member 'AAngelaCharacter::BreakWingVelocity' has a wrong offset!");
static_assert(offsetof(AAngelaCharacter, ListenEnergyChangeTypes) == 0x002248, "Member 'AAngelaCharacter::ListenEnergyChangeTypes' has a wrong offset!");
static_assert(offsetof(AAngelaCharacter, OnAgelaEnergyAttrChanged) == 0x002258, "Member 'AAngelaCharacter::OnAgelaEnergyAttrChanged' has a wrong offset!");
static_assert(offsetof(AAngelaCharacter, AngelaMoveLogic) == 0x002268, "Member 'AAngelaCharacter::AngelaMoveLogic' has a wrong offset!");
static_assert(offsetof(AAngelaCharacter, CurrentGlidingStage) == 0x002270, "Member 'AAngelaCharacter::CurrentGlidingStage' has a wrong offset!");
static_assert(offsetof(AAngelaCharacter, MeshInterpInfo) == 0x0022A8, "Member 'AAngelaCharacter::MeshInterpInfo' has a wrong offset!");
static_assert(offsetof(AAngelaCharacter, bIsSwitchingBetweenGlidingAndDashing) == 0x002308, "Member 'AAngelaCharacter::bIsSwitchingBetweenGlidingAndDashing' has a wrong offset!");

// Class Hero_1056.AngelaSpringArmComponent
// 0x0140 (0x1200 - 0x10C0)
class UAngelaSpringArmComponent final : public UMarvelComposerSpringArmComponent
{
public:
	uint8                                         Pad_10C0[0x28];                                    // 0x10C0(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAngelaSpringArmConfig                 GlidingSpringArmConfig;                            // 0x10E8(0x0070)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FAngelaSpringArmConfig                 DashingSpringArmConfig;                            // 0x1158(0x0070)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_11C8[0x38];                                    // 0x11C8(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AngelaSpringArmComponent">();
	}
	static class UAngelaSpringArmComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAngelaSpringArmComponent>();
	}
};
static_assert(alignof(UAngelaSpringArmComponent) == 0x000010, "Wrong alignment on UAngelaSpringArmComponent");
static_assert(sizeof(UAngelaSpringArmComponent) == 0x001200, "Wrong size on UAngelaSpringArmComponent");
static_assert(offsetof(UAngelaSpringArmComponent, GlidingSpringArmConfig) == 0x0010E8, "Member 'UAngelaSpringArmComponent::GlidingSpringArmConfig' has a wrong offset!");
static_assert(offsetof(UAngelaSpringArmComponent, DashingSpringArmConfig) == 0x001158, "Member 'UAngelaSpringArmComponent::DashingSpringArmConfig' has a wrong offset!");

// Class Hero_1056.AnimNotifyState_TimedFXWithAO_1056
// 0x0020 (0x03B0 - 0x0390)
class UAnimNotifyState_TimedFXWithAO_1056 final : public UAnimNotifyState_TimedFXWithAO
{
public:
	uint8                                         Pad_390[0x8];                                      // 0x0390(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	EAmmoClipType                                 EnergyType;                                        // 0x0398(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_399[0x3];                                      // 0x0399(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   FXParamName;                                       // 0x039C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A8[0x8];                                      // 0x03A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_TimedFXWithAO_1056">();
	}
	static class UAnimNotifyState_TimedFXWithAO_1056* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_TimedFXWithAO_1056>();
	}
};
static_assert(alignof(UAnimNotifyState_TimedFXWithAO_1056) == 0x000010, "Wrong alignment on UAnimNotifyState_TimedFXWithAO_1056");
static_assert(sizeof(UAnimNotifyState_TimedFXWithAO_1056) == 0x0003B0, "Wrong size on UAnimNotifyState_TimedFXWithAO_1056");
static_assert(offsetof(UAnimNotifyState_TimedFXWithAO_1056, EnergyType) == 0x000398, "Member 'UAnimNotifyState_TimedFXWithAO_1056::EnergyType' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_TimedFXWithAO_1056, FXParamName) == 0x00039C, "Member 'UAnimNotifyState_TimedFXWithAO_1056::FXParamName' has a wrong offset!");

// Class Hero_1056.AnimNotifyState_TimedNiagaraEffectEx_1056
// 0x0018 (0x0268 - 0x0250)
class UAnimNotifyState_TimedNiagaraEffectEx_1056 final : public UAnimNotifyState_TimedNiagaraEffectEx
{
public:
	uint8                                         Pad_250[0x8];                                      // 0x0250(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	EAmmoClipType                                 EnergyType;                                        // 0x0258(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_259[0x3];                                      // 0x0259(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   FXParamName;                                       // 0x025C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_TimedNiagaraEffectEx_1056">();
	}
	static class UAnimNotifyState_TimedNiagaraEffectEx_1056* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_TimedNiagaraEffectEx_1056>();
	}
};
static_assert(alignof(UAnimNotifyState_TimedNiagaraEffectEx_1056) == 0x000008, "Wrong alignment on UAnimNotifyState_TimedNiagaraEffectEx_1056");
static_assert(sizeof(UAnimNotifyState_TimedNiagaraEffectEx_1056) == 0x000268, "Wrong size on UAnimNotifyState_TimedNiagaraEffectEx_1056");
static_assert(offsetof(UAnimNotifyState_TimedNiagaraEffectEx_1056, EnergyType) == 0x000258, "Member 'UAnimNotifyState_TimedNiagaraEffectEx_1056::EnergyType' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_TimedNiagaraEffectEx_1056, FXParamName) == 0x00025C, "Member 'UAnimNotifyState_TimedNiagaraEffectEx_1056::FXParamName' has a wrong offset!");

// Class Hero_1056.AnimNotifyState_TimedNiagaraEffectEx_1056_ShowWithCond
// 0x0018 (0x0268 - 0x0250)
class UAnimNotifyState_TimedNiagaraEffectEx_1056_ShowWithCond final : public UAnimNotifyState_TimedNiagaraEffectEx
{
public:
	uint8                                         Pad_250[0x8];                                      // 0x0250(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bShowInBreakWind;                                  // 0x0258(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_259[0x7];                                      // 0x0259(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraComponent*                      HoldNSComp;                                        // 0x0260(0x0008)(ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_TimedNiagaraEffectEx_1056_ShowWithCond">();
	}
	static class UAnimNotifyState_TimedNiagaraEffectEx_1056_ShowWithCond* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_TimedNiagaraEffectEx_1056_ShowWithCond>();
	}
};
static_assert(alignof(UAnimNotifyState_TimedNiagaraEffectEx_1056_ShowWithCond) == 0x000008, "Wrong alignment on UAnimNotifyState_TimedNiagaraEffectEx_1056_ShowWithCond");
static_assert(sizeof(UAnimNotifyState_TimedNiagaraEffectEx_1056_ShowWithCond) == 0x000268, "Wrong size on UAnimNotifyState_TimedNiagaraEffectEx_1056_ShowWithCond");
static_assert(offsetof(UAnimNotifyState_TimedNiagaraEffectEx_1056_ShowWithCond, bShowInBreakWind) == 0x000258, "Member 'UAnimNotifyState_TimedNiagaraEffectEx_1056_ShowWithCond::bShowInBreakWind' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_TimedNiagaraEffectEx_1056_ShowWithCond, HoldNSComp) == 0x000260, "Member 'UAnimNotifyState_TimedNiagaraEffectEx_1056_ShowWithCond::HoldNSComp' has a wrong offset!");

// Class Hero_1056.AnimNotify_PlayNiagaraEffectEx_SpecialMesh_Angela
// 0x0010 (0x0390 - 0x0380)
class UAnimNotify_PlayNiagaraEffectEx_SpecialMesh_Angela final : public UAnimNotify_PlayNiagaraEffectEx_SpecialMesh
{
public:
	bool                                          bDisableWhenSwitchingBetweenGlidingAndDashing;     // 0x0380(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_381[0xF];                                      // 0x0381(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_PlayNiagaraEffectEx_SpecialMesh_Angela">();
	}
	static class UAnimNotify_PlayNiagaraEffectEx_SpecialMesh_Angela* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_PlayNiagaraEffectEx_SpecialMesh_Angela>();
	}
};
static_assert(alignof(UAnimNotify_PlayNiagaraEffectEx_SpecialMesh_Angela) == 0x000010, "Wrong alignment on UAnimNotify_PlayNiagaraEffectEx_SpecialMesh_Angela");
static_assert(sizeof(UAnimNotify_PlayNiagaraEffectEx_SpecialMesh_Angela) == 0x000390, "Wrong size on UAnimNotify_PlayNiagaraEffectEx_SpecialMesh_Angela");
static_assert(offsetof(UAnimNotify_PlayNiagaraEffectEx_SpecialMesh_Angela, bDisableWhenSwitchingBetweenGlidingAndDashing) == 0x000380, "Member 'UAnimNotify_PlayNiagaraEffectEx_SpecialMesh_Angela::bDisableWhenSwitchingBetweenGlidingAndDashing' has a wrong offset!");

// Class Hero_1056.Cue_Ability_Loop_1056_ModWeaponMaterial
// 0x00D0 (0x1280 - 0x11B0)
class ACue_Ability_Loop_1056_ModWeaponMaterial final : public AMarvelCueNotify_Ability
{
public:
	float                                         CueLifeSpan;                                       // 0x11B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11B4[0x4];                                     // 0x11B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EAngelaWeaponType, struct FWPMaterialMod_1056> MaterialCurveMap;                            // 0x11B8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         DefaultValCurveTime;                               // 0x1208(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChargeTime;                                        // 0x120C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<EAngelaWeaponType, class USkeletalMeshComponent*> WeaponMeshes;                             // 0x1210(0x0050)(ExportObject, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FTimerHandle                           DelayRecycleCueHandle;                             // 0x1260(0x0018)(Transient, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1278[0x8];                                     // 0x1278(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ResetMaterial();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Ability_Loop_1056_ModWeaponMaterial">();
	}
	static class ACue_Ability_Loop_1056_ModWeaponMaterial* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Ability_Loop_1056_ModWeaponMaterial>();
	}
};
static_assert(alignof(ACue_Ability_Loop_1056_ModWeaponMaterial) == 0x000010, "Wrong alignment on ACue_Ability_Loop_1056_ModWeaponMaterial");
static_assert(sizeof(ACue_Ability_Loop_1056_ModWeaponMaterial) == 0x001280, "Wrong size on ACue_Ability_Loop_1056_ModWeaponMaterial");
static_assert(offsetof(ACue_Ability_Loop_1056_ModWeaponMaterial, CueLifeSpan) == 0x0011B0, "Member 'ACue_Ability_Loop_1056_ModWeaponMaterial::CueLifeSpan' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_1056_ModWeaponMaterial, MaterialCurveMap) == 0x0011B8, "Member 'ACue_Ability_Loop_1056_ModWeaponMaterial::MaterialCurveMap' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_1056_ModWeaponMaterial, DefaultValCurveTime) == 0x001208, "Member 'ACue_Ability_Loop_1056_ModWeaponMaterial::DefaultValCurveTime' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_1056_ModWeaponMaterial, ChargeTime) == 0x00120C, "Member 'ACue_Ability_Loop_1056_ModWeaponMaterial::ChargeTime' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_1056_ModWeaponMaterial, WeaponMeshes) == 0x001210, "Member 'ACue_Ability_Loop_1056_ModWeaponMaterial::WeaponMeshes' has a wrong offset!");
static_assert(offsetof(ACue_Ability_Loop_1056_ModWeaponMaterial, DelayRecycleCueHandle) == 0x001260, "Member 'ACue_Ability_Loop_1056_ModWeaponMaterial::DelayRecycleCueHandle' has a wrong offset!");

// Class Hero_1056.AnimNotify_CameraShake_1056
// 0x0050 (0x0098 - 0x0048)
class UAnimNotify_CameraShake_1056 final : public UAnimNotify_CameraShake
{
public:
	TMap<EAngelaEnergyLevel, TSubclassOf<class ULegacyCameraShake>> ShakeClasses;                    // 0x0048(0x0050)(Edit, BlueprintReadOnly, DisableEditOnTemplate, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_CameraShake_1056">();
	}
	static class UAnimNotify_CameraShake_1056* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_CameraShake_1056>();
	}
};
static_assert(alignof(UAnimNotify_CameraShake_1056) == 0x000008, "Wrong alignment on UAnimNotify_CameraShake_1056");
static_assert(sizeof(UAnimNotify_CameraShake_1056) == 0x000098, "Wrong size on UAnimNotify_CameraShake_1056");
static_assert(offsetof(UAnimNotify_CameraShake_1056, ShakeClasses) == 0x000048, "Member 'UAnimNotify_CameraShake_1056::ShakeClasses' has a wrong offset!");

// Class Hero_1056.AngelaMoveLogicBaseComponent
// 0x0000 (0x0400 - 0x0400)
class UAngelaMoveLogicBaseComponent final : public UMarvelMoveLogicBaseComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AngelaMoveLogicBaseComponent">();
	}
	static class UAngelaMoveLogicBaseComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAngelaMoveLogicBaseComponent>();
	}
};
static_assert(alignof(UAngelaMoveLogicBaseComponent) == 0x000008, "Wrong alignment on UAngelaMoveLogicBaseComponent");
static_assert(sizeof(UAngelaMoveLogicBaseComponent) == 0x000400, "Wrong size on UAngelaMoveLogicBaseComponent");

// Class Hero_1056.AngelaMovementComponent
// 0x0010 (0x2370 - 0x2360)
class UAngelaMovementComponent final : public UMarvelCharacterMovementComponent
{
public:
	uint8                                         Pad_2360[0x10];                                    // 0x2360(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AngelaMovementComponent">();
	}
	static class UAngelaMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAngelaMovementComponent>();
	}
};
static_assert(alignof(UAngelaMovementComponent) == 0x000010, "Wrong alignment on UAngelaMovementComponent");
static_assert(sizeof(UAngelaMovementComponent) == 0x002370, "Wrong size on UAngelaMovementComponent");

}

