#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Hero_1058

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "Marvel_structs.hpp"
#include "Marvel_classes.hpp"
#include "Hero_1058_structs.hpp"
#include "GameplayAbilities_structs.hpp"
#include "Engine_structs.hpp"
#include "GameplayTags_structs.hpp"


namespace SDK
{

// Class Hero_1058.Config_105852
// 0x4588 (0x4620 - 0x0098)
class UConfig_105852 final : public UMarvelAbilityConfig
{
public:
	uint8                                         Pad_98[0x8];                                       // 0x0098(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMarvelAbilityTraceContext             InitialHomingTargetTraceContext;                   // 0x00A0(0x1660)(Edit, BlueprintVisible, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FSelectTaskParam                       SelectParam;                                       // 0x1700(0x17C0)(Edit, BlueprintVisible, ContainsInstancedReference, NativeAccessSpecifierPublic)
	int32                                         ProjectileID;                                      // 0x2EC0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2EC4[0x4];                                     // 0x2EC4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Offset;                                            // 0x2EC8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FProjectileBounceInfo                  BounceInfo;                                        // 0x2EE0(0x16E0)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	EBouncePriorityType_105852                    PriorityOne;                                       // 0x45C0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBouncePriorityType_105852                    PriorityTwo;                                       // 0x45C1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBouncePriorityType_105852                    PriorityThree;                                     // 0x45C2(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBouncePriorityType_105852                    PriorityFour;                                      // 0x45C3(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PreHomingBuffID;                                   // 0x45C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSet<int32>                                   AfterHomingBuffInfos;                              // 0x45C8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         Pad_4618[0x8];                                     // 0x4618(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_105852">();
	}
	static class UConfig_105852* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_105852>();
	}
};
static_assert(alignof(UConfig_105852) == 0x000010, "Wrong alignment on UConfig_105852");
static_assert(sizeof(UConfig_105852) == 0x004620, "Wrong size on UConfig_105852");
static_assert(offsetof(UConfig_105852, InitialHomingTargetTraceContext) == 0x0000A0, "Member 'UConfig_105852::InitialHomingTargetTraceContext' has a wrong offset!");
static_assert(offsetof(UConfig_105852, SelectParam) == 0x001700, "Member 'UConfig_105852::SelectParam' has a wrong offset!");
static_assert(offsetof(UConfig_105852, ProjectileID) == 0x002EC0, "Member 'UConfig_105852::ProjectileID' has a wrong offset!");
static_assert(offsetof(UConfig_105852, Offset) == 0x002EC8, "Member 'UConfig_105852::Offset' has a wrong offset!");
static_assert(offsetof(UConfig_105852, BounceInfo) == 0x002EE0, "Member 'UConfig_105852::BounceInfo' has a wrong offset!");
static_assert(offsetof(UConfig_105852, PriorityOne) == 0x0045C0, "Member 'UConfig_105852::PriorityOne' has a wrong offset!");
static_assert(offsetof(UConfig_105852, PriorityTwo) == 0x0045C1, "Member 'UConfig_105852::PriorityTwo' has a wrong offset!");
static_assert(offsetof(UConfig_105852, PriorityThree) == 0x0045C2, "Member 'UConfig_105852::PriorityThree' has a wrong offset!");
static_assert(offsetof(UConfig_105852, PriorityFour) == 0x0045C3, "Member 'UConfig_105852::PriorityFour' has a wrong offset!");
static_assert(offsetof(UConfig_105852, PreHomingBuffID) == 0x0045C4, "Member 'UConfig_105852::PreHomingBuffID' has a wrong offset!");
static_assert(offsetof(UConfig_105852, AfterHomingBuffInfos) == 0x0045C8, "Member 'UConfig_105852::AfterHomingBuffInfos' has a wrong offset!");

// Class Hero_1058.Ability_105852
// 0x0098 (0x2A90 - 0x29F8)
class UAbility_105852 : public UAbility_108
{
public:
	struct FPredictionKey                         SendHomingTargetKey;                               // 0x29F8(0x0070)(Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 InitialHomingActor;                                // 0x2A68(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHomingDataReady;                                  // 0x2A70(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A71[0x7];                                     // 0x2A71(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UMarvelAbilityTask_SelectTarget*        SelectTask;                                        // 0x2A78(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AProjectile_10585201*                   HomingProjectile;                                  // 0x2A80(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMarvelAbilityTask_Projectile*          SpawnProjectileTask;                               // 0x2A88(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnHomingProjectileSpawnSuccess(class AActor* SpawnActor, const struct FGameplayAbilityTargetDataHandle& Data);
	void OnInitialHomingDataReady();
	void OnServerReceiveHomingActor(const struct FHitResult& InHit);
	class AActor* TryTraceInitialHomingActor(struct FHitResult* OutResult);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_105852">();
	}
	static class UAbility_105852* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_105852>();
	}
};
static_assert(alignof(UAbility_105852) == 0x000008, "Wrong alignment on UAbility_105852");
static_assert(sizeof(UAbility_105852) == 0x002A90, "Wrong size on UAbility_105852");
static_assert(offsetof(UAbility_105852, SendHomingTargetKey) == 0x0029F8, "Member 'UAbility_105852::SendHomingTargetKey' has a wrong offset!");
static_assert(offsetof(UAbility_105852, InitialHomingActor) == 0x002A68, "Member 'UAbility_105852::InitialHomingActor' has a wrong offset!");
static_assert(offsetof(UAbility_105852, bHomingDataReady) == 0x002A70, "Member 'UAbility_105852::bHomingDataReady' has a wrong offset!");
static_assert(offsetof(UAbility_105852, SelectTask) == 0x002A78, "Member 'UAbility_105852::SelectTask' has a wrong offset!");
static_assert(offsetof(UAbility_105852, HomingProjectile) == 0x002A80, "Member 'UAbility_105852::HomingProjectile' has a wrong offset!");
static_assert(offsetof(UAbility_105852, SpawnProjectileTask) == 0x002A88, "Member 'UAbility_105852::SpawnProjectileTask' has a wrong offset!");

// Class Hero_1058.GambitTrackingProjectileMovement
// 0x0000 (0x2A40 - 0x2A40)
class UGambitTrackingProjectileMovement final : public UMarvelProjectileComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GambitTrackingProjectileMovement">();
	}
	static class UGambitTrackingProjectileMovement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGambitTrackingProjectileMovement>();
	}
};
static_assert(alignof(UGambitTrackingProjectileMovement) == 0x000010, "Wrong alignment on UGambitTrackingProjectileMovement");
static_assert(sizeof(UGambitTrackingProjectileMovement) == 0x002A40, "Wrong size on UGambitTrackingProjectileMovement");

// Class Hero_1058.Projectile_10585201
// 0x0030 (0x5390 - 0x5360)
class AProjectile_10585201 : public AMarvelBounceProjectile
{
public:
	class AMarvelBaseCharacter*                   OwnerCharacter;                                    // 0x5358(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UConfig_105852*                         AbilityConfig;                                     // 0x5360(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGambitProjectileTrackingState                CurrentState;                                      // 0x5368(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5369[0x7];                                     // 0x5369(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TWeakObjectPtr<class AActor>>          IgnoreCollisionActors;                             // 0x5370(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPublic)
	bool                                          bStopConductBehavior;                              // 0x5380(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5381[0x7];                                     // 0x5381(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 CurrentHomingActor;                                // 0x5388(0x0008)(BlueprintVisible, Net, ZeroConstructor, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void OnRep_CurrentHomingActor();
	void RemoteProjectileBounce(const struct FHitResult& ImpactResult, const struct FVector& ImpactVelocity);
	void SetCurrentHomingTarget(class AActor* InTarget);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Projectile_10585201">();
	}
	static class AProjectile_10585201* GetDefaultObj()
	{
		return GetDefaultObjImpl<AProjectile_10585201>();
	}
};
static_assert(alignof(AProjectile_10585201) == 0x000010, "Wrong alignment on AProjectile_10585201");
static_assert(sizeof(AProjectile_10585201) == 0x005390, "Wrong size on AProjectile_10585201");
static_assert(offsetof(AProjectile_10585201, OwnerCharacter) == 0x005358, "Member 'AProjectile_10585201::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(AProjectile_10585201, AbilityConfig) == 0x005360, "Member 'AProjectile_10585201::AbilityConfig' has a wrong offset!");
static_assert(offsetof(AProjectile_10585201, CurrentState) == 0x005368, "Member 'AProjectile_10585201::CurrentState' has a wrong offset!");
static_assert(offsetof(AProjectile_10585201, IgnoreCollisionActors) == 0x005370, "Member 'AProjectile_10585201::IgnoreCollisionActors' has a wrong offset!");
static_assert(offsetof(AProjectile_10585201, bStopConductBehavior) == 0x005380, "Member 'AProjectile_10585201::bStopConductBehavior' has a wrong offset!");
static_assert(offsetof(AProjectile_10585201, CurrentHomingActor) == 0x005388, "Member 'AProjectile_10585201::CurrentHomingActor' has a wrong offset!");

// Class Hero_1058.Config_105853
// 0x0008 (0x00A0 - 0x0098)
class UConfig_105853 : public UMarvelAbilityConfig
{
public:
	int32                                         MaxSingleTargetApplyCount;                         // 0x0098(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxSingleSelfApplyCount;                           // 0x009C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config_105853">();
	}
	static class UConfig_105853* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig_105853>();
	}
};
static_assert(alignof(UConfig_105853) == 0x000008, "Wrong alignment on UConfig_105853");
static_assert(sizeof(UConfig_105853) == 0x0000A0, "Wrong size on UConfig_105853");
static_assert(offsetof(UConfig_105853, MaxSingleTargetApplyCount) == 0x000098, "Member 'UConfig_105853::MaxSingleTargetApplyCount' has a wrong offset!");
static_assert(offsetof(UConfig_105853, MaxSingleSelfApplyCount) == 0x00009C, "Member 'UConfig_105853::MaxSingleSelfApplyCount' has a wrong offset!");

// Class Hero_1058.Ability_105853
// 0x0078 (0x2A70 - 0x29F8)
class alignas(0x10) UAbility_105853 : public UAbility_108
{
public:
	TMap<class FString, struct FPlayerApplyCountData_105853> TargetApplyCountMap;                    // 0x29F8(0x0050)(NativeAccessSpecifierPublic)
	uint8                                         Pad_2A48[0x18];                                    // 0x2A48(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UConfig_105853*                         CachedConfig;                                      // 0x2A60(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A68[0x8];                                     // 0x2A68(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CanApplyEffectToTarget(const class FString& InKey, class AActor* InActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_105853">();
	}
	static class UAbility_105853* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_105853>();
	}
};
static_assert(alignof(UAbility_105853) == 0x000010, "Wrong alignment on UAbility_105853");
static_assert(sizeof(UAbility_105853) == 0x002A70, "Wrong size on UAbility_105853");
static_assert(offsetof(UAbility_105853, TargetApplyCountMap) == 0x0029F8, "Member 'UAbility_105853::TargetApplyCountMap' has a wrong offset!");
static_assert(offsetof(UAbility_105853, CachedConfig) == 0x002A60, "Member 'UAbility_105853::CachedConfig' has a wrong offset!");

// Class Hero_1058.Projectile_10585301_Base
// 0x0010 (0x3BA0 - 0x3B90)
class AProjectile_10585301_Base final : public AMarvelAbilityTargetActor_Projectile
{
public:
	class FString                                 CachedActivationKey;                               // 0x3B88(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B98[0x8];                                     // 0x3B98(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Projectile_10585301_Base">();
	}
	static class AProjectile_10585301_Base* GetDefaultObj()
	{
		return GetDefaultObjImpl<AProjectile_10585301_Base>();
	}
};
static_assert(alignof(AProjectile_10585301_Base) == 0x000010, "Wrong alignment on AProjectile_10585301_Base");
static_assert(sizeof(AProjectile_10585301_Base) == 0x003BA0, "Wrong size on AProjectile_10585301_Base");
static_assert(offsetof(AProjectile_10585301_Base, CachedActivationKey) == 0x003B88, "Member 'AProjectile_10585301_Base::CachedActivationKey' has a wrong offset!");

// Class Hero_1058.EffectiveComponent_10585301_Base
// 0x0000 (0x1C70 - 0x1C70)
class UEffectiveComponent_10585301_Base final : public UMarvelAgentEffectiveComponent
{
public:
	TArray<struct FHitResult> K2_OnPreApplyContainer(const TArray<struct FHitResult>& HitResults);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EffectiveComponent_10585301_Base">();
	}
	static class UEffectiveComponent_10585301_Base* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEffectiveComponent_10585301_Base>();
	}
};
static_assert(alignof(UEffectiveComponent_10585301_Base) == 0x000010, "Wrong alignment on UEffectiveComponent_10585301_Base");
static_assert(sizeof(UEffectiveComponent_10585301_Base) == 0x001C70, "Wrong size on UEffectiveComponent_10585301_Base");

// Class Hero_1058.Ability_105871
// 0x00F0 (0x2AE8 - 0x29F8)
class UAbility_105871 : public UAbility_108
{
public:
	struct FPredictionKey                         SpawnDestructionScopeKey;                          // 0x29F8(0x0070)(Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPredictionKey                         WaitSelectDataKey;                                 // 0x2A68(0x0070)(Transient, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETimelineLoopState_105871                     CurrentAbilityState;                               // 0x2AD8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETimelineLoopState_105871                     LastAbilityState;                                  // 0x2AD9(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2ADA[0x6];                                     // 0x2ADA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class AMarvelBaseCharacter*                   OwnerCharacter;                                    // 0x2AE0(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void K2_OnSelectDataReady(const TArray<struct FHitResult>& HitResults);
	void LocallyUpdateSelectResults(const TArray<struct FHitResult>& HitResults);
	void OnServerReceiveSelectResults(const TArray<struct FHitResult>& HitResults);

	void StopWaitLocalSelectResults() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_105871">();
	}
	static class UAbility_105871* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_105871>();
	}
};
static_assert(alignof(UAbility_105871) == 0x000008, "Wrong alignment on UAbility_105871");
static_assert(sizeof(UAbility_105871) == 0x002AE8, "Wrong size on UAbility_105871");
static_assert(offsetof(UAbility_105871, SpawnDestructionScopeKey) == 0x0029F8, "Member 'UAbility_105871::SpawnDestructionScopeKey' has a wrong offset!");
static_assert(offsetof(UAbility_105871, WaitSelectDataKey) == 0x002A68, "Member 'UAbility_105871::WaitSelectDataKey' has a wrong offset!");
static_assert(offsetof(UAbility_105871, CurrentAbilityState) == 0x002AD8, "Member 'UAbility_105871::CurrentAbilityState' has a wrong offset!");
static_assert(offsetof(UAbility_105871, LastAbilityState) == 0x002AD9, "Member 'UAbility_105871::LastAbilityState' has a wrong offset!");
static_assert(offsetof(UAbility_105871, OwnerCharacter) == 0x002AE0, "Member 'UAbility_105871::OwnerCharacter' has a wrong offset!");

// Class Hero_1058.Projectile_10587101
// 0x0010 (0x3BA0 - 0x3B90)
class AProjectile_10587101 : public AMarvelAbilityTargetActor_Projectile
{
public:
	TArray<EObjectTypeQuery>                      TraceObjectQuery;                                  // 0x3B88(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B98[0x8];                                     // 0x3B98(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void K2_PerformMovement(float DeltaTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Projectile_10587101">();
	}
	static class AProjectile_10587101* GetDefaultObj()
	{
		return GetDefaultObjImpl<AProjectile_10587101>();
	}
};
static_assert(alignof(AProjectile_10587101) == 0x000010, "Wrong alignment on AProjectile_10587101");
static_assert(sizeof(AProjectile_10587101) == 0x003BA0, "Wrong size on AProjectile_10587101");
static_assert(offsetof(AProjectile_10587101, TraceObjectQuery) == 0x003B88, "Member 'AProjectile_10587101::TraceObjectQuery' has a wrong offset!");

// Class Hero_1058.ProjectileMovement_10587101
// 0x0000 (0x2A40 - 0x2A40)
class UProjectileMovement_10587101 final : public UMarvelProjectileComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProjectileMovement_10587101">();
	}
	static class UProjectileMovement_10587101* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProjectileMovement_10587101>();
	}
};
static_assert(alignof(UProjectileMovement_10587101) == 0x000010, "Wrong alignment on UProjectileMovement_10587101");
static_assert(sizeof(UProjectileMovement_10587101) == 0x002A40, "Wrong size on UProjectileMovement_10587101");

// Class Hero_1058.BuffAbility_10587101
// 0x0040 (0x13B0 - 0x1370)
class UBuffAbility_10587101 : public UMarvelEffectGameplayAbility
{
public:
	float                                         ExtraJumpZVelocity;                                // 0x1370(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1374[0x3C];                                    // 0x1374(0x003C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuffAbility_10587101">();
	}
	static class UBuffAbility_10587101* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBuffAbility_10587101>();
	}
};
static_assert(alignof(UBuffAbility_10587101) == 0x000008, "Wrong alignment on UBuffAbility_10587101");
static_assert(sizeof(UBuffAbility_10587101) == 0x0013B0, "Wrong size on UBuffAbility_10587101");
static_assert(offsetof(UBuffAbility_10587101, ExtraJumpZVelocity) == 0x001370, "Member 'UBuffAbility_10587101::ExtraJumpZVelocity' has a wrong offset!");

// Class Hero_1058.Cue_Buff_10587101
// 0x0000 (0x1640 - 0x1640)
class ACue_Buff_10587101 : public AMarvelCueNotify_Buff
{
public:
	void OnOwnerCharacterApplyDamage(class AActor* InSourceAvatar, class AActor* InTargetAvatar, const struct FAttributeModifierHandle& ModifierParameterHandle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Buff_10587101">();
	}
	static class ACue_Buff_10587101* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Buff_10587101>();
	}
};
static_assert(alignof(ACue_Buff_10587101) == 0x000010, "Wrong alignment on ACue_Buff_10587101");
static_assert(sizeof(ACue_Buff_10587101) == 0x001640, "Wrong size on ACue_Buff_10587101");

// Class Hero_1058.GambitAnimInstance
// 0x0000 (0x0A20 - 0x0A20)
class UGambitAnimInstance final : public UMarvelAnimInstance
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GambitAnimInstance">();
	}
	static class UGambitAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGambitAnimInstance>();
	}
};
static_assert(alignof(UGambitAnimInstance) == 0x000010, "Wrong alignment on UGambitAnimInstance");
static_assert(sizeof(UGambitAnimInstance) == 0x000A20, "Wrong size on UGambitAnimInstance");

// Class Hero_1058.GambitCharacter
// 0x0010 (0x21B0 - 0x21A0)
class AGambitCharacter : public AMarvelBaseCharacter
{
public:
	class UGambitMoveLogicBaseComponent*          GambitMoveLogic;                                   // 0x21A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_21A8[0x8];                                     // 0x21A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GambitCharacter">();
	}
	static class AGambitCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGambitCharacter>();
	}
};
static_assert(alignof(AGambitCharacter) == 0x000010, "Wrong alignment on AGambitCharacter");
static_assert(sizeof(AGambitCharacter) == 0x0021B0, "Wrong size on AGambitCharacter");
static_assert(offsetof(AGambitCharacter, GambitMoveLogic) == 0x0021A0, "Member 'AGambitCharacter::GambitMoveLogic' has a wrong offset!");

// Class Hero_1058.GambitChildActor
// 0x0010 (0x0E30 - 0x0E20)
class AGambitChildActor final : public AMarvelCharacterChildActor
{
public:
	class USkeletalMeshComponent*                 PoleMesh;                                          // 0x0E18(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           HidePoleMeshTag;                                   // 0x0E20(0x000C)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E2C[0x4];                                      // 0x0E2C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GambitChildActor">();
	}
	static class AGambitChildActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGambitChildActor>();
	}
};
static_assert(alignof(AGambitChildActor) == 0x000010, "Wrong alignment on AGambitChildActor");
static_assert(sizeof(AGambitChildActor) == 0x000E30, "Wrong size on AGambitChildActor");
static_assert(offsetof(AGambitChildActor, PoleMesh) == 0x000E18, "Member 'AGambitChildActor::PoleMesh' has a wrong offset!");
static_assert(offsetof(AGambitChildActor, HidePoleMeshTag) == 0x000E20, "Member 'AGambitChildActor::HidePoleMeshTag' has a wrong offset!");

// Class Hero_1058.GambitMoveLogicBaseComponent
// 0x0000 (0x0400 - 0x0400)
class UGambitMoveLogicBaseComponent final : public UMarvelMoveLogicBaseComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GambitMoveLogicBaseComponent">();
	}
	static class UGambitMoveLogicBaseComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGambitMoveLogicBaseComponent>();
	}
};
static_assert(alignof(UGambitMoveLogicBaseComponent) == 0x000008, "Wrong alignment on UGambitMoveLogicBaseComponent");
static_assert(sizeof(UGambitMoveLogicBaseComponent) == 0x000400, "Wrong size on UGambitMoveLogicBaseComponent");

// Class Hero_1058.GambitMovementComponent
// 0x0000 (0x2360 - 0x2360)
class UGambitMovementComponent final : public UMarvelCharacterMovementComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GambitMovementComponent">();
	}
	static class UGambitMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGambitMovementComponent>();
	}
};
static_assert(alignof(UGambitMovementComponent) == 0x000010, "Wrong alignment on UGambitMovementComponent");
static_assert(sizeof(UGambitMovementComponent) == 0x002360, "Wrong size on UGambitMovementComponent");

}

