#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Hero_Synergy

#include "Basic.hpp"

#include "Hero_Synergy_classes.hpp"
#include "Hero_Synergy_parameters.hpp"


namespace SDK
{

// Function Hero_Synergy.MarvelBackTrackAbility.DelayStartRecord
// (Final, Native, Public)
// Parameters:
// bool                                    bSetDelay                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMarvelBackTrackAbility::DelayStartRecord(bool bSetDelay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MarvelBackTrackAbility", "DelayStartRecord");

	Params::MarvelBackTrackAbility_DelayStartRecord Parms{};

	Parms.bSetDelay = bSetDelay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Hero_Synergy.MarvelBackTrackAbility.IsHoldMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMarvelBackTrackAbility::IsHoldMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MarvelBackTrackAbility", "IsHoldMode");

	Params::MarvelBackTrackAbility_IsHoldMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Hero_Synergy.MarvelBackTrackAbility.MulticastInterrupt
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void UMarvelBackTrackAbility::MulticastInterrupt()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MarvelBackTrackAbility", "MulticastInterrupt");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Hero_Synergy.MarvelBackTrackAbility.OnCharacterForceChangedBySourceActor
// (Final, Native, Public, HasOutParams, HasDefaults)
// Parameters:
// const struct FTransform&                OriginTransform                                        (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FTransform&                ThroughTransform                                       (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           SourceActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMarvelBackTrackAbility::OnCharacterForceChangedBySourceActor(const struct FTransform& OriginTransform, const struct FTransform& ThroughTransform, class AActor* SourceActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MarvelBackTrackAbility", "OnCharacterForceChangedBySourceActor");

	Params::MarvelBackTrackAbility_OnCharacterForceChangedBySourceActor Parms{};

	Parms.OriginTransform = std::move(OriginTransform);
	Parms.ThroughTransform = std::move(ThroughTransform);
	Parms.SourceActor = SourceActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Hero_Synergy.MarvelBackTrackAbility.OnCharacterMovementPreUpdated
// (Final, Native, Public)
// Parameters:
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMarvelBackTrackAbility::OnCharacterMovementPreUpdated(float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MarvelBackTrackAbility", "OnCharacterMovementPreUpdated");

	Params::MarvelBackTrackAbility_OnCharacterMovementPreUpdated Parms{};

	Parms.DeltaTime = DeltaTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Hero_Synergy.MarvelBackTrackAbility.OnClientAckMoveWithStamp
// (Final, Native, Public, HasOutParams, HasDefaults)
// Parameters:
// const float                             TimeStamp                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMarvelBackTrackAbility::OnClientAckMoveWithStamp(const float TimeStamp, const struct FVector& Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MarvelBackTrackAbility", "OnClientAckMoveWithStamp");

	Params::MarvelBackTrackAbility_OnClientAckMoveWithStamp Parms{};

	Parms.TimeStamp = TimeStamp;
	Parms.Location = std::move(Location);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Hero_Synergy.MarvelBackTrackAbility.OnLivingStateChanged
// (Final, Native, Public)
// Parameters:
// EPlayerLivingState                      LivingState                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMarvelBackTrackAbility::OnLivingStateChanged(EPlayerLivingState LivingState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MarvelBackTrackAbility", "OnLivingStateChanged");

	Params::MarvelBackTrackAbility_OnLivingStateChanged Parms{};

	Parms.LivingState = LivingState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Hero_Synergy.MarvelBackTrackAbility.OnLongPressRelease
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   TimeHeld                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMarvelBackTrackAbility::OnLongPressRelease(float TimeHeld)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MarvelBackTrackAbility", "OnLongPressRelease");

	Params::MarvelBackTrackAbility_OnLongPressRelease Parms{};

	Parms.TimeHeld = TimeHeld;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Hero_Synergy.MarvelBackTrackAbility.OnLongPressTimeOverMaxHoldTime
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   TimeHeld                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMarvelBackTrackAbility::OnLongPressTimeOverMaxHoldTime(float TimeHeld)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MarvelBackTrackAbility", "OnLongPressTimeOverMaxHoldTime");

	Params::MarvelBackTrackAbility_OnLongPressTimeOverMaxHoldTime Parms{};

	Parms.TimeHeld = TimeHeld;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Hero_Synergy.MarvelBackTrackAbility.OnServerHandleClientMoveWithStamp
// (Final, Native, Public, HasOutParams, HasDefaults)
// Parameters:
// const float                             TimeStamp                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMarvelBackTrackAbility::OnServerHandleClientMoveWithStamp(const float TimeStamp, const struct FVector& Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MarvelBackTrackAbility", "OnServerHandleClientMoveWithStamp");

	Params::MarvelBackTrackAbility_OnServerHandleClientMoveWithStamp Parms{};

	Parms.TimeStamp = TimeStamp;
	Parms.Location = std::move(Location);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Hero_Synergy.MarvelBackTrackAbility.RecordState
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const float                             TimeStamp                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMarvelBackTrackAbility::RecordState(const float TimeStamp, const struct FVector& Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MarvelBackTrackAbility", "RecordState");

	Params::MarvelBackTrackAbility_RecordState Parms{};

	Parms.TimeStamp = TimeStamp;
	Parms.Location = std::move(Location);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Hero_Synergy.MarvelBackTrackAbility.ServerCheckClientLocValid
// (Final, Native, Public, HasOutParams, HasDefaults)
// Parameters:
// const struct FVector&                   InTargetLoc                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bStrictCheck                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMarvelBackTrackAbility::ServerCheckClientLocValid(const struct FVector& InTargetLoc, bool bStrictCheck)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MarvelBackTrackAbility", "ServerCheckClientLocValid");

	Params::MarvelBackTrackAbility_ServerCheckClientLocValid Parms{};

	Parms.InTargetLoc = std::move(InTargetLoc);
	Parms.bStrictCheck = bStrictCheck;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Hero_Synergy.MarvelBackTrackAbility.ServerInterrupt
// (Net, NetReliable, Native, Event, Public, NetServer, HasDefaults)
// Parameters:
// const struct FVector&                   InClientLocation                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMarvelBackTrackAbility::ServerInterrupt(const struct FVector& InClientLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MarvelBackTrackAbility", "ServerInterrupt");

	Params::MarvelBackTrackAbility_ServerInterrupt Parms{};

	Parms.InClientLocation = std::move(InClientLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Hero_Synergy.MarvelBackTrackAbility.StartBackTrack
// (Final, Native, Public, BlueprintCallable)

void UMarvelBackTrackAbility::StartBackTrack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MarvelBackTrackAbility", "StartBackTrack");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Hero_Synergy.MarvelBackTrackAbility.StartRecordState
// (Final, Native, Public, BlueprintCallable)

void UMarvelBackTrackAbility::StartRecordState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MarvelBackTrackAbility", "StartRecordState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Hero_Synergy.MarvelBackTrackAbility.StopBackTrack
// (Final, Native, Public, BlueprintCallable)

void UMarvelBackTrackAbility::StopBackTrack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MarvelBackTrackAbility", "StopBackTrack");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Hero_Synergy.MarvelBackTrackAbility.StopRecordState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bClearData                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMarvelBackTrackAbility::StopRecordState(bool bClearData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MarvelBackTrackAbility", "StopRecordState");

	Params::MarvelBackTrackAbility_StopRecordState Parms{};

	Parms.bClearData = bClearData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Hero_Synergy.MarvelBackTrackAbility.SafeMoveTo
// (Final, Native, Public, HasOutParams, HasDefaults, Const)
// Parameters:
// const struct FVector&                   TargetLoc                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult*                      OutHit                                                 (Parm, OutParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    bSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PointIdx                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMarvelBackTrackAbility::SafeMoveTo(const struct FVector& TargetLoc, struct FHitResult* OutHit, bool bSweep, int32 PointIdx) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MarvelBackTrackAbility", "SafeMoveTo");

	Params::MarvelBackTrackAbility_SafeMoveTo Parms{};

	Parms.TargetLoc = std::move(TargetLoc);
	Parms.bSweep = bSweep;
	Parms.PointIdx = PointIdx;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutHit != nullptr)
		*OutHit = std::move(Parms.OutHit);

	return Parms.ReturnValue;
}


// Function Hero_Synergy.TraceComponent_100009.OnPreOutTraceResults
// (Native, Public, HasOutParams)
// Parameters:
// const struct FHitResult&                Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTraceComponent_100009::OnPreOutTraceResults(const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TraceComponent_100009", "OnPreOutTraceResults");

	Params::TraceComponent_100009_OnPreOutTraceResults Parms{};

	Parms.Hit = std::move(Hit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Hero_Synergy.BuffManagerAbility_100009.OnAbilityActivate
// (Final, Native, Public)
// Parameters:
// int32                                   AbilityID                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBuffManagerAbility_100009::OnAbilityActivate(int32 AbilityID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BuffManagerAbility_100009", "OnAbilityActivate");

	Params::BuffManagerAbility_100009_OnAbilityActivate Parms{};

	Parms.AbilityID = AbilityID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Hero_Synergy.BuffManagerAbility_100009.OnAbilityEnded
// (Final, Native, Public)
// Parameters:
// int32                                   AbilityID                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBuffManagerAbility_100009::OnAbilityEnded(int32 AbilityID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BuffManagerAbility_100009", "OnAbilityEnded");

	Params::BuffManagerAbility_100009_OnAbilityEnded Parms{};

	Parms.AbilityID = AbilityID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Hero_Synergy.BuffManagerAbility_100009.OnBuffExecuted
// (Final, Native, Public, HasOutParams)
// Parameters:
// class UAbilitySystemComponent*          AbilitySystemComponent                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayEffectSpecStackHandle&EffectSpecHandle                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FActiveGameplayEffectHandle&EffectHandle                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBuffManagerAbility_100009::OnBuffExecuted(class UAbilitySystemComponent* AbilitySystemComponent, const struct FGameplayEffectSpecStackHandle& EffectSpecHandle, const struct FActiveGameplayEffectHandle& EffectHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BuffManagerAbility_100009", "OnBuffExecuted");

	Params::BuffManagerAbility_100009_OnBuffExecuted Parms{};

	Parms.AbilitySystemComponent = AbilitySystemComponent;
	Parms.EffectSpecHandle = std::move(EffectSpecHandle);
	Parms.EffectHandle = std::move(EffectHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Hero_Synergy.BuffManagerAbility_100009.OnBuffRemoved
// (Final, Native, Public, HasOutParams)
// Parameters:
// const struct FActiveGameplayEffect&     RemovedEffect                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bPrematureRemoval                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBuffManagerAbility_100009::OnBuffRemoved(const struct FActiveGameplayEffect& RemovedEffect, bool bPrematureRemoval)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BuffManagerAbility_100009", "OnBuffRemoved");

	Params::BuffManagerAbility_100009_OnBuffRemoved Parms{};

	Parms.RemovedEffect = std::move(RemovedEffect);
	Parms.bPrematureRemoval = bPrematureRemoval;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Hero_Synergy.BuffManagerAbility_100009.OnOwnerCollide
// (Final, Native, Public, HasOutParams, HasDefaults)
// Parameters:
// class UPrimitiveComponent*              HitComponent                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   NormalImpulse                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UBuffManagerAbility_100009::OnOwnerCollide(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BuffManagerAbility_100009", "OnOwnerCollide");

	Params::BuffManagerAbility_100009_OnOwnerCollide Parms{};

	Parms.HitComponent = HitComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.NormalImpulse = std::move(NormalImpulse);
	Parms.Hit = std::move(Hit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Hero_Synergy.BuffManagerAbility_100009.OnOwnerTakeDamage
// (Final, Native, Public, HasOutParams)
// Parameters:
// class AActor*                           InSourceAvatar                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InTargetAvatar                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FAttributeModifierHandle&  ModifierParameterHandle                                (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBuffManagerAbility_100009::OnOwnerTakeDamage(class AActor* InSourceAvatar, class AActor* InTargetAvatar, const struct FAttributeModifierHandle& ModifierParameterHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BuffManagerAbility_100009", "OnOwnerTakeDamage");

	Params::BuffManagerAbility_100009_OnOwnerTakeDamage Parms{};

	Parms.InSourceAvatar = InSourceAvatar;
	Parms.InTargetAvatar = InTargetAvatar;
	Parms.ModifierParameterHandle = std::move(ModifierParameterHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Hero_Synergy.BuffManagerAbility_100009.RemoveBuffFromSelf
// (Final, Native, Public, BlueprintCallable)

void UBuffManagerAbility_100009::RemoveBuffFromSelf()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BuffManagerAbility_100009", "RemoveBuffFromSelf");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Hero_Synergy.BuffManagerAbility_100009.RestoreBuffToSelfWithDelay
// (Final, Native, Public, BlueprintCallable)

void UBuffManagerAbility_100009::RestoreBuffToSelfWithDelay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BuffManagerAbility_100009", "RestoreBuffToSelfWithDelay");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Hero_Synergy.Ability_100015.AddWavingData
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FHitResult&                InHitResult                                            (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UAbility_100015::AddWavingData(const struct FHitResult& InHitResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Ability_100015", "AddWavingData");

	Params::Ability_100015_AddWavingData Parms{};

	Parms.InHitResult = std::move(InHitResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Hero_Synergy.Ability_100015.BindCancelRideInput
// (Final, Native, Protected, BlueprintCallable)

void UAbility_100015::BindCancelRideInput()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Ability_100015", "BindCancelRideInput");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Hero_Synergy.Ability_100015.CancelRelevantSynergyAbility
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNormalEnd                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAbility_100015::CancelRelevantSynergyAbility(bool bNormalEnd)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Ability_100015", "CancelRelevantSynergyAbility");

	Params::Ability_100015_CancelRelevantSynergyAbility Parms{};

	Parms.bNormalEnd = bNormalEnd;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Hero_Synergy.Ability_100015.ClearWavingHoldTimer
// (Final, Native, Public, BlueprintCallable)

void UAbility_100015::ClearWavingHoldTimer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Ability_100015", "ClearWavingHoldTimer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Hero_Synergy.Ability_100015.ClientCheckWavingState
// (Final, Native, Protected)
// Parameters:
// ESynergyWavingState                     AuthorityRoleState                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAbility_100015::ClientCheckWavingState(ESynergyWavingState AuthorityRoleState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Ability_100015", "ClientCheckWavingState");

	Params::Ability_100015_ClientCheckWavingState Parms{};

	Parms.AuthorityRoleState = AuthorityRoleState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Hero_Synergy.Ability_100015.CustomCommitSynergyCoolDown
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNormalEnd                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAbility_100015::CustomCommitSynergyCoolDown(bool bNormalEnd)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Ability_100015", "CustomCommitSynergyCoolDown");

	Params::Ability_100015_CustomCommitSynergyCoolDown Parms{};

	Parms.bNormalEnd = bNormalEnd;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Hero_Synergy.Ability_100015.GetDashPortalSegments
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FPortalSegments                  ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FPortalSegments UAbility_100015::GetDashPortalSegments()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Ability_100015", "GetDashPortalSegments");

	Params::Ability_100015_GetDashPortalSegments Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Hero_Synergy.Ability_100015.GetRelevantSynergyAbility
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AMarvelBaseCharacter*             InCharacter                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAbility_100015*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAbility_100015* UAbility_100015::GetRelevantSynergyAbility(class AMarvelBaseCharacter* InCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Ability_100015", "GetRelevantSynergyAbility");

	Params::Ability_100015_GetRelevantSynergyAbility Parms{};

	Parms.InCharacter = InCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Hero_Synergy.Ability_100015.HasActiveBond
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAbility_100015::HasActiveBond()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Ability_100015", "HasActiveBond");

	Params::Ability_100015_HasActiveBond Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Hero_Synergy.Ability_100015.IsAbilityNormalEnd
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAbility_100015::IsAbilityNormalEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Ability_100015", "IsAbilityNormalEnd");

	Params::Ability_100015_IsAbilityNormalEnd Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Hero_Synergy.Ability_100015.K2_CanCancelByRelevantAbility
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAbility_100015::K2_CanCancelByRelevantAbility()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Ability_100015", "K2_CanCancelByRelevantAbility");

	Params::Ability_100015_K2_CanCancelByRelevantAbility Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Hero_Synergy.Ability_100015.K2_OnStartWaving
// (Native, Event, Protected, BlueprintEvent)

void UAbility_100015::K2_OnStartWaving()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Ability_100015", "K2_OnStartWaving");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Hero_Synergy.Ability_100015.K2_OnWavingConfirmed
// (Native, Event, Protected, BlueprintEvent)

void UAbility_100015::K2_OnWavingConfirmed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Ability_100015", "K2_OnWavingConfirmed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Hero_Synergy.Ability_100015.K2_OnWavingOffSight
// (Native, Event, Protected, BlueprintEvent)

void UAbility_100015::K2_OnWavingOffSight()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Ability_100015", "K2_OnWavingOffSight");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Hero_Synergy.Ability_100015.K2_OnWavingTimeOut
// (Native, Event, Protected, BlueprintEvent)

void UAbility_100015::K2_OnWavingTimeOut()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Ability_100015", "K2_OnWavingTimeOut");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Hero_Synergy.Ability_100015.OnCoopAbilityTickStateChanged
// (Final, Native, Protected)
// Parameters:
// bool                                    bShouldAbilityTick                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAbility_100015::OnCoopAbilityTickStateChanged(bool bShouldAbilityTick)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Ability_100015", "OnCoopAbilityTickStateChanged");

	Params::Ability_100015_OnCoopAbilityTickStateChanged Parms{};

	Parms.bShouldAbilityTick = bShouldAbilityTick;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Hero_Synergy.Ability_100015.OnOwnerGameplayTagUpdate
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const struct FGameplayTag&              InTag                                                  (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bTagExists                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAbility_100015::OnOwnerGameplayTagUpdate(const struct FGameplayTag& InTag, bool bTagExists)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Ability_100015", "OnOwnerGameplayTagUpdate");

	Params::Ability_100015_OnOwnerGameplayTagUpdate Parms{};

	Parms.InTag = std::move(InTag);
	Parms.bTagExists = bTagExists;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Hero_Synergy.Ability_100015.OnRep_ConfirmedCharacter
// (Final, Native, Protected)

void UAbility_100015::OnRep_ConfirmedCharacter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Ability_100015", "OnRep_ConfirmedCharacter");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Hero_Synergy.Ability_100015.OnRep_CurrentWavingState
// (Final, Native, Protected)

void UAbility_100015::OnRep_CurrentWavingState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Ability_100015", "OnRep_CurrentWavingState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Hero_Synergy.Ability_100015.OnRep_WavingData
// (Final, Native, Protected)

void UAbility_100015::OnRep_WavingData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Ability_100015", "OnRep_WavingData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Hero_Synergy.Ability_100015.OnRideCancel
// (Net, NetReliable, Native, Event, Protected, NetServer)
// Parameters:
// float                                   StateIntervalTime                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAbility_100015::OnRideCancel(float StateIntervalTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Ability_100015", "OnRideCancel");

	Params::Ability_100015_OnRideCancel Parms{};

	Parms.StateIntervalTime = StateIntervalTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Hero_Synergy.Ability_100015.OnWavingCharacterOffSightCallBack
// (Final, Native, Protected)

void UAbility_100015::OnWavingCharacterOffSightCallBack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Ability_100015", "OnWavingCharacterOffSightCallBack");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Hero_Synergy.Ability_100015.Python_OnRideCancel
// (Event, Protected, BlueprintEvent)

void UAbility_100015::Python_OnRideCancel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Ability_100015", "Python_OnRideCancel");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Hero_Synergy.Ability_100015.RemoveWavingData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAbility_100015::RemoveWavingData(class AActor* InActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Ability_100015", "RemoveWavingData");

	Params::Ability_100015_RemoveWavingData Parms{};

	Parms.InActor = InActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Hero_Synergy.Ability_100015.SetCurrentWavingCharacter
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class AActor*                     TargetActor                                            (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAbility_100015::SetCurrentWavingCharacter(const class AActor* TargetActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Ability_100015", "SetCurrentWavingCharacter");

	Params::Ability_100015_SetCurrentWavingCharacter Parms{};

	Parms.TargetActor = TargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Hero_Synergy.Ability_100015.SetWavingConfirmedByCharacter
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AMarvelBaseCharacter*             InCharacter                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAbility_100015::SetWavingConfirmedByCharacter(class AMarvelBaseCharacter* InCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Ability_100015", "SetWavingConfirmedByCharacter");

	Params::Ability_100015_SetWavingConfirmedByCharacter Parms{};

	Parms.InCharacter = InCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Hero_Synergy.Ability_100015.SetWavingState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ESynergyWavingState                     InNewState                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAbility_100015::SetWavingState(ESynergyWavingState InNewState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Ability_100015", "SetWavingState");

	Params::Ability_100015_SetWavingState Parms{};

	Parms.InNewState = InNewState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Hero_Synergy.Ability_100015.CheckConfirmedOriginWithinTolerance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAbility_100015::CheckConfirmedOriginWithinTolerance() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Ability_100015", "CheckConfirmedOriginWithinTolerance");

	Params::Ability_100015_CheckConfirmedOriginWithinTolerance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Hero_Synergy.Ability_100015.GetWavingState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ESynergyWavingState                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESynergyWavingState UAbility_100015::GetWavingState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Ability_100015", "GetWavingState");

	Params::Ability_100015_GetWavingState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Hero_Synergy.Ability_100015.IsActiveInitiator
// (Final, Native, Protected, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAbility_100015::IsActiveInitiator() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Ability_100015", "IsActiveInitiator");

	Params::Ability_100015_IsActiveInitiator Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Hero_Synergy.Ability_100015.IsPassiveInitiator
// (Final, Native, Protected, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAbility_100015::IsPassiveInitiator() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Ability_100015", "IsPassiveInitiator");

	Params::Ability_100015_IsPassiveInitiator Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Hero_Synergy.Ability_100015.IsProcessingActiveInitiator
// (Final, Native, Protected, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAbility_100015::IsProcessingActiveInitiator() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Ability_100015", "IsProcessingActiveInitiator");

	Params::Ability_100015_IsProcessingActiveInitiator Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Hero_Synergy.Ability_100015.IsProcessingPassiveInitiator
// (Final, Native, Protected, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAbility_100015::IsProcessingPassiveInitiator() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Ability_100015", "IsProcessingPassiveInitiator");

	Params::Ability_100015_IsProcessingPassiveInitiator Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Hero_Synergy.Ability_100016.BroadcastThrowSplineHudEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAbility_100016::BroadcastThrowSplineHudEnabled(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Ability_100016", "BroadcastThrowSplineHudEnabled");

	Params::Ability_100016_BroadcastThrowSplineHudEnabled Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Hero_Synergy.Ability_100016.OnRep_ThrowCharacter
// (Final, Native, Public)

void UAbility_100016::OnRep_ThrowCharacter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Ability_100016", "OnRep_ThrowCharacter");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Hero_Synergy.Ability_100016.OnThrowCharacterCoopRideStateChanged
// (Final, Native, Protected)
// Parameters:
// bool                                    bIsRiding                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AMarvelBaseCharacter*             RideCharacter                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAbility_100016::OnThrowCharacterCoopRideStateChanged(bool bIsRiding, class AMarvelBaseCharacter* RideCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Ability_100016", "OnThrowCharacterCoopRideStateChanged");

	Params::Ability_100016_OnThrowCharacterCoopRideStateChanged Parms{};

	Parms.bIsRiding = bIsRiding;
	Parms.RideCharacter = RideCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Hero_Synergy.Ability_100016.PredictThrowDataWhenPressed
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   PredictVelocity                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FVector>*                 PredictionPath                                         (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// float                                   MaxFallSeconds                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxJumpHeightDown                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAbility_100016::PredictThrowDataWhenPressed(const struct FVector& PredictVelocity, TArray<struct FVector>* PredictionPath, float MaxFallSeconds, float MaxJumpHeightDown)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Ability_100016", "PredictThrowDataWhenPressed");

	Params::Ability_100016_PredictThrowDataWhenPressed Parms{};

	Parms.PredictVelocity = std::move(PredictVelocity);
	Parms.MaxFallSeconds = MaxFallSeconds;
	Parms.MaxJumpHeightDown = MaxJumpHeightDown;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (PredictionPath != nullptr)
		*PredictionPath = std::move(Parms.PredictionPath);
}


// Function Hero_Synergy.Ability_100016.PredictThrowVelocity
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// float                                   PredictSpeed                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRemoteRole                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRotator&                  InRotator                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UAbility_100016::PredictThrowVelocity(float PredictSpeed, bool bRemoteRole, const struct FRotator& InRotator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Ability_100016", "PredictThrowVelocity");

	Params::Ability_100016_PredictThrowVelocity Parms{};

	Parms.PredictSpeed = PredictSpeed;
	Parms.bRemoteRole = bRemoteRole;
	Parms.InRotator = std::move(InRotator);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Hero_Synergy.Cue_Ability_Loop_100016.OnOwnerAbilityThrowSplineHudEnabledChanged
// (Final, Native, Protected)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACue_Ability_Loop_100016::OnOwnerAbilityThrowSplineHudEnabledChanged(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Cue_Ability_Loop_100016", "OnOwnerAbilityThrowSplineHudEnabledChanged");

	Params::Cue_Ability_Loop_100016_OnOwnerAbilityThrowSplineHudEnabledChanged Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Hero_Synergy.Cue_Ability_Loop_100016.OnPressRelease
// (Final, Native, Public)
// Parameters:
// float                                   TimeWaited                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACue_Ability_Loop_100016::OnPressRelease(float TimeWaited)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Cue_Ability_Loop_100016", "OnPressRelease");

	Params::Cue_Ability_Loop_100016_OnPressRelease Parms{};

	Parms.TimeWaited = TimeWaited;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Hero_Synergy.Cue_Ability_Loop_100016.OnPressTimeMin
// (Final, Native, Public)
// Parameters:
// float                                   TimeWaited                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACue_Ability_Loop_100016::OnPressTimeMin(float TimeWaited)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Cue_Ability_Loop_100016", "OnPressTimeMin");

	Params::Cue_Ability_Loop_100016_OnPressTimeMin Parms{};

	Parms.TimeWaited = TimeWaited;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Hero_Synergy.Ability_100021.OnDashFinished
// (Final, Native, Protected)
// Parameters:
// EDashStopReason                         InReason                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAbility_100021::OnDashFinished(EDashStopReason InReason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Ability_100021", "OnDashFinished");

	Params::Ability_100021_OnDashFinished Parms{};

	Parms.InReason = InReason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Hero_Synergy.Ability_100021.OnDashToTargetGameplayTagUpdate
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const struct FGameplayTag&              InTag                                                  (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bTagExists                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAbility_100021::OnDashToTargetGameplayTagUpdate(const struct FGameplayTag& InTag, bool bTagExists)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Ability_100021", "OnDashToTargetGameplayTagUpdate");

	Params::Ability_100021_OnDashToTargetGameplayTagUpdate Parms{};

	Parms.InTag = std::move(InTag);
	Parms.bTagExists = bTagExists;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Hero_Synergy.Ability_100021.OnMeetSuccess
// (Native, Protected)

void UAbility_100021::OnMeetSuccess()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Ability_100021", "OnMeetSuccess");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Hero_Synergy.Ability_100021.OnOwnerCharacterMovementUpdated
// (Final, Native, Protected, HasDefaults)
// Parameters:
// float                                   DeltaSeconds                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   OldLocation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   OldVelocity                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAbility_100021::OnOwnerCharacterMovementUpdated(float DeltaSeconds, const struct FVector& OldLocation, const struct FVector& OldVelocity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Ability_100021", "OnOwnerCharacterMovementUpdated");

	Params::Ability_100021_OnOwnerCharacterMovementUpdated Parms{};

	Parms.DeltaSeconds = DeltaSeconds;
	Parms.OldLocation = std::move(OldLocation);
	Parms.OldVelocity = std::move(OldVelocity);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Hero_Synergy.Ability_100021.OnTargetCharacterForcedPortal
// (Final, Native, Protected)
// Parameters:
// class APortalViewActor*                 InPortal                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAbility_100021::OnTargetCharacterForcedPortal(class APortalViewActor* InPortal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Ability_100021", "OnTargetCharacterForcedPortal");

	Params::Ability_100021_OnTargetCharacterForcedPortal Parms{};

	Parms.InPortal = InPortal;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Hero_Synergy.SynergyAbility_100026.OnCheckDontKill
// (Final, Native, Public, HasOutParams)
// Parameters:
// const float                             CurrentHealth                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             TotalDamageLeft                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayEffectSpec&       DamageSpec                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USynergyAbility_100026::OnCheckDontKill(const float CurrentHealth, const float TotalDamageLeft, const struct FGameplayEffectSpec& DamageSpec)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SynergyAbility_100026", "OnCheckDontKill");

	Params::SynergyAbility_100026_OnCheckDontKill Parms{};

	Parms.CurrentHealth = CurrentHealth;
	Parms.TotalDamageLeft = TotalDamageLeft;
	Parms.DamageSpec = std::move(DamageSpec);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Hero_Synergy.SynergyAbility_10002603.OnSummonedBegin
// (Event, Public, BlueprintEvent)

void USynergyAbility_10002603::OnSummonedBegin()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SynergyAbility_10002603", "OnSummonedBegin");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Hero_Synergy.SynergyAbility_10002603.OnSummonedEnd
// (Event, Public, BlueprintEvent)

void USynergyAbility_10002603::OnSummonedEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SynergyAbility_10002603", "OnSummonedEnd");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Hero_Synergy.SynergyAbility_10002603.TryEndAbilityOnProjectileEnd
// (Event, Public, BlueprintEvent)

void USynergyAbility_10002603::TryEndAbilityOnProjectileEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SynergyAbility_10002603", "TryEndAbilityOnProjectileEnd");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Hero_Synergy.SynergySummoned_10002603.CheckTargetState
// (Final, Native, Public)

void ASynergySummoned_10002603::CheckTargetState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SynergySummoned_10002603", "CheckTargetState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Hero_Synergy.SynergySummoned_10002603.OnAttachParentActorDeath
// (Final, Native, Public, HasOutParams)
// Parameters:
// class AActor*                           InSourceAvatar                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InTargetAvatar                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FAttributeModifierHandle&  ModifierParameterHandle                                (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASynergySummoned_10002603::OnAttachParentActorDeath(class AActor* InSourceAvatar, class AActor* InTargetAvatar, const struct FAttributeModifierHandle& ModifierParameterHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SynergySummoned_10002603", "OnAttachParentActorDeath");

	Params::SynergySummoned_10002603_OnAttachParentActorDeath Parms{};

	Parms.InSourceAvatar = InSourceAvatar;
	Parms.InTargetAvatar = InTargetAvatar;
	Parms.ModifierParameterHandle = std::move(ModifierParameterHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Hero_Synergy.SynergySummoned_10002603.SetCheckTimer
// (Final, Native, Public)
// Parameters:
// bool                                    bSet                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASynergySummoned_10002603::SetCheckTimer(bool bSet)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SynergySummoned_10002603", "SetCheckTimer");

	Params::SynergySummoned_10002603_SetCheckTimer Parms{};

	Parms.bSet = bSet;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Hero_Synergy.SynergyAbility_1000260301.ApplyDash
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class UMarvelAbilityTask_Dash*          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMarvelAbilityTask_Dash* USynergyAbility_1000260301::ApplyDash()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SynergyAbility_1000260301", "ApplyDash");

	Params::SynergyAbility_1000260301_ApplyDash Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Hero_Synergy.SynergyAbility_1000260301.OnDashFinish
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// EDashStopReason                         Reason                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USynergyAbility_1000260301::OnDashFinish(EDashStopReason Reason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SynergyAbility_1000260301", "OnDashFinish");

	Params::SynergyAbility_1000260301_OnDashFinish Parms{};

	Parms.Reason = Reason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Hero_Synergy.JeffPassengerContainerComponent.Client_AttachPassengerAndUpdateComponentTickPrerequisite
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class AActor*                           InAttachPassenger                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJeffPassengerContainerComponent::Client_AttachPassengerAndUpdateComponentTickPrerequisite(class AActor* InAttachPassenger)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JeffPassengerContainerComponent", "Client_AttachPassengerAndUpdateComponentTickPrerequisite");

	Params::JeffPassengerContainerComponent_Client_AttachPassengerAndUpdateComponentTickPrerequisite Parms{};

	Parms.InAttachPassenger = InAttachPassenger;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Hero_Synergy.JeffPassengerContainerComponent.Client_DetachPassengerAndUpdateComponentTickPrerequisite
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class AActor*                           InDetachPassenger                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJeffPassengerContainerComponent::Client_DetachPassengerAndUpdateComponentTickPrerequisite(class AActor* InDetachPassenger)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JeffPassengerContainerComponent", "Client_DetachPassengerAndUpdateComponentTickPrerequisite");

	Params::JeffPassengerContainerComponent_Client_DetachPassengerAndUpdateComponentTickPrerequisite Parms{};

	Parms.InDetachPassenger = InDetachPassenger;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}

}

