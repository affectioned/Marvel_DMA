#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: MarvelLevel

#include "Basic.hpp"

#include "MarvelLevel_structs.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "Marvel_structs.hpp"
#include "Marvel_classes.hpp"
#include "GameplayTags_structs.hpp"
#include "GameplayAbilities_structs.hpp"
#include "GameplayAbilities_classes.hpp"
#include "LevelSequence_classes.hpp"


namespace SDK
{

// Class MarvelLevel.AnimNotify_LevelAnimSectionEnded
// 0x0000 (0x0040 - 0x0040)
class UAnimNotify_LevelAnimSectionEnded final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_LevelAnimSectionEnded">();
	}
	static class UAnimNotify_LevelAnimSectionEnded* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_LevelAnimSectionEnded>();
	}
};
static_assert(alignof(UAnimNotify_LevelAnimSectionEnded) == 0x000008, "Wrong alignment on UAnimNotify_LevelAnimSectionEnded");
static_assert(sizeof(UAnimNotify_LevelAnimSectionEnded) == 0x000040, "Wrong size on UAnimNotify_LevelAnimSectionEnded");

// Class MarvelLevel.DeathZoneActor
// 0x0000 (0x06E0 - 0x06E0)
class ADeathZoneActor : public AMarvelLevelActorBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DeathZoneActor">();
	}
	static class ADeathZoneActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADeathZoneActor>();
	}
};
static_assert(alignof(ADeathZoneActor) == 0x000010, "Wrong alignment on ADeathZoneActor");
static_assert(sizeof(ADeathZoneActor) == 0x0006E0, "Wrong size on ADeathZoneActor");

// Class MarvelLevel.EnvironmentGlobalActor
// 0x0000 (0x06E0 - 0x06E0)
class AEnvironmentGlobalActor : public AEnvironmentStaticActorBase
{
public:
	void ChangeQuality(bool IsHighQuality);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvironmentGlobalActor">();
	}
	static class AEnvironmentGlobalActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEnvironmentGlobalActor>();
	}
};
static_assert(alignof(AEnvironmentGlobalActor) == 0x000010, "Wrong alignment on AEnvironmentGlobalActor");
static_assert(sizeof(AEnvironmentGlobalActor) == 0x0006E0, "Wrong size on AEnvironmentGlobalActor");

// Class MarvelLevel.EnvironmentStaticActor
// 0x0010 (0x06F0 - 0x06E0)
class AEnvironmentStaticActor : public AEnvironmentStaticActorBase
{
public:
	class UStaticMeshComponent*                   MeshComponent;                                     // 0x06D8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEnvironmentActorTransitionComponent*   EnvironmentTransition;                             // 0x06E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsTransitionCompRemoved;                          // 0x06E8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6E9[0x7];                                      // 0x06E9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvironmentStaticActor">();
	}
	static class AEnvironmentStaticActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEnvironmentStaticActor>();
	}
};
static_assert(alignof(AEnvironmentStaticActor) == 0x000010, "Wrong alignment on AEnvironmentStaticActor");
static_assert(sizeof(AEnvironmentStaticActor) == 0x0006F0, "Wrong size on AEnvironmentStaticActor");
static_assert(offsetof(AEnvironmentStaticActor, MeshComponent) == 0x0006D8, "Member 'AEnvironmentStaticActor::MeshComponent' has a wrong offset!");
static_assert(offsetof(AEnvironmentStaticActor, EnvironmentTransition) == 0x0006E0, "Member 'AEnvironmentStaticActor::EnvironmentTransition' has a wrong offset!");
static_assert(offsetof(AEnvironmentStaticActor, bIsTransitionCompRemoved) == 0x0006E8, "Member 'AEnvironmentStaticActor::bIsTransitionCompRemoved' has a wrong offset!");

// Class MarvelLevel.EnvironmentPCGActor
// 0x0000 (0x06F0 - 0x06F0)
class AEnvironmentPCGActor final : public AEnvironmentStaticActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvironmentPCGActor">();
	}
	static class AEnvironmentPCGActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEnvironmentPCGActor>();
	}
};
static_assert(alignof(AEnvironmentPCGActor) == 0x000010, "Wrong alignment on AEnvironmentPCGActor");
static_assert(sizeof(AEnvironmentPCGActor) == 0x0006F0, "Wrong size on AEnvironmentPCGActor");

// Class MarvelLevel.FillColorBox
// 0x0010 (0x06F0 - 0x06E0)
class AFillColorBox : public AActor
{
public:
	TArray<uint64>                                FillColorStateList;                                // 0x06D8(0x0010)(Net, ZeroConstructor, RepNotify, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_6E8[0x8];                                      // 0x06E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FPaintSceneReconnectRebuildData GeneratePaintSceneRebuildData();
	TArray<int32> GetItemsState(const int32 InArrayLength);
	void InitializeItems(const int32 InArrayLength);
	void OnRep_FillColorStateList();
	void ReceiveDataForPy();
	void RewindForReplayForPy();
	void UpdateItemState(const TArray<int32>& ArrayIndexList, const int32 NewState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FillColorBox">();
	}
	static class AFillColorBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFillColorBox>();
	}
};
static_assert(alignof(AFillColorBox) == 0x000010, "Wrong alignment on AFillColorBox");
static_assert(sizeof(AFillColorBox) == 0x0006F0, "Wrong size on AFillColorBox");
static_assert(offsetof(AFillColorBox, FillColorStateList) == 0x0006D8, "Member 'AFillColorBox::FillColorStateList' has a wrong offset!");

// Class MarvelLevel.FillColorBoxV2
// 0x0000 (0x06F0 - 0x06F0)
class AFillColorBoxV2 final : public AFillColorBox
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FillColorBoxV2">();
	}
	static class AFillColorBoxV2* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFillColorBoxV2>();
	}
};
static_assert(alignof(AFillColorBoxV2) == 0x000010, "Wrong alignment on AFillColorBoxV2");
static_assert(sizeof(AFillColorBoxV2) == 0x0006F0, "Wrong size on AFillColorBoxV2");

// Class MarvelLevel.FillColorPoint
// 0x0000 (0x06E0 - 0x06E0)
class AFillColorPoint final : public AActor
{
public:
	void FillColor(EBattleSide BattleSide);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FillColorPoint">();
	}
	static class AFillColorPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFillColorPoint>();
	}
};
static_assert(alignof(AFillColorPoint) == 0x000010, "Wrong alignment on AFillColorPoint");
static_assert(sizeof(AFillColorPoint) == 0x0006E0, "Wrong size on AFillColorPoint");

// Class MarvelLevel.LevelAnimBaseActor
// 0x0000 (0x06E0 - 0x06E0)
class ALevelAnimBaseActor : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LevelAnimBaseActor">();
	}
	static class ALevelAnimBaseActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALevelAnimBaseActor>();
	}
};
static_assert(alignof(ALevelAnimBaseActor) == 0x000010, "Wrong alignment on ALevelAnimBaseActor");
static_assert(sizeof(ALevelAnimBaseActor) == 0x0006E0, "Wrong size on ALevelAnimBaseActor");

// Class MarvelLevel.LevelAnimMovementComponent
// 0x0250 (0x03F0 - 0x01A0)
class ULevelAnimMovementComponent final : public UMovementComponent
{
public:
	TMulticastInlineDelegate<void(class UPrimitiveComponent* NewBase, struct FHitResult* FloorHitResult)> OnMovementBaseChanged; // 0x01A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bTickPoseOnDS;                                     // 0x01B0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bCanUpdateFromRootMotion : 1;                      // 0x01B1(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bEnableKinematic : 1;                              // 0x01B1(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_1B2[0x6];                                      // 0x01B2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class AMarvelLevelAnimBaseActor*              LevelAnimOwner;                                    // 0x01B8(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPrimitiveComponent*                    MovementBase;                                      // 0x01C0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FHitResult                             FloorHitResult;                                    // 0x01C8(0x01F0)(Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	ELevelAnimMoveMode                            MovementMode;                                      // 0x03B8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3B9[0x3];                                      // 0x03B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GravityScale;                                      // 0x03BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                GravityDirection;                                  // 0x03C0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LocalGravityZ;                                     // 0x03D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableSlide;                                      // 0x03DC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3DD[0x3];                                      // 0x03DD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ValidAngle;                                        // 0x03E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SweepDeltaValue;                                   // 0x03E4(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ELevelAnimMoveMode                            InitMovementMode;                                  // 0x03E8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3E9[0x7];                                      // 0x03E9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LevelAnimMovementComponent">();
	}
	static class ULevelAnimMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULevelAnimMovementComponent>();
	}
};
static_assert(alignof(ULevelAnimMovementComponent) == 0x000008, "Wrong alignment on ULevelAnimMovementComponent");
static_assert(sizeof(ULevelAnimMovementComponent) == 0x0003F0, "Wrong size on ULevelAnimMovementComponent");
static_assert(offsetof(ULevelAnimMovementComponent, OnMovementBaseChanged) == 0x0001A0, "Member 'ULevelAnimMovementComponent::OnMovementBaseChanged' has a wrong offset!");
static_assert(offsetof(ULevelAnimMovementComponent, bTickPoseOnDS) == 0x0001B0, "Member 'ULevelAnimMovementComponent::bTickPoseOnDS' has a wrong offset!");
static_assert(offsetof(ULevelAnimMovementComponent, LevelAnimOwner) == 0x0001B8, "Member 'ULevelAnimMovementComponent::LevelAnimOwner' has a wrong offset!");
static_assert(offsetof(ULevelAnimMovementComponent, MovementBase) == 0x0001C0, "Member 'ULevelAnimMovementComponent::MovementBase' has a wrong offset!");
static_assert(offsetof(ULevelAnimMovementComponent, FloorHitResult) == 0x0001C8, "Member 'ULevelAnimMovementComponent::FloorHitResult' has a wrong offset!");
static_assert(offsetof(ULevelAnimMovementComponent, MovementMode) == 0x0003B8, "Member 'ULevelAnimMovementComponent::MovementMode' has a wrong offset!");
static_assert(offsetof(ULevelAnimMovementComponent, GravityScale) == 0x0003BC, "Member 'ULevelAnimMovementComponent::GravityScale' has a wrong offset!");
static_assert(offsetof(ULevelAnimMovementComponent, GravityDirection) == 0x0003C0, "Member 'ULevelAnimMovementComponent::GravityDirection' has a wrong offset!");
static_assert(offsetof(ULevelAnimMovementComponent, LocalGravityZ) == 0x0003D8, "Member 'ULevelAnimMovementComponent::LocalGravityZ' has a wrong offset!");
static_assert(offsetof(ULevelAnimMovementComponent, bEnableSlide) == 0x0003DC, "Member 'ULevelAnimMovementComponent::bEnableSlide' has a wrong offset!");
static_assert(offsetof(ULevelAnimMovementComponent, ValidAngle) == 0x0003E0, "Member 'ULevelAnimMovementComponent::ValidAngle' has a wrong offset!");
static_assert(offsetof(ULevelAnimMovementComponent, SweepDeltaValue) == 0x0003E4, "Member 'ULevelAnimMovementComponent::SweepDeltaValue' has a wrong offset!");
static_assert(offsetof(ULevelAnimMovementComponent, InitMovementMode) == 0x0003E8, "Member 'ULevelAnimMovementComponent::InitMovementMode' has a wrong offset!");

// Class MarvelLevel.LevelAudioActor
// 0x0000 (0x06E0 - 0x06E0)
class ALevelAudioActor : public AActor
{
public:
	class UAkComponent* PyGetDefaultAkComponent();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LevelAudioActor">();
	}
	static class ALevelAudioActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALevelAudioActor>();
	}
};
static_assert(alignof(ALevelAudioActor) == 0x000010, "Wrong alignment on ALevelAudioActor");
static_assert(sizeof(ALevelAudioActor) == 0x0006E0, "Wrong size on ALevelAudioActor");

// Class MarvelLevel.LevelBlockActor
// 0x0010 (0x06F0 - 0x06E0)
class ALevelBlockActor : public AMarvelLevelActorBase
{
public:
	uint8                                         bIsBlockPawn : 1;                                  // 0x06D8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsBlockAttack : 1;                                // 0x06D8(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_6D9[0x7];                                      // 0x06D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EBattleSide>                           IgnoreBattleSides;                                 // 0x06E0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void UpdateMaskFilter();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LevelBlockActor">();
	}
	static class ALevelBlockActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALevelBlockActor>();
	}
};
static_assert(alignof(ALevelBlockActor) == 0x000010, "Wrong alignment on ALevelBlockActor");
static_assert(sizeof(ALevelBlockActor) == 0x0006F0, "Wrong size on ALevelBlockActor");
static_assert(offsetof(ALevelBlockActor, IgnoreBattleSides) == 0x0006E0, "Member 'ALevelBlockActor::IgnoreBattleSides' has a wrong offset!");

// Class MarvelLevel.LevelBlockFlyPersistent
// 0x0070 (0x13E0 - 0x1370)
class ULevelBlockFlyPersistent final : public UMarvelEffectGameplayAbility
{
public:
	int32                                         FlyModeID;                                         // 0x1370(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1374[0x6C];                                    // 0x1374(0x006C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LevelBlockFlyPersistent">();
	}
	static class ULevelBlockFlyPersistent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULevelBlockFlyPersistent>();
	}
};
static_assert(alignof(ULevelBlockFlyPersistent) == 0x000008, "Wrong alignment on ULevelBlockFlyPersistent");
static_assert(sizeof(ULevelBlockFlyPersistent) == 0x0013E0, "Wrong size on ULevelBlockFlyPersistent");
static_assert(offsetof(ULevelBlockFlyPersistent, FlyModeID) == 0x001370, "Member 'ULevelBlockFlyPersistent::FlyModeID' has a wrong offset!");

// Class MarvelLevel.LevelCustomEventSubsystem
// 0x0000 (0x0038 - 0x0038)
class ULevelCustomEventSubsystem : public UWorldSubsystem
{
public:
	static class ULevelCustomEventSubsystem* GetLevelCustomEventSubsystem(const class UObject* WorldContextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LevelCustomEventSubsystem">();
	}
	static class ULevelCustomEventSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULevelCustomEventSubsystem>();
	}
};
static_assert(alignof(ULevelCustomEventSubsystem) == 0x000008, "Wrong alignment on ULevelCustomEventSubsystem");
static_assert(sizeof(ULevelCustomEventSubsystem) == 0x000038, "Wrong size on ULevelCustomEventSubsystem");

// Class MarvelLevel.LevelFunctionLibrary
// 0x0000 (0x0030 - 0x0030)
class ULevelFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void DestroyServerConnection(class UObject* WorldContextObject, bool bResetNetGUIDs, bool bCleanPC);
	static void DestroySomeNetObjects(class UObject* WorldContextObject);
	static void DestroyWorldNetDrive(class UObject* WorldContextObject);
	static void DestroyWorldNetDriver(class UObject* WorldContextObject);
	static int32 FindDeathCollectionIndex(class UObject* WorldContextObject);
	static class UMovieSceneTrack* FindMovieSceneTrack(class UMovieScene* InMovieScene, TSubclassOf<class UMovieSceneTrack> TrackClass, const struct FGuid& ObjectGuid, const class FName& TrackName);
	static void GetAllActorsWithTagInWorld(class UObject* WorldContextObject, const TArray<class FName>& Tags, TMap<class FName, struct FActorsWithSameOneTag>* OutActors);
	static TArray<class FString> GetAllLevelAlwaysLoadedRelatedAssetPaths(class UWorld* InWorld);
	static TArray<class FString> GetAllLevelAssetPaths(class UWorld* InWorld);
	static TArray<class UClass*> GetDerivedUClasses(const class UClass* ClassToLookFor, bool bRecursive);
	static class UGameInstanceSubsystem* GetGameInstanceSubsystem(const class UObject* WorldContextObject, TSubclassOf<class UGameInstanceSubsystem> SubsystemClass);
	static int32 GetM2201ForceFullPurgeInterval();
	static int32 GetM2201FullPurgeInterval();
	static int32 GetM2201FullPurgeMemoryPS4ThresholdMB();
	static int32 GetM2201FullPurgeMemoryThresholdMB();
	static int32 GetM2201IncrementalPurgeInterval();
	static int32 GetM2201IncrementalPurgeMemoryThresholdMB();
	static float GetSequenceLength(class ULevelSequence* LevelSequence);
	static float GetSequencePlayerCurrentTime(class ULevelSequencePlayer* LevelSequencePlayer);
	static bool IsActorInAABBRange(const struct FTransform& LocalTransform, const struct FVector& BorderHalfSize, class AMarvelBaseCharacter* InActor);
	static bool IsEnableLevelAsyncLoadInQueue();
	static void LevelSetClientTravel(class UObject* WorldContextObject, const class FString& NextURLString);
	static TArray<class UObject*> LocateBoundObjects(class ULevelSequence* InLevelSequence, const struct FGuid& InObjectId, class UObject* InContext);
	static TArray<struct FVector> MeshData(const class UStaticMeshComponent* StaticMeshComponent);
	static void ModifyLevelFoliageMaterial();
	static void SequencePlayerJumpTo(class ULevelSequencePlayer* LevelSequencePlayer, float TargetTime);
	static void SequencePlayerJumpToSkippingSpawn(class ULevelSequencePlayer* LevelSequencePlayer, float TargetTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LevelFunctionLibrary">();
	}
	static class ULevelFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULevelFunctionLibrary>();
	}
};
static_assert(alignof(ULevelFunctionLibrary) == 0x000008, "Wrong alignment on ULevelFunctionLibrary");
static_assert(sizeof(ULevelFunctionLibrary) == 0x000030, "Wrong size on ULevelFunctionLibrary");

// Class MarvelLevel.MarvelLevelSummonedBase
// 0x0030 (0x0B70 - 0x0B40)
#pragma pack(push, 0x1)
class alignas(0x10) AMarvelLevelSummonedBase : public AMarvelSummonerBase
{
public:
	uint8                                         Pad_B40[0x10];                                     // 0x0B40(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UTeamComponent*                         TeamComponent;                                     // 0x0B50(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHittable;                                         // 0x0B58(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B59[0x3];                                      // 0x0B59(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	EReplicationLevel                             ConfigRepLevel;                                    // 0x0B5C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConfigNetFrequency;                                // 0x0B60(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B64[0x4];                                      // 0x0B64(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetHittable(bool Hittable);
	void SetTriggerRepCheck();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelLevelSummonedBase">();
	}
	static class AMarvelLevelSummonedBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMarvelLevelSummonedBase>();
	}
};
#pragma pack(pop)
static_assert(alignof(AMarvelLevelSummonedBase) == 0x000010, "Wrong alignment on AMarvelLevelSummonedBase");
static_assert(sizeof(AMarvelLevelSummonedBase) == 0x000B70, "Wrong size on AMarvelLevelSummonedBase");
static_assert(offsetof(AMarvelLevelSummonedBase, TeamComponent) == 0x000B50, "Member 'AMarvelLevelSummonedBase::TeamComponent' has a wrong offset!");
static_assert(offsetof(AMarvelLevelSummonedBase, bHittable) == 0x000B58, "Member 'AMarvelLevelSummonedBase::bHittable' has a wrong offset!");
static_assert(offsetof(AMarvelLevelSummonedBase, ConfigRepLevel) == 0x000B5C, "Member 'AMarvelLevelSummonedBase::ConfigRepLevel' has a wrong offset!");
static_assert(offsetof(AMarvelLevelSummonedBase, ConfigNetFrequency) == 0x000B60, "Member 'AMarvelLevelSummonedBase::ConfigNetFrequency' has a wrong offset!");

// Class MarvelLevel.LevelGravityElevator
// 0x0200 (0x0D70 - 0x0B70)
class ALevelGravityElevator final : public AMarvelLevelSummonedBase
{
public:
	int32                                         Priority;                                          // 0x0B68(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         GravityElevatorEffectID;                           // 0x0B6C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GravityDurationTime;                               // 0x0B70(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         EndPointKnockUpEffectID;                           // 0x0B74(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinBrakingFriction;                                // 0x0B78(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinBrakingDecelerationFalling;                     // 0x0B7C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinBrakingDecelerationFlying;                      // 0x0B80(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B84[0x4];                                      // 0x0B84(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                PathConveyedVelocity;                              // 0x0B88(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                PathConveyedEndPoint;                              // 0x0BA0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GapTime;                                           // 0x0BB8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_BBC[0x4];                                      // 0x0BBC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  IgnoreTags;                                        // 0x0BC0(0x0068)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  RequireTags;                                       // 0x0C28(0x0068)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	float                                         TimeInterval;                                      // 0x0C90(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C94[0x1C];                                     // 0x0C94(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, struct FActiveGameplayEffectHandle> CharacterEffectDict;                             // 0x0CB0(0x0050)(Protected, NativeAccessSpecifierProtected)
	TArray<class AMarvelBaseCharacter*>           InsideCharacter;                                   // 0x0D00(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TMap<int32, float>                            EffectTimeDict;                                    // 0x0D10(0x0050)(Protected, NativeAccessSpecifierProtected)
	class UBoxComponent*                          BoxComponent;                                      // 0x0D60(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D68[0x8];                                      // 0x0D68(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FVector GetPathVelocity(const struct FVector& InVelocity, class UPrimitiveComponent* UpdatedComponent, const struct FVector& InGravity, float DeltaTime, EMovementMode MovementMode) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LevelGravityElevator">();
	}
	static class ALevelGravityElevator* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALevelGravityElevator>();
	}
};
static_assert(alignof(ALevelGravityElevator) == 0x000010, "Wrong alignment on ALevelGravityElevator");
static_assert(sizeof(ALevelGravityElevator) == 0x000D70, "Wrong size on ALevelGravityElevator");
static_assert(offsetof(ALevelGravityElevator, Priority) == 0x000B68, "Member 'ALevelGravityElevator::Priority' has a wrong offset!");
static_assert(offsetof(ALevelGravityElevator, GravityElevatorEffectID) == 0x000B6C, "Member 'ALevelGravityElevator::GravityElevatorEffectID' has a wrong offset!");
static_assert(offsetof(ALevelGravityElevator, GravityDurationTime) == 0x000B70, "Member 'ALevelGravityElevator::GravityDurationTime' has a wrong offset!");
static_assert(offsetof(ALevelGravityElevator, EndPointKnockUpEffectID) == 0x000B74, "Member 'ALevelGravityElevator::EndPointKnockUpEffectID' has a wrong offset!");
static_assert(offsetof(ALevelGravityElevator, MinBrakingFriction) == 0x000B78, "Member 'ALevelGravityElevator::MinBrakingFriction' has a wrong offset!");
static_assert(offsetof(ALevelGravityElevator, MinBrakingDecelerationFalling) == 0x000B7C, "Member 'ALevelGravityElevator::MinBrakingDecelerationFalling' has a wrong offset!");
static_assert(offsetof(ALevelGravityElevator, MinBrakingDecelerationFlying) == 0x000B80, "Member 'ALevelGravityElevator::MinBrakingDecelerationFlying' has a wrong offset!");
static_assert(offsetof(ALevelGravityElevator, PathConveyedVelocity) == 0x000B88, "Member 'ALevelGravityElevator::PathConveyedVelocity' has a wrong offset!");
static_assert(offsetof(ALevelGravityElevator, PathConveyedEndPoint) == 0x000BA0, "Member 'ALevelGravityElevator::PathConveyedEndPoint' has a wrong offset!");
static_assert(offsetof(ALevelGravityElevator, GapTime) == 0x000BB8, "Member 'ALevelGravityElevator::GapTime' has a wrong offset!");
static_assert(offsetof(ALevelGravityElevator, IgnoreTags) == 0x000BC0, "Member 'ALevelGravityElevator::IgnoreTags' has a wrong offset!");
static_assert(offsetof(ALevelGravityElevator, RequireTags) == 0x000C28, "Member 'ALevelGravityElevator::RequireTags' has a wrong offset!");
static_assert(offsetof(ALevelGravityElevator, TimeInterval) == 0x000C90, "Member 'ALevelGravityElevator::TimeInterval' has a wrong offset!");
static_assert(offsetof(ALevelGravityElevator, CharacterEffectDict) == 0x000CB0, "Member 'ALevelGravityElevator::CharacterEffectDict' has a wrong offset!");
static_assert(offsetof(ALevelGravityElevator, InsideCharacter) == 0x000D00, "Member 'ALevelGravityElevator::InsideCharacter' has a wrong offset!");
static_assert(offsetof(ALevelGravityElevator, EffectTimeDict) == 0x000D10, "Member 'ALevelGravityElevator::EffectTimeDict' has a wrong offset!");
static_assert(offsetof(ALevelGravityElevator, BoxComponent) == 0x000D60, "Member 'ALevelGravityElevator::BoxComponent' has a wrong offset!");

// Class MarvelLevel.LevelGravityElevatorAbility
// 0x0000 (0x1370 - 0x1370)
class ULevelGravityElevatorAbility final : public UMarvelEffectGameplayAbility
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LevelGravityElevatorAbility">();
	}
	static class ULevelGravityElevatorAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULevelGravityElevatorAbility>();
	}
};
static_assert(alignof(ULevelGravityElevatorAbility) == 0x000008, "Wrong alignment on ULevelGravityElevatorAbility");
static_assert(sizeof(ULevelGravityElevatorAbility) == 0x001370, "Wrong size on ULevelGravityElevatorAbility");

// Class MarvelLevel.LevelGravityZoneGameplayEffectComponent
// 0x0048 (0x0078 - 0x0030)
class ULevelGravityZoneGameplayEffectComponent final : public UGameplayEffectComponent
{
public:
	struct FGameplayTagQuery                      BeDispelledQuery;                                  // 0x0030(0x0048)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LevelGravityZoneGameplayEffectComponent">();
	}
	static class ULevelGravityZoneGameplayEffectComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULevelGravityZoneGameplayEffectComponent>();
	}
};
static_assert(alignof(ULevelGravityZoneGameplayEffectComponent) == 0x000008, "Wrong alignment on ULevelGravityZoneGameplayEffectComponent");
static_assert(sizeof(ULevelGravityZoneGameplayEffectComponent) == 0x000078, "Wrong size on ULevelGravityZoneGameplayEffectComponent");
static_assert(offsetof(ULevelGravityZoneGameplayEffectComponent, BeDispelledQuery) == 0x000030, "Member 'ULevelGravityZoneGameplayEffectComponent::BeDispelledQuery' has a wrong offset!");

// Class MarvelLevel.LevelGravityZoneEffectTemplate
// 0x0000 (0x1438 - 0x1438)
class ULevelGravityZoneEffectTemplate : public UMarvelGameplayEffectTemplate
{
public:
	bool IsDispelledByAbility(const struct FGameplayTagContainer& AbilityTags);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LevelGravityZoneEffectTemplate">();
	}
	static class ULevelGravityZoneEffectTemplate* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULevelGravityZoneEffectTemplate>();
	}
};
static_assert(alignof(ULevelGravityZoneEffectTemplate) == 0x000008, "Wrong alignment on ULevelGravityZoneEffectTemplate");
static_assert(sizeof(ULevelGravityZoneEffectTemplate) == 0x001438, "Wrong size on ULevelGravityZoneEffectTemplate");

// Class MarvelLevel.Ability_200401
// 0x0000 (0x2B10 - 0x2B10)
class UAbility_200401 : public UMarvelAeroBaseAbility
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ability_200401">();
	}
	static class UAbility_200401* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbility_200401>();
	}
};
static_assert(alignof(UAbility_200401) == 0x000008, "Wrong alignment on UAbility_200401");
static_assert(sizeof(UAbility_200401) == 0x002B10, "Wrong size on UAbility_200401");

// Class MarvelLevel.LevelLightControlActor
// 0x0060 (0x0740 - 0x06E0)
class ALevelLightControlActor final : public AActor
{
public:
	TArray<class FName>                           LightActorTags;                                    // 0x06D8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	int32                                         FramingNumber;                                     // 0x06E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FlashRate;                                         // 0x06EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxIntensityLight;                                 // 0x06F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinIntensityLight;                                 // 0x06F4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6F8[0x48];                                     // 0x06F8(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HideLights();
	void Initialize();
	void StartChangeLights();
	void StopChangeLights();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LevelLightControlActor">();
	}
	static class ALevelLightControlActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALevelLightControlActor>();
	}
};
static_assert(alignof(ALevelLightControlActor) == 0x000010, "Wrong alignment on ALevelLightControlActor");
static_assert(sizeof(ALevelLightControlActor) == 0x000740, "Wrong size on ALevelLightControlActor");
static_assert(offsetof(ALevelLightControlActor, LightActorTags) == 0x0006D8, "Member 'ALevelLightControlActor::LightActorTags' has a wrong offset!");
static_assert(offsetof(ALevelLightControlActor, FramingNumber) == 0x0006E8, "Member 'ALevelLightControlActor::FramingNumber' has a wrong offset!");
static_assert(offsetof(ALevelLightControlActor, FlashRate) == 0x0006EC, "Member 'ALevelLightControlActor::FlashRate' has a wrong offset!");
static_assert(offsetof(ALevelLightControlActor, MaxIntensityLight) == 0x0006F0, "Member 'ALevelLightControlActor::MaxIntensityLight' has a wrong offset!");
static_assert(offsetof(ALevelLightControlActor, MinIntensityLight) == 0x0006F4, "Member 'ALevelLightControlActor::MinIntensityLight' has a wrong offset!");

// Class MarvelLevel.LevelPackageRulesFuncLibrary
// 0x0000 (0x0030 - 0x0030)
class ULevelPackageRulesFuncLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void UpdatePackageDataTables();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LevelPackageRulesFuncLibrary">();
	}
	static class ULevelPackageRulesFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULevelPackageRulesFuncLibrary>();
	}
};
static_assert(alignof(ULevelPackageRulesFuncLibrary) == 0x000008, "Wrong alignment on ULevelPackageRulesFuncLibrary");
static_assert(sizeof(ULevelPackageRulesFuncLibrary) == 0x000030, "Wrong size on ULevelPackageRulesFuncLibrary");

// Class MarvelLevel.LevelPortal
// 0x0000 (0x06E0 - 0x06E0)
class ALevelPortal : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LevelPortal">();
	}
	static class ALevelPortal* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALevelPortal>();
	}
};
static_assert(alignof(ALevelPortal) == 0x000010, "Wrong alignment on ALevelPortal");
static_assert(sizeof(ALevelPortal) == 0x0006E0, "Wrong size on ALevelPortal");

// Class MarvelLevel.LevelStaticMeshActor
// 0x0000 (0x06E0 - 0x06E0)
class ALevelStaticMeshActor final : public AActor
{
public:
	TArray<struct FVector> MeshData(const class UStaticMeshComponent* StaticMeshComponent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LevelStaticMeshActor">();
	}
	static class ALevelStaticMeshActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALevelStaticMeshActor>();
	}
};
static_assert(alignof(ALevelStaticMeshActor) == 0x000010, "Wrong alignment on ALevelStaticMeshActor");
static_assert(sizeof(ALevelStaticMeshActor) == 0x0006E0, "Wrong size on ALevelStaticMeshActor");

// Class MarvelLevel.LevelTransportPipe
// 0x0000 (0x0B70 - 0x0B70)
class ALevelTransportPipe final : public AMarvelLevelSummonedBase
{
public:
	bool GetKnockUp(struct FPhysicForceMove* OutPhysicKnockUp) const;
	struct FVector GetPathVelocity(const struct FVector& InVelocity, class UPrimitiveComponent* UpdatedComponent, const struct FVector& InGravity, float DeltaTime, EMovementMode MovementMode) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LevelTransportPipe">();
	}
	static class ALevelTransportPipe* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALevelTransportPipe>();
	}
};
static_assert(alignof(ALevelTransportPipe) == 0x000010, "Wrong alignment on ALevelTransportPipe");
static_assert(sizeof(ALevelTransportPipe) == 0x000B70, "Wrong size on ALevelTransportPipe");

// Class MarvelLevel.LevelViewCheckComponent
// 0x0000 (0x0340 - 0x0340)
class ULevelViewCheckComponent : public USceneComponent
{
public:
	float                                         Radius;                                            // 0x0338(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SkipCheckInBattleState;                            // 0x033C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_33D[0x3];                                      // 0x033D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CheckInView();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LevelViewCheckComponent">();
	}
	static class ULevelViewCheckComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULevelViewCheckComponent>();
	}
};
static_assert(alignof(ULevelViewCheckComponent) == 0x000010, "Wrong alignment on ULevelViewCheckComponent");
static_assert(sizeof(ULevelViewCheckComponent) == 0x000340, "Wrong size on ULevelViewCheckComponent");
static_assert(offsetof(ULevelViewCheckComponent, Radius) == 0x000338, "Member 'ULevelViewCheckComponent::Radius' has a wrong offset!");
static_assert(offsetof(ULevelViewCheckComponent, SkipCheckInBattleState) == 0x00033C, "Member 'ULevelViewCheckComponent::SkipCheckInBattleState' has a wrong offset!");

// Class MarvelLevel.MarvelAbilitiesRuleComponent
// 0x0010 (0x0118 - 0x0108)
class UMarvelAbilitiesRuleComponent : public URuleComponent
{
public:
	uint8                                         Pad_108[0x10];                                     // 0x0108(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitConfigRule(class UMarvelAbilitiesLevelConfig* InConfig);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelAbilitiesRuleComponent">();
	}
	static class UMarvelAbilitiesRuleComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMarvelAbilitiesRuleComponent>();
	}
};
static_assert(alignof(UMarvelAbilitiesRuleComponent) == 0x000008, "Wrong alignment on UMarvelAbilitiesRuleComponent");
static_assert(sizeof(UMarvelAbilitiesRuleComponent) == 0x000118, "Wrong size on UMarvelAbilitiesRuleComponent");

// Class MarvelLevel.MarvelAudioCondition
// 0x0000 (0x0030 - 0x0030)
class UMarvelAudioCondition : public UObject
{
public:
	void PyPostEditChange();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelAudioCondition">();
	}
	static class UMarvelAudioCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMarvelAudioCondition>();
	}
};
static_assert(alignof(UMarvelAudioCondition) == 0x000008, "Wrong alignment on UMarvelAudioCondition");
static_assert(sizeof(UMarvelAudioCondition) == 0x000030, "Wrong size on UMarvelAudioCondition");

// Class MarvelLevel.MarvelLevelAnimActionComponent
// 0x0180 (0x0288 - 0x0108)
class UMarvelLevelAnimActionComponent final : public UActorComponent
{
public:
	TArray<struct FMarvelLevelAnimAction>         LevelAnimActions;                                  // 0x0108(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 MeshComponent;                                     // 0x0118(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULevelAnimMovementComponent*            MovementComponent;                                 // 0x0120(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ReplicatedActionIndex;                             // 0x0128(0x0004)(Edit, Net, ZeroConstructor, EditConst, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_12C[0x1C];                                     // 0x012C(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         WeakLinkingInteractableActors;                     // 0x0148(0x0010)(Edit, BlueprintVisible, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_158[0x130];                                    // 0x0158(0x0130)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnApplyHit(class AActor* InSourceAvatar);
	void OnLinkClientGCBreak();
	void OnLinkGCBreak(const struct FChaosBreakEvent& BreakEvent);
	void OnLinkGCIgnoreBreak(const int32& Index_0, const float& ServerTime);
	void OnMovementBaseChanged(class UPrimitiveComponent* NewBase, struct FHitResult* FloorHitResult);
	void OnRep_ReplicatedActionIndex();
	void OnServerSimulateMontageSectionEnded();
	void ResetForLevelSwitch();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelLevelAnimActionComponent">();
	}
	static class UMarvelLevelAnimActionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMarvelLevelAnimActionComponent>();
	}
};
static_assert(alignof(UMarvelLevelAnimActionComponent) == 0x000008, "Wrong alignment on UMarvelLevelAnimActionComponent");
static_assert(sizeof(UMarvelLevelAnimActionComponent) == 0x000288, "Wrong size on UMarvelLevelAnimActionComponent");
static_assert(offsetof(UMarvelLevelAnimActionComponent, LevelAnimActions) == 0x000108, "Member 'UMarvelLevelAnimActionComponent::LevelAnimActions' has a wrong offset!");
static_assert(offsetof(UMarvelLevelAnimActionComponent, MeshComponent) == 0x000118, "Member 'UMarvelLevelAnimActionComponent::MeshComponent' has a wrong offset!");
static_assert(offsetof(UMarvelLevelAnimActionComponent, MovementComponent) == 0x000120, "Member 'UMarvelLevelAnimActionComponent::MovementComponent' has a wrong offset!");
static_assert(offsetof(UMarvelLevelAnimActionComponent, ReplicatedActionIndex) == 0x000128, "Member 'UMarvelLevelAnimActionComponent::ReplicatedActionIndex' has a wrong offset!");
static_assert(offsetof(UMarvelLevelAnimActionComponent, WeakLinkingInteractableActors) == 0x000148, "Member 'UMarvelLevelAnimActionComponent::WeakLinkingInteractableActors' has a wrong offset!");

// Class MarvelLevel.MarvelLevelAnimActor
// 0x0030 (0x0710 - 0x06E0)
class AMarvelLevelAnimActor final : public AMarvelLevelAnimBaseActor
{
public:
	class UCapsuleComponent*                      CapsuleComponent;                                  // 0x06E0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 MeshComponent;                                     // 0x06E8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULevelOptimizationComponent*            LevelOptimizationComp;                             // 0x06F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMarvelLevelAnimActionComponent*        ActionComponent;                                   // 0x06F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULevelAnimMovementComponent*            MovementComponent;                                 // 0x0700(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_708[0x8];                                      // 0x0708(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAllRequiredMapLoaded();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelLevelAnimActor">();
	}
	static class AMarvelLevelAnimActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMarvelLevelAnimActor>();
	}
};
static_assert(alignof(AMarvelLevelAnimActor) == 0x000010, "Wrong alignment on AMarvelLevelAnimActor");
static_assert(sizeof(AMarvelLevelAnimActor) == 0x000710, "Wrong size on AMarvelLevelAnimActor");
static_assert(offsetof(AMarvelLevelAnimActor, CapsuleComponent) == 0x0006E0, "Member 'AMarvelLevelAnimActor::CapsuleComponent' has a wrong offset!");
static_assert(offsetof(AMarvelLevelAnimActor, MeshComponent) == 0x0006E8, "Member 'AMarvelLevelAnimActor::MeshComponent' has a wrong offset!");
static_assert(offsetof(AMarvelLevelAnimActor, LevelOptimizationComp) == 0x0006F0, "Member 'AMarvelLevelAnimActor::LevelOptimizationComp' has a wrong offset!");
static_assert(offsetof(AMarvelLevelAnimActor, ActionComponent) == 0x0006F8, "Member 'AMarvelLevelAnimActor::ActionComponent' has a wrong offset!");
static_assert(offsetof(AMarvelLevelAnimActor, MovementComponent) == 0x000700, "Member 'AMarvelLevelAnimActor::MovementComponent' has a wrong offset!");

// Class MarvelLevel.MarvelLevelAudioItem
// 0x0000 (0x0038 - 0x0038)
class UMarvelLevelAudioItem : public UPrimaryDataAsset
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelLevelAudioItem">();
	}
	static class UMarvelLevelAudioItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMarvelLevelAudioItem>();
	}
};
static_assert(alignof(UMarvelLevelAudioItem) == 0x000008, "Wrong alignment on UMarvelLevelAudioItem");
static_assert(sizeof(UMarvelLevelAudioItem) == 0x000038, "Wrong size on UMarvelLevelAudioItem");

// Class MarvelLevel.MarvelLevelKnockUpAbility
// 0x0000 (0x2038 - 0x2038)
class UMarvelLevelKnockUpAbility : public UMarvelKnockUpAbility
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelLevelKnockUpAbility">();
	}
	static class UMarvelLevelKnockUpAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMarvelLevelKnockUpAbility>();
	}
};
static_assert(alignof(UMarvelLevelKnockUpAbility) == 0x000008, "Wrong alignment on UMarvelLevelKnockUpAbility");
static_assert(sizeof(UMarvelLevelKnockUpAbility) == 0x002038, "Wrong size on UMarvelLevelKnockUpAbility");

// Class MarvelLevel.MarvelLevelKrakoaPortalAbility
// 0x0000 (0x29F0 - 0x29F0)
class UMarvelLevelKrakoaPortalAbility : public UMarvelGameplayAbility
{
public:
	void K2_OnMoveLogicFrameExecute(class UCharacterMovementComponent* InOwnerMovementComponent, class AActor* TriggerPortal, class AActor* TargetPlayerStart);
	void K2_OnMoveLogicFrameReplayExecute(class UCharacterMovementComponent* InOwnerMovementComponent, class AActor* TriggerPortal, class AActor* TargetPlayerStart);
	struct FMoveLogicHandle RegisterTeleportMoveLogicFrame(const struct FPredictionKeyHandle& InChildPredictionKeyHandle, class UCharacterMovementComponent* InOwnerMovementComponent, bool bIsServerInitiated, class AActor* TriggerPortal, class AActor* TargetPlayerStart);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelLevelKrakoaPortalAbility">();
	}
	static class UMarvelLevelKrakoaPortalAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMarvelLevelKrakoaPortalAbility>();
	}
};
static_assert(alignof(UMarvelLevelKrakoaPortalAbility) == 0x000008, "Wrong alignment on UMarvelLevelKrakoaPortalAbility");
static_assert(sizeof(UMarvelLevelKrakoaPortalAbility) == 0x0029F0, "Wrong size on UMarvelLevelKrakoaPortalAbility");

// Class MarvelLevel.MarvelLevelSequenceActorBase
// 0x0000 (0x0780 - 0x0780)
class AMarvelLevelSequenceActorBase : public ALevelSequenceActor
{
public:
	void K2_PostNetLevelSequenceChanged();
	void K2_PostNetReceive();
	void K2_PreNetLevelSequenceChanged();
	void K2_PreRewindForReplay();
	void K2_ReceivePostBeginPlay();
	void K2_RewindForReplay();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelLevelSequenceActorBase">();
	}
	static class AMarvelLevelSequenceActorBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMarvelLevelSequenceActorBase>();
	}
};
static_assert(alignof(AMarvelLevelSequenceActorBase) == 0x000010, "Wrong alignment on AMarvelLevelSequenceActorBase");
static_assert(sizeof(AMarvelLevelSequenceActorBase) == 0x000780, "Wrong size on AMarvelLevelSequenceActorBase");

// Class MarvelLevel.MarvelLevelPortalBase
// 0x0140 (0x08C0 - 0x0780)
class AMarvelLevelPortalBase : public AMarvelLevelSequenceActorBase
{
public:
	TMulticastInlineDelegate<void(class AMarvelLevelPortalBase* Portal, bool bActivated)> OnLevelPortalActivationChanged; // 0x0780(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bLevelPortalActivated;                             // 0x0790(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_791[0x7];                                      // 0x0791(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPortalPlayerUsageRecordContainer      PlayerUsageRecords;                                // 0x0798(0x0128)(Net, Transient, Protected, NativeAccessSpecifierProtected)

public:
	double GetPlayerLastUseServerTime(const int32& UID);
	void K2_OnPostReplicatedAddPlayerUsageRecord(const int32& UID, const double& LastUseServerTimeSeconds);
	void K2_OnPostReplicatedChangePlayerUsageRecord(const int32& UID, const double& LastUseServerTimeSeconds);
	void S_ClearPlayerLastUseServerTimeRecords();
	void S_RemovePlayerLastUseServerTime(const int32& UID);
	void S_SetPlayerLastUseServerTime(const int32& UID, const double& LastUseServerTimeSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelLevelPortalBase">();
	}
	static class AMarvelLevelPortalBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMarvelLevelPortalBase>();
	}
};
static_assert(alignof(AMarvelLevelPortalBase) == 0x000010, "Wrong alignment on AMarvelLevelPortalBase");
static_assert(sizeof(AMarvelLevelPortalBase) == 0x0008C0, "Wrong size on AMarvelLevelPortalBase");
static_assert(offsetof(AMarvelLevelPortalBase, OnLevelPortalActivationChanged) == 0x000780, "Member 'AMarvelLevelPortalBase::OnLevelPortalActivationChanged' has a wrong offset!");
static_assert(offsetof(AMarvelLevelPortalBase, bLevelPortalActivated) == 0x000790, "Member 'AMarvelLevelPortalBase::bLevelPortalActivated' has a wrong offset!");
static_assert(offsetof(AMarvelLevelPortalBase, PlayerUsageRecords) == 0x000798, "Member 'AMarvelLevelPortalBase::PlayerUsageRecords' has a wrong offset!");

// Class MarvelLevel.MarvelLevelProcessController
// 0x0000 (0x06E0 - 0x06E0)
class AMarvelLevelProcessController : public AMarvelLevelActorBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelLevelProcessController">();
	}
	static class AMarvelLevelProcessController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMarvelLevelProcessController>();
	}
};
static_assert(alignof(AMarvelLevelProcessController) == 0x000010, "Wrong alignment on AMarvelLevelProcessController");
static_assert(sizeof(AMarvelLevelProcessController) == 0x0006E0, "Wrong size on AMarvelLevelProcessController");

// Class MarvelLevel.MarvelLevelRuleControlBase
// 0x00A0 (0x01A8 - 0x0108)
class UMarvelLevelRuleControlBase : public UActorComponent
{
public:
	TMap<class FString, struct FTimerHandle>      LevelNodeDelayTimeMap;                             // 0x0108(0x0050)(NativeAccessSpecifierPublic)
	TMap<class FString, struct FTimerHandle>      LevelNodeRepeatTimeMap;                            // 0x0158(0x0050)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelLevelRuleControlBase">();
	}
	static class UMarvelLevelRuleControlBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMarvelLevelRuleControlBase>();
	}
};
static_assert(alignof(UMarvelLevelRuleControlBase) == 0x000008, "Wrong alignment on UMarvelLevelRuleControlBase");
static_assert(sizeof(UMarvelLevelRuleControlBase) == 0x0001A8, "Wrong size on UMarvelLevelRuleControlBase");
static_assert(offsetof(UMarvelLevelRuleControlBase, LevelNodeDelayTimeMap) == 0x000108, "Member 'UMarvelLevelRuleControlBase::LevelNodeDelayTimeMap' has a wrong offset!");
static_assert(offsetof(UMarvelLevelRuleControlBase, LevelNodeRepeatTimeMap) == 0x000158, "Member 'UMarvelLevelRuleControlBase::LevelNodeRepeatTimeMap' has a wrong offset!");

// Class MarvelLevel.MarvelLevelSummoned_StaticMesh
// 0x0000 (0x0B70 - 0x0B70)
class AMarvelLevelSummoned_StaticMesh final : public AMarvelLevelSummonedBase
{
public:
	class UStaticMeshComponent*                   SummonedStaticMesh;                                // 0x0B68(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelLevelSummoned_StaticMesh">();
	}
	static class AMarvelLevelSummoned_StaticMesh* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMarvelLevelSummoned_StaticMesh>();
	}
};
static_assert(alignof(AMarvelLevelSummoned_StaticMesh) == 0x000010, "Wrong alignment on AMarvelLevelSummoned_StaticMesh");
static_assert(sizeof(AMarvelLevelSummoned_StaticMesh) == 0x000B70, "Wrong size on AMarvelLevelSummoned_StaticMesh");
static_assert(offsetof(AMarvelLevelSummoned_StaticMesh, SummonedStaticMesh) == 0x000B68, "Member 'AMarvelLevelSummoned_StaticMesh::SummonedStaticMesh' has a wrong offset!");

// Class MarvelLevel.Cue_Buff_20000001
// 0x0000 (0x1640 - 0x1640)
class ACue_Buff_20000001 final : public AMarvelCueNotify_Buff
{
public:
	class UAkAudioEvent*                          AudioEvent;                                        // 0x1638(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cue_Buff_20000001">();
	}
	static class ACue_Buff_20000001* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACue_Buff_20000001>();
	}
};
static_assert(alignof(ACue_Buff_20000001) == 0x000010, "Wrong alignment on ACue_Buff_20000001");
static_assert(sizeof(ACue_Buff_20000001) == 0x001640, "Wrong size on ACue_Buff_20000001");
static_assert(offsetof(ACue_Buff_20000001, AudioEvent) == 0x001638, "Member 'ACue_Buff_20000001::AudioEvent' has a wrong offset!");

// Class MarvelLevel.MarvelLevelSummoned_20000010
// 0x0010 (0x0B80 - 0x0B70)
class AMarvelLevelSummoned_20000010 : public AMarvelLevelSummonedBase
{
public:
	TArray<class AActor*>                         ExOcclusionTargets;                                // 0x0B68(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_B78[0x8];                                      // 0x0B78(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelLevelSummoned_20000010">();
	}
	static class AMarvelLevelSummoned_20000010* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMarvelLevelSummoned_20000010>();
	}
};
static_assert(alignof(AMarvelLevelSummoned_20000010) == 0x000010, "Wrong alignment on AMarvelLevelSummoned_20000010");
static_assert(sizeof(AMarvelLevelSummoned_20000010) == 0x000B80, "Wrong size on AMarvelLevelSummoned_20000010");
static_assert(offsetof(AMarvelLevelSummoned_20000010, ExOcclusionTargets) == 0x000B68, "Member 'AMarvelLevelSummoned_20000010::ExOcclusionTargets' has a wrong offset!");

// Class MarvelLevel.MarvelLevelSummoned_20050101
// 0x0000 (0x0B70 - 0x0B70)
class AMarvelLevelSummoned_20050101 final : public AMarvelLevelSummonedBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelLevelSummoned_20050101">();
	}
	static class AMarvelLevelSummoned_20050101* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMarvelLevelSummoned_20050101>();
	}
};
static_assert(alignof(AMarvelLevelSummoned_20050101) == 0x000010, "Wrong alignment on AMarvelLevelSummoned_20050101");
static_assert(sizeof(AMarvelLevelSummoned_20050101) == 0x000B70, "Wrong size on AMarvelLevelSummoned_20050101");

// Class MarvelLevel.MarvelLevelSummoned_KnockUp
// 0x0050 (0x0BC0 - 0x0B70)
class AMarvelLevelSummoned_KnockUp : public AMarvelLevelSummonedBase
{
public:
	struct FPhysicForceMove                       PhysicKnockUp;                                     // 0x0B68(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	uint8                                         Pad_BB8[0x8];                                      // 0x0BB8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelLevelSummoned_KnockUp">();
	}
	static class AMarvelLevelSummoned_KnockUp* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMarvelLevelSummoned_KnockUp>();
	}
};
static_assert(alignof(AMarvelLevelSummoned_KnockUp) == 0x000010, "Wrong alignment on AMarvelLevelSummoned_KnockUp");
static_assert(sizeof(AMarvelLevelSummoned_KnockUp) == 0x000BC0, "Wrong size on AMarvelLevelSummoned_KnockUp");
static_assert(offsetof(AMarvelLevelSummoned_KnockUp, PhysicKnockUp) == 0x000B68, "Member 'AMarvelLevelSummoned_KnockUp::PhysicKnockUp' has a wrong offset!");

// Class MarvelLevel.MarvelRuleCondition
// 0x0000 (0x0030 - 0x0030)
class UMarvelRuleCondition : public UObject
{
public:
	void PyPostEditChange();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelRuleCondition">();
	}
	static class UMarvelRuleCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMarvelRuleCondition>();
	}
};
static_assert(alignof(UMarvelRuleCondition) == 0x000008, "Wrong alignment on UMarvelRuleCondition");
static_assert(sizeof(UMarvelRuleCondition) == 0x000030, "Wrong size on UMarvelRuleCondition");

// Class MarvelLevel.MarvelRuleConfig
// 0x0000 (0x0030 - 0x0030)
class UMarvelRuleConfig : public UObject
{
public:
	void PyPostEditChange();
	void PyPostInitProperties();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelRuleConfig">();
	}
	static class UMarvelRuleConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMarvelRuleConfig>();
	}
};
static_assert(alignof(UMarvelRuleConfig) == 0x000008, "Wrong alignment on UMarvelRuleConfig");
static_assert(sizeof(UMarvelRuleConfig) == 0x000030, "Wrong size on UMarvelRuleConfig");

// Class MarvelLevel.MarvelRuleControllerItem
// 0x0008 (0x0040 - 0x0038)
class UMarvelRuleControllerItem final : public UPrimaryDataAsset
{
public:
	TSubclassOf<class UMarvelLevelRuleControlBase> RuleControllerClass;                              // 0x0038(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelRuleControllerItem">();
	}
	static class UMarvelRuleControllerItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMarvelRuleControllerItem>();
	}
};
static_assert(alignof(UMarvelRuleControllerItem) == 0x000008, "Wrong alignment on UMarvelRuleControllerItem");
static_assert(sizeof(UMarvelRuleControllerItem) == 0x000040, "Wrong size on UMarvelRuleControllerItem");
static_assert(offsetof(UMarvelRuleControllerItem, RuleControllerClass) == 0x000038, "Member 'UMarvelRuleControllerItem::RuleControllerClass' has a wrong offset!");

// Class MarvelLevel.MarvelRuleItem
// 0x0028 (0x0060 - 0x0038)
class UMarvelRuleItem final : public UPrimaryDataAsset
{
public:
	TArray<struct FRuleContent>                   RuleList;                                          // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<struct FActionContent>                 ActionList;                                        // 0x0048(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class UMarvelLevelConfig*                     LevelConfig;                                       // 0x0058(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarvelRuleItem">();
	}
	static class UMarvelRuleItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMarvelRuleItem>();
	}
};
static_assert(alignof(UMarvelRuleItem) == 0x000008, "Wrong alignment on UMarvelRuleItem");
static_assert(sizeof(UMarvelRuleItem) == 0x000060, "Wrong size on UMarvelRuleItem");
static_assert(offsetof(UMarvelRuleItem, RuleList) == 0x000038, "Member 'UMarvelRuleItem::RuleList' has a wrong offset!");
static_assert(offsetof(UMarvelRuleItem, ActionList) == 0x000048, "Member 'UMarvelRuleItem::ActionList' has a wrong offset!");
static_assert(offsetof(UMarvelRuleItem, LevelConfig) == 0x000058, "Member 'UMarvelRuleItem::LevelConfig' has a wrong offset!");

// Class MarvelLevel.PlayerStateTrainComponent
// 0x0030 (0x0138 - 0x0108)
class UPlayerStateTrainComponent : public UMarvelActorComponentBase
{
public:
	int32                                         SelfPlayerUID;                                     // 0x0108(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MainAttackHit;                                     // 0x010C(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MainAttackMiss;                                    // 0x0110(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_114[0x4];                                      // 0x0114(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         GenerateIDList;                                    // 0x0118(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         MainAttackCriticalHit;                             // 0x0128(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         KillCount;                                         // 0x012C(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InstigateDamage;                                   // 0x0130(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_134[0x4];                                      // 0x0134(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BindMainAttack();
	void ClearMainAttackData();
	void OnActorDeath(class AActor* Source, class AActor* Target, const struct FAttributeModifierHandle& ModifierParameterHandle, const struct FGlobalEventExtraData& ExtraData);
	void OnActorTakeDamage(class AActor* InInstigator, class AActor* InTarget, const struct FAttributeModifierHandle& ModifierParameterHandle, const struct FGlobalEventExtraData& ExtraData);
	void OnRep_MainAttackHit();
	void OnRep_MainAttackMiss();
	void OnTargetActorRecycleAgentTask(class AActor* Source, class UMarvelGameplayAbility* SourceAbility, const struct FMarvelTargetActorGenerateInfo& GenerateInfo, const struct FEndAgentTaskInfo& EndAgentTaskInfo);
	void OnWeaponAmmoUse(class AActor* Source, class AActor* Target, int32 AbilityID, bool bHit, bool bIsCritHit, const struct FGlobalEventExtraData& ExtraData);
	void UnbindMainAttack();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerStateTrainComponent">();
	}
	static class UPlayerStateTrainComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerStateTrainComponent>();
	}
};
static_assert(alignof(UPlayerStateTrainComponent) == 0x000008, "Wrong alignment on UPlayerStateTrainComponent");
static_assert(sizeof(UPlayerStateTrainComponent) == 0x000138, "Wrong size on UPlayerStateTrainComponent");
static_assert(offsetof(UPlayerStateTrainComponent, SelfPlayerUID) == 0x000108, "Member 'UPlayerStateTrainComponent::SelfPlayerUID' has a wrong offset!");
static_assert(offsetof(UPlayerStateTrainComponent, MainAttackHit) == 0x00010C, "Member 'UPlayerStateTrainComponent::MainAttackHit' has a wrong offset!");
static_assert(offsetof(UPlayerStateTrainComponent, MainAttackMiss) == 0x000110, "Member 'UPlayerStateTrainComponent::MainAttackMiss' has a wrong offset!");
static_assert(offsetof(UPlayerStateTrainComponent, GenerateIDList) == 0x000118, "Member 'UPlayerStateTrainComponent::GenerateIDList' has a wrong offset!");
static_assert(offsetof(UPlayerStateTrainComponent, MainAttackCriticalHit) == 0x000128, "Member 'UPlayerStateTrainComponent::MainAttackCriticalHit' has a wrong offset!");
static_assert(offsetof(UPlayerStateTrainComponent, KillCount) == 0x00012C, "Member 'UPlayerStateTrainComponent::KillCount' has a wrong offset!");
static_assert(offsetof(UPlayerStateTrainComponent, InstigateDamage) == 0x000130, "Member 'UPlayerStateTrainComponent::InstigateDamage' has a wrong offset!");

// Class MarvelLevel.EffectAbility_ScaleGravity
// 0x0000 (0x1370 - 0x1370)
class UEffectAbility_ScaleGravity : public UMarvelEffectGameplayAbility
{
public:
	void ResetGravityScale();
	bool SetGravityScale(float NewGravityScale);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EffectAbility_ScaleGravity">();
	}
	static class UEffectAbility_ScaleGravity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEffectAbility_ScaleGravity>();
	}
};
static_assert(alignof(UEffectAbility_ScaleGravity) == 0x000008, "Wrong alignment on UEffectAbility_ScaleGravity");
static_assert(sizeof(UEffectAbility_ScaleGravity) == 0x001370, "Wrong size on UEffectAbility_ScaleGravity");

// Class MarvelLevel.SpringFestivalStatComponent
// 0x0060 (0x0168 - 0x0108)
class USpringFestivalStatComponent : public UActorComponent
{
public:
	TArray<struct FSpringFestivalPlayerStat>      PlayerStats;                                       // 0x0108(0x0010)(Net, ZeroConstructor, RepNotify, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_118[0x50];                                     // 0x0118(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddPlayerStat(int32 UID, int32 StatIndex, int32 Value);
	void OnRep_PlayerStats();
	void RegisterPlayerStat(int32 UID, int32 StatCount);
	void SetPlayerStat(int32 UID, int32 StatIndex, int32 Value);
	void UnregisterPlayerStat(int32 UID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpringFestivalStatComponent">();
	}
	static class USpringFestivalStatComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpringFestivalStatComponent>();
	}
};
static_assert(alignof(USpringFestivalStatComponent) == 0x000008, "Wrong alignment on USpringFestivalStatComponent");
static_assert(sizeof(USpringFestivalStatComponent) == 0x000168, "Wrong size on USpringFestivalStatComponent");
static_assert(offsetof(USpringFestivalStatComponent, PlayerStats) == 0x000108, "Member 'USpringFestivalStatComponent::PlayerStats' has a wrong offset!");

// Class MarvelLevel.Summoned_20020001
// 0x0000 (0x0B70 - 0x0B70)
class ASummoned_20020001 : public AMarvelLevelSummonedBase
{
public:
	class UStaticMeshComponent*                   SummonedStaticMesh;                                // 0x0B68(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void K2_SetReplicatingMovement(bool NewReplicate);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Summoned_20020001">();
	}
	static class ASummoned_20020001* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASummoned_20020001>();
	}
};
static_assert(alignof(ASummoned_20020001) == 0x000010, "Wrong alignment on ASummoned_20020001");
static_assert(sizeof(ASummoned_20020001) == 0x000B70, "Wrong size on ASummoned_20020001");
static_assert(offsetof(ASummoned_20020001, SummonedStaticMesh) == 0x000B68, "Member 'ASummoned_20020001::SummonedStaticMesh' has a wrong offset!");

// Class MarvelLevel.Summoned_21300401
// 0x0000 (0x0B70 - 0x0B70)
class ASummoned_21300401 : public AMarvelLevelSummonedBase
{
public:
	float K2_OnModifyDamage(const struct FGameplayEffectSpec& Spec, float InDamage, const class UAbilitySystemComponent* SourceASC, const class UAbilitySystemComponent* TargetASC);
	void UpdateMaskFilter();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Summoned_21300401">();
	}
	static class ASummoned_21300401* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASummoned_21300401>();
	}
};
static_assert(alignof(ASummoned_21300401) == 0x000010, "Wrong alignment on ASummoned_21300401");
static_assert(sizeof(ASummoned_21300401) == 0x000B70, "Wrong size on ASummoned_21300401");

}

