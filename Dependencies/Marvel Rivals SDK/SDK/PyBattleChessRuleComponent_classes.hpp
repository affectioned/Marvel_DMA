#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: PyBattleChessRuleComponent

#include "Basic.hpp"

#include "PyRuleComponent_classes.hpp"
#include "CoreUObject_structs.hpp"
#include "MarvelLevel_structs.hpp"
#include "level_battle_chess_structs.hpp"


namespace SDK
{

// PythonClass PyBattleChessRuleComponent.PyBattleChessRuleComponent
// 0x03F8 (0x0500 - 0x0108)
class UPyBattleChessRuleComponent final : public UPyRuleComponent
{
public:
	TArray<class AMarvelPlayerState*>             PlayerList;                                        // 0x0108(0x0010)(Net, RepNotify, NativeAccessSpecifierPublic)
	TArray<class AMarvelPlayerState*>             AlivePlayerList;                                   // 0x0118(0x0010)(Net, NativeAccessSpecifierPublic)
	class AMarvelPlayerState*                     MirrorPlayer;                                      // 0x0128(0x0008)(Net, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AMarvelPlayerState*                     MirrorPlayerSource;                                // 0x0130(0x0008)(Net, ZeroConstructor, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxPlayerNum;                                      // 0x0138(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TeamAINum;                                         // 0x013C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AIDifficultyLevel;                                 // 0x0140(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_144[0x4];                                      // 0x0144(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   MirrorPlayerName;                                  // 0x0148(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   AIPlayerName;                                      // 0x0160(0x0018)(Edit, NativeAccessSpecifierPublic)
	int32                                         TankHeroNum;                                       // 0x0178(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DamageHeroNum;                                     // 0x017C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SupportHeroNum;                                    // 0x0180(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TankBondSourceNum;                                 // 0x0184(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DamageBondSourceNum;                               // 0x0188(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SupportBondSourceNum;                              // 0x018C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShareHeroPool;                                     // 0x0190(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_191[0x3];                                      // 0x0191(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         InitialHP;                                         // 0x0194(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DefeatReduceHP;                                    // 0x0198(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DrawReduceHP;                                      // 0x019C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RoundReduceHP;                                     // 0x01A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AIAliveReduceHP;                                   // 0x01A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BattleChessState;                                  // 0x01A8(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RoundStartTime;                                    // 0x01AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeroPlaceTime;                                     // 0x01B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BattleStartTime;                                   // 0x01B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RegularFightTime;                                  // 0x01B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedUpFightTime;                                  // 0x01BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReduceHpTime;                                      // 0x01C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C4[0x4];                                      // 0x01C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, struct FBattleChessPVEStage>      PVEStageConfig;                                    // 0x01C8(0x0050)(Edit, NativeAccessSpecifierPublic)
	float                                         PVERewardTime;                                     // 0x0218(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsPveRound;                                        // 0x021C(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21D[0x3];                                      // 0x021D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 SwitchHeroRoundList;                               // 0x0220(0x0010)(Edit, NativeAccessSpecifierPublic)
	int32                                         SwitchHeroCardRefreshPrice;                        // 0x0230(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SwitchHeroDrawCardTime;                            // 0x0234(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsSwitchHeroRound;                                 // 0x0238(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableDrawCard;                                   // 0x0239(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsDrawingCard;                                     // 0x023A(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23B[0x1];                                      // 0x023B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DrawCardTime;                                      // 0x023C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<int32, float>                            DrawCardTimeByRound;                               // 0x0240(0x0050)(Edit, NativeAccessSpecifierPublic)
	int32                                         DrawCardNum;                                       // 0x0290(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CardRefreshPrice;                                  // 0x0294(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxHoldCardNum;                                    // 0x0298(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StartCurrency;                                     // 0x029C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WinAward;                                          // 0x02A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A4[0x4];                                      // 0x02A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, int32>                            WinningStreakRewards;                              // 0x02A8(0x0050)(Edit, NativeAccessSpecifierPublic)
	TMap<int32, int32>                            LosingStreakReward;                                // 0x02F8(0x0050)(Edit, NativeAccessSpecifierPublic)
	int32                                         RoundRewardCurrency;                               // 0x0348(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InterestRewardsActivationValue;                    // 0x034C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterestRewardsReturnRate;                         // 0x0350(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InterestMaxRewards;                                // 0x0354(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HpReduceReward;                                    // 0x0358(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35C[0x4];                                      // 0x035C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AActor>                     CameraTargetActorClass;                            // 0x0360(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_368[0x8];                                      // 0x0368(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             CameraTargetTransform;                             // 0x0370(0x0060)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraMoveTime;                                    // 0x03D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraMoveBackTime;                                // 0x03D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ResetCameraWhenSwitchRound;                        // 0x03D8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D9[0x3];                                      // 0x03D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PrepareBuff;                                       // 0x03DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 FightBuffList;                                     // 0x03E0(0x0010)(Edit, NativeAccessSpecifierPublic)
	TMap<int32, TArray<int32>>                    FightHeroBuffMap;                                  // 0x03F0(0x0050)(Edit, NativeAccessSpecifierPublic)
	int32                                         SpeedUpFightBuff;                                  // 0x0440(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_444[0x4];                                      // 0x0444(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             BuffTable;                                         // 0x0448(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnableAutoTest;                                    // 0x0450(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnableAutoTest2;                                   // 0x0451(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnableAutoTest3;                                   // 0x0452(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_453[0x5];                                      // 0x0453(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, int32>                            HeroLevelMapping;                                  // 0x0458(0x0050)(Edit, NativeAccessSpecifierPublic)
	TMap<int32, class UBehaviorTree*>             GalactaBotBehaviorTree;                            // 0x04A8(0x0050)(Edit, NativeAccessSpecifierPublic)

public:
	void OnRep_IsSwitchHeroRound();
	void NetMulticast_BattleChessStateChange(EBattleChessState state, int32 RoundIndex);
	void OnRep_BattleChessState();
	void OnRep_PlayerList();
	void OnRep_MirrorPlayerSource();
	void NetMulticast_RoundWinner(class AMarvelPlayerState* Winner, class AMarvelPlayerState* Loser, bool IsTeamKill);
	void OnRep_IsDrawingCard();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PyBattleChessRuleComponent">();
	}
	static class UPyBattleChessRuleComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPyBattleChessRuleComponent>();
	}
};
static_assert(alignof(UPyBattleChessRuleComponent) == 0x000010, "Wrong alignment on UPyBattleChessRuleComponent");
static_assert(sizeof(UPyBattleChessRuleComponent) == 0x000500, "Wrong size on UPyBattleChessRuleComponent");
static_assert(offsetof(UPyBattleChessRuleComponent, PlayerList) == 0x000108, "Member 'UPyBattleChessRuleComponent::PlayerList' has a wrong offset!");
static_assert(offsetof(UPyBattleChessRuleComponent, AlivePlayerList) == 0x000118, "Member 'UPyBattleChessRuleComponent::AlivePlayerList' has a wrong offset!");
static_assert(offsetof(UPyBattleChessRuleComponent, MirrorPlayer) == 0x000128, "Member 'UPyBattleChessRuleComponent::MirrorPlayer' has a wrong offset!");
static_assert(offsetof(UPyBattleChessRuleComponent, MirrorPlayerSource) == 0x000130, "Member 'UPyBattleChessRuleComponent::MirrorPlayerSource' has a wrong offset!");
static_assert(offsetof(UPyBattleChessRuleComponent, MaxPlayerNum) == 0x000138, "Member 'UPyBattleChessRuleComponent::MaxPlayerNum' has a wrong offset!");
static_assert(offsetof(UPyBattleChessRuleComponent, TeamAINum) == 0x00013C, "Member 'UPyBattleChessRuleComponent::TeamAINum' has a wrong offset!");
static_assert(offsetof(UPyBattleChessRuleComponent, AIDifficultyLevel) == 0x000140, "Member 'UPyBattleChessRuleComponent::AIDifficultyLevel' has a wrong offset!");
static_assert(offsetof(UPyBattleChessRuleComponent, MirrorPlayerName) == 0x000148, "Member 'UPyBattleChessRuleComponent::MirrorPlayerName' has a wrong offset!");
static_assert(offsetof(UPyBattleChessRuleComponent, AIPlayerName) == 0x000160, "Member 'UPyBattleChessRuleComponent::AIPlayerName' has a wrong offset!");
static_assert(offsetof(UPyBattleChessRuleComponent, TankHeroNum) == 0x000178, "Member 'UPyBattleChessRuleComponent::TankHeroNum' has a wrong offset!");
static_assert(offsetof(UPyBattleChessRuleComponent, DamageHeroNum) == 0x00017C, "Member 'UPyBattleChessRuleComponent::DamageHeroNum' has a wrong offset!");
static_assert(offsetof(UPyBattleChessRuleComponent, SupportHeroNum) == 0x000180, "Member 'UPyBattleChessRuleComponent::SupportHeroNum' has a wrong offset!");
static_assert(offsetof(UPyBattleChessRuleComponent, TankBondSourceNum) == 0x000184, "Member 'UPyBattleChessRuleComponent::TankBondSourceNum' has a wrong offset!");
static_assert(offsetof(UPyBattleChessRuleComponent, DamageBondSourceNum) == 0x000188, "Member 'UPyBattleChessRuleComponent::DamageBondSourceNum' has a wrong offset!");
static_assert(offsetof(UPyBattleChessRuleComponent, SupportBondSourceNum) == 0x00018C, "Member 'UPyBattleChessRuleComponent::SupportBondSourceNum' has a wrong offset!");
static_assert(offsetof(UPyBattleChessRuleComponent, ShareHeroPool) == 0x000190, "Member 'UPyBattleChessRuleComponent::ShareHeroPool' has a wrong offset!");
static_assert(offsetof(UPyBattleChessRuleComponent, InitialHP) == 0x000194, "Member 'UPyBattleChessRuleComponent::InitialHP' has a wrong offset!");
static_assert(offsetof(UPyBattleChessRuleComponent, DefeatReduceHP) == 0x000198, "Member 'UPyBattleChessRuleComponent::DefeatReduceHP' has a wrong offset!");
static_assert(offsetof(UPyBattleChessRuleComponent, DrawReduceHP) == 0x00019C, "Member 'UPyBattleChessRuleComponent::DrawReduceHP' has a wrong offset!");
static_assert(offsetof(UPyBattleChessRuleComponent, RoundReduceHP) == 0x0001A0, "Member 'UPyBattleChessRuleComponent::RoundReduceHP' has a wrong offset!");
static_assert(offsetof(UPyBattleChessRuleComponent, AIAliveReduceHP) == 0x0001A4, "Member 'UPyBattleChessRuleComponent::AIAliveReduceHP' has a wrong offset!");
static_assert(offsetof(UPyBattleChessRuleComponent, BattleChessState) == 0x0001A8, "Member 'UPyBattleChessRuleComponent::BattleChessState' has a wrong offset!");
static_assert(offsetof(UPyBattleChessRuleComponent, RoundStartTime) == 0x0001AC, "Member 'UPyBattleChessRuleComponent::RoundStartTime' has a wrong offset!");
static_assert(offsetof(UPyBattleChessRuleComponent, HeroPlaceTime) == 0x0001B0, "Member 'UPyBattleChessRuleComponent::HeroPlaceTime' has a wrong offset!");
static_assert(offsetof(UPyBattleChessRuleComponent, BattleStartTime) == 0x0001B4, "Member 'UPyBattleChessRuleComponent::BattleStartTime' has a wrong offset!");
static_assert(offsetof(UPyBattleChessRuleComponent, RegularFightTime) == 0x0001B8, "Member 'UPyBattleChessRuleComponent::RegularFightTime' has a wrong offset!");
static_assert(offsetof(UPyBattleChessRuleComponent, SpeedUpFightTime) == 0x0001BC, "Member 'UPyBattleChessRuleComponent::SpeedUpFightTime' has a wrong offset!");
static_assert(offsetof(UPyBattleChessRuleComponent, ReduceHpTime) == 0x0001C0, "Member 'UPyBattleChessRuleComponent::ReduceHpTime' has a wrong offset!");
static_assert(offsetof(UPyBattleChessRuleComponent, PVEStageConfig) == 0x0001C8, "Member 'UPyBattleChessRuleComponent::PVEStageConfig' has a wrong offset!");
static_assert(offsetof(UPyBattleChessRuleComponent, PVERewardTime) == 0x000218, "Member 'UPyBattleChessRuleComponent::PVERewardTime' has a wrong offset!");
static_assert(offsetof(UPyBattleChessRuleComponent, IsPveRound) == 0x00021C, "Member 'UPyBattleChessRuleComponent::IsPveRound' has a wrong offset!");
static_assert(offsetof(UPyBattleChessRuleComponent, SwitchHeroRoundList) == 0x000220, "Member 'UPyBattleChessRuleComponent::SwitchHeroRoundList' has a wrong offset!");
static_assert(offsetof(UPyBattleChessRuleComponent, SwitchHeroCardRefreshPrice) == 0x000230, "Member 'UPyBattleChessRuleComponent::SwitchHeroCardRefreshPrice' has a wrong offset!");
static_assert(offsetof(UPyBattleChessRuleComponent, SwitchHeroDrawCardTime) == 0x000234, "Member 'UPyBattleChessRuleComponent::SwitchHeroDrawCardTime' has a wrong offset!");
static_assert(offsetof(UPyBattleChessRuleComponent, IsSwitchHeroRound) == 0x000238, "Member 'UPyBattleChessRuleComponent::IsSwitchHeroRound' has a wrong offset!");
static_assert(offsetof(UPyBattleChessRuleComponent, bEnableDrawCard) == 0x000239, "Member 'UPyBattleChessRuleComponent::bEnableDrawCard' has a wrong offset!");
static_assert(offsetof(UPyBattleChessRuleComponent, IsDrawingCard) == 0x00023A, "Member 'UPyBattleChessRuleComponent::IsDrawingCard' has a wrong offset!");
static_assert(offsetof(UPyBattleChessRuleComponent, DrawCardTime) == 0x00023C, "Member 'UPyBattleChessRuleComponent::DrawCardTime' has a wrong offset!");
static_assert(offsetof(UPyBattleChessRuleComponent, DrawCardTimeByRound) == 0x000240, "Member 'UPyBattleChessRuleComponent::DrawCardTimeByRound' has a wrong offset!");
static_assert(offsetof(UPyBattleChessRuleComponent, DrawCardNum) == 0x000290, "Member 'UPyBattleChessRuleComponent::DrawCardNum' has a wrong offset!");
static_assert(offsetof(UPyBattleChessRuleComponent, CardRefreshPrice) == 0x000294, "Member 'UPyBattleChessRuleComponent::CardRefreshPrice' has a wrong offset!");
static_assert(offsetof(UPyBattleChessRuleComponent, MaxHoldCardNum) == 0x000298, "Member 'UPyBattleChessRuleComponent::MaxHoldCardNum' has a wrong offset!");
static_assert(offsetof(UPyBattleChessRuleComponent, StartCurrency) == 0x00029C, "Member 'UPyBattleChessRuleComponent::StartCurrency' has a wrong offset!");
static_assert(offsetof(UPyBattleChessRuleComponent, WinAward) == 0x0002A0, "Member 'UPyBattleChessRuleComponent::WinAward' has a wrong offset!");
static_assert(offsetof(UPyBattleChessRuleComponent, WinningStreakRewards) == 0x0002A8, "Member 'UPyBattleChessRuleComponent::WinningStreakRewards' has a wrong offset!");
static_assert(offsetof(UPyBattleChessRuleComponent, LosingStreakReward) == 0x0002F8, "Member 'UPyBattleChessRuleComponent::LosingStreakReward' has a wrong offset!");
static_assert(offsetof(UPyBattleChessRuleComponent, RoundRewardCurrency) == 0x000348, "Member 'UPyBattleChessRuleComponent::RoundRewardCurrency' has a wrong offset!");
static_assert(offsetof(UPyBattleChessRuleComponent, InterestRewardsActivationValue) == 0x00034C, "Member 'UPyBattleChessRuleComponent::InterestRewardsActivationValue' has a wrong offset!");
static_assert(offsetof(UPyBattleChessRuleComponent, InterestRewardsReturnRate) == 0x000350, "Member 'UPyBattleChessRuleComponent::InterestRewardsReturnRate' has a wrong offset!");
static_assert(offsetof(UPyBattleChessRuleComponent, InterestMaxRewards) == 0x000354, "Member 'UPyBattleChessRuleComponent::InterestMaxRewards' has a wrong offset!");
static_assert(offsetof(UPyBattleChessRuleComponent, HpReduceReward) == 0x000358, "Member 'UPyBattleChessRuleComponent::HpReduceReward' has a wrong offset!");
static_assert(offsetof(UPyBattleChessRuleComponent, CameraTargetActorClass) == 0x000360, "Member 'UPyBattleChessRuleComponent::CameraTargetActorClass' has a wrong offset!");
static_assert(offsetof(UPyBattleChessRuleComponent, CameraTargetTransform) == 0x000370, "Member 'UPyBattleChessRuleComponent::CameraTargetTransform' has a wrong offset!");
static_assert(offsetof(UPyBattleChessRuleComponent, CameraMoveTime) == 0x0003D0, "Member 'UPyBattleChessRuleComponent::CameraMoveTime' has a wrong offset!");
static_assert(offsetof(UPyBattleChessRuleComponent, CameraMoveBackTime) == 0x0003D4, "Member 'UPyBattleChessRuleComponent::CameraMoveBackTime' has a wrong offset!");
static_assert(offsetof(UPyBattleChessRuleComponent, ResetCameraWhenSwitchRound) == 0x0003D8, "Member 'UPyBattleChessRuleComponent::ResetCameraWhenSwitchRound' has a wrong offset!");
static_assert(offsetof(UPyBattleChessRuleComponent, PrepareBuff) == 0x0003DC, "Member 'UPyBattleChessRuleComponent::PrepareBuff' has a wrong offset!");
static_assert(offsetof(UPyBattleChessRuleComponent, FightBuffList) == 0x0003E0, "Member 'UPyBattleChessRuleComponent::FightBuffList' has a wrong offset!");
static_assert(offsetof(UPyBattleChessRuleComponent, FightHeroBuffMap) == 0x0003F0, "Member 'UPyBattleChessRuleComponent::FightHeroBuffMap' has a wrong offset!");
static_assert(offsetof(UPyBattleChessRuleComponent, SpeedUpFightBuff) == 0x000440, "Member 'UPyBattleChessRuleComponent::SpeedUpFightBuff' has a wrong offset!");
static_assert(offsetof(UPyBattleChessRuleComponent, BuffTable) == 0x000448, "Member 'UPyBattleChessRuleComponent::BuffTable' has a wrong offset!");
static_assert(offsetof(UPyBattleChessRuleComponent, EnableAutoTest) == 0x000450, "Member 'UPyBattleChessRuleComponent::EnableAutoTest' has a wrong offset!");
static_assert(offsetof(UPyBattleChessRuleComponent, EnableAutoTest2) == 0x000451, "Member 'UPyBattleChessRuleComponent::EnableAutoTest2' has a wrong offset!");
static_assert(offsetof(UPyBattleChessRuleComponent, EnableAutoTest3) == 0x000452, "Member 'UPyBattleChessRuleComponent::EnableAutoTest3' has a wrong offset!");
static_assert(offsetof(UPyBattleChessRuleComponent, HeroLevelMapping) == 0x000458, "Member 'UPyBattleChessRuleComponent::HeroLevelMapping' has a wrong offset!");
static_assert(offsetof(UPyBattleChessRuleComponent, GalactaBotBehaviorTree) == 0x0004A8, "Member 'UPyBattleChessRuleComponent::GalactaBotBehaviorTree' has a wrong offset!");

}

