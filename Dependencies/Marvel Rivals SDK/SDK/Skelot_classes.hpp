#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Skelot

#include "Basic.hpp"

#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "Skelot_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "DeveloperSettings_classes.hpp"
#include "StructUtils_structs.hpp"


namespace SDK
{

// Class Skelot.Character_SkelotBound
// 0x0010 (0x0DA0 - 0x0D90)
class ACharacter_SkelotBound final : public ACharacter
{
public:
	int32                                         InstanceIndex;                                     // 0x0D90(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class USkelotCharacterSyncComponent> SkelotComponent;                             // 0x0D94(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D9C[0x4];                                      // 0x0D9C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BindToSkelot(class USkelotCharacterSyncComponent* InSkelotComponent);
	void UnbindFromSkelot();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Character_SkelotBound">();
	}
	static class ACharacter_SkelotBound* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACharacter_SkelotBound>();
	}
};
static_assert(alignof(ACharacter_SkelotBound) == 0x000010, "Wrong alignment on ACharacter_SkelotBound");
static_assert(sizeof(ACharacter_SkelotBound) == 0x000DA0, "Wrong size on ACharacter_SkelotBound");
static_assert(offsetof(ACharacter_SkelotBound, InstanceIndex) == 0x000D90, "Member 'ACharacter_SkelotBound::InstanceIndex' has a wrong offset!");
static_assert(offsetof(ACharacter_SkelotBound, SkelotComponent) == 0x000D94, "Member 'ACharacter_SkelotBound::SkelotComponent' has a wrong offset!");

// Class Skelot.SkelotComponent
// 0x0320 (0x0BA0 - 0x0880)
class USkelotComponent : public UMeshComponent
{
public:
	class USkelotAnimCollection*                  AnimCollection;                                    // 0x0878(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSkelotSubmeshSlot>             Submeshes;                                         // 0x0880(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class USkeletalMesh*                          SkeletalMesh;                                      // 0x0890(0x0008)(ZeroConstructor, Deprecated, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InstanceMaxDrawDistance;                           // 0x0898(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InstanceMinDrawDistance;                           // 0x089C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector3f                              ComponentBoundExtent;                              // 0x08A0(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LODDistances[0x7];                                 // 0x08AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LODDistanceScale;                                  // 0x08C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumCustomDataFloats;                               // 0x08CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         StartShadowLODBias;                                // 0x08D0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ShadowLODBias;                                     // 0x08D1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bNeedCustomDataForShadowPass : 1;                  // 0x08D2(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseFixedInstanceBound : 1;                        // 0x08D2(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIgnoreAnimationsTick : 1;                         // 0x08D2(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         MaxMeshPerInstance;                                // 0x08D3(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         InstanceDefaultAttachIndex;                        // 0x08D4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8D5[0x3];                                      // 0x08D5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AnimationPlayRate;                                 // 0x08D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8DC[0x4];                                      // 0x08DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UScriptStruct*                          PerInstanceScriptStruct;                           // 0x08E0(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8E8[0x1D0];                                    // 0x08E8(0x01D0)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class USkelotComponent* Component, const TArray<struct FSkelotAnimFinishEvent>& Events)> OnAnimationFinishedDelegate; // 0x0AB8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class USkelotComponent* Component, const TArray<struct FSkelotAnimNotifyEvent>& Events)> OnAnimationNotifyDelegate; // 0x0AC8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMap<int32, struct FSkelotDynInsTieData>      DynamicPoseInstancesTiedToSMC;                     // 0x0AD8(0x0050)(BlueprintVisible, BlueprintReadOnly, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_B28[0x78];                                     // 0x0B28(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 AddInstance(const struct FTransform3f& WorldTransform);
	int32 AddInstance_CopyFrom(const class USkelotComponent* Src, int32 SrcInstanceIndex);
	void AddInstanceLocation(int32 InstanceIndex, const struct FVector3f& Offset);
	void AddSubmesh(const struct FSkelotSubmeshSlot& InData);
	void BatchAddUserFlags(const TArray<int32>& InstanceIndices, int32 Flags_0);
	void BatchRemoveUserFlags(const TArray<int32>& InstanceIndices, int32 Flags_0);
	void BatchUpdateTransforms(int32 StartInstanceIndex, const TArray<struct FTransform3f>& NewTransforms);
	void ClearInstances(bool bEmpty);
	bool DestroyInstance(int32 InstanceIndex);
	void DestroyInstances(const TArray<int32>& InstanceIndices);
	void DestroyInstancesByRange(int32 StartIndex, int32 Count);
	bool EnableInstanceDynamicPose(int32 InstanceIndex, bool bEnable);
	void InitSubmeshesFromAnimCollection();
	void InstanceAddUserFlags(int32 InstanceIndex, int32 Flags_0);
	bool InstanceAttachSubmeshByAsset(int32 InstanceIndex, class USkeletalMesh* InMesh, bool bAttach);
	bool InstanceAttachSubmeshByIndex(int32 InstanceIndex, uint8 SubMeshIndex, bool bAttach);
	bool InstanceAttachSubmeshByName(int32 InstanceIndex, class FName SubMeshName, bool bAttach);
	int32 InstanceAttachSubmeshes(int32 InstanceIndex, const TArray<class USkeletalMesh*>& InMeshes, bool bAttach);
	void InstanceCopyFrom(int32 InstanceIndex, const class USkelotComponent* SrcComponent, int32 SrcInstanceIndex);
	void InstanceDetachAllSubmeshes(int32 InstanceIndex);
	float InstancePlayAnimation(int32 InstanceIndex, class UAnimSequenceBase* Animation, bool bLoop, float StartAt, float PlayScale, float TransitionDuration, EAlphaBlendOption BlendOption, bool bIgnoreTransitionGeneration);
	float InstancePlayAnimationByIndex(int32 InstanceIndex, int32 AnimationIndex, bool bLoop, float StartAt, float PlayScale, float TransitionDuration, EAlphaBlendOption BlendOption, bool bIgnoreTransitionGeneration);
	void InstanceRemoveUserFlags(int32 InstanceIndex, int32 Flags_0);
	int32 K2_FlushInstances(TArray<int32>* RemapArray);
	void K2_GetInstanceCustomStruct(ESkelotValidity* ExecResult, int32 InstanceIndex, int32* OutStruct);
	void K2_MarkRenderStateDirty();
	void K2_SetInstanceCustomStruct(int32 InstanceIndex, const int32& InStruct);
	void MoveAllInstances(const struct FVector3f& Offset);
	void PauseInstanceAnimation(int32 InstanceIndex, bool bPause);
	void PlayAnimationOnAll(class UAnimSequenceBase* Animation, bool bLoop, float StartAt, float PlayScale, float TransitionDuration, EAlphaBlendOption BlendOption, bool bIgnoreTransitionGeneration);
	void ResetInstanceAnimationState(int32 InstanceIndex);
	void SetAnimCollection(class USkelotAnimCollection* asset);
	void SetInstanceAnimationLooped(int32 InstanceIndex, bool bLoop);
	void SetInstanceCustomData(int32 InstanceIndex, int32 FloatIndex, float InValue);
	void SetInstanceCustomDataFloat1(int32 InstanceIndex, float Value);
	void SetInstanceCustomDataFloat2(int32 InstanceIndex, const struct FVector2f& Value);
	void SetInstanceCustomDataFloat3(int32 InstanceIndex, const struct FVector3f& Value);
	void SetInstanceCustomDataFloat4(int32 InstanceIndex, const struct FVector4f& Value);
	void SetInstanceHidden(int32 InstanceIndex, bool bHidden);
	void SetInstanceLocation(int32 InstanceIndex, const struct FVector3f& NewLocation);
	void SetInstanceLocationAndRotation(int32 InstanceIndex, const struct FVector3f& NewLocation, const struct FQuat4f& NewRotation);
	void SetInstancePlayScale(int32 InstanceIndex, float NewPlayScale);
	void SetInstanceRotation(int32 InstanceIndex, const struct FQuat4f& NewRotation);
	void SetInstanceRotator(int32 InstanceIndex, const struct FRotator3f& NewRotator);
	void SetInstanceScale(int32 InstanceIndex, const struct FVector3f& NewScale);
	void SetInstanceStencil(int32 InstanceIndex, int32 Stencil);
	void SetInstanceTransform(int32 InstanceIndex, const struct FTransform3f& NewTransform);
	void SetLODDistanceScale(float NewLODDistanceScale);
	void SetSubmeshAsset(int32 SubmeshIndex, class USkeletalMesh* InMesh);
	void SetSubmeshMaterial(class FName SubmeshName, class USkeletalMesh* OrSubmeshAsset, class FName MaterialSlotName, int32 OrMaterialIndex, class UMaterialInterface* Material);
	void TieDynamicPoseToComponent(int32 InstanceIndex, class USkeletalMeshComponent* SrcComponent, int32 UserData);
	void ToggleInstanceAnimationLoop(int32 InstanceIndex);
	void ToggleInstanceAnimationPause(int32 InstanceIndex);
	void ToggleInstanceVisibility(int32 InstanceIndex);
	void UntieDynamicPoseFromComponent(int32 InstanceIndex);

	int32 FindSubmeshIndex(class FName SubmeshName, const class USkeletalMesh* OrSubmeshAsset) const;
	int32 GetAliveInstanceCount() const;
	int32 GetBoneIndex(class FName BoneName) const;
	class FName GetBoneName(int32 SkeletonBoneIndex) const;
	int32 GetDestroyedInstanceCount() const;
	void GetInstanceAttachedSkeletalMeshes(int32 InstanceIndex, TArray<class USkeletalMesh*>* OutMeshes) const;
	int32 GetInstanceCount() const;
	float GetInstanceCurrentAnimPlayScale(int32 InstanceIndex) const;
	class UAnimSequenceBase* GetInstanceCurrentAnimSequence(int32 InstanceIndex) const;
	int32 GetInstanceCurrentAnimSequenceIndex(int32 InstanceIndex) const;
	float GetInstanceCustomData(int32 InstanceIndex, int32 FloatIndex) const;
	float GetInstanceCustomDataFloat1(int32 InstanceIndex) const;
	struct FVector2f GetInstanceCustomDataFloat2(int32 InstanceIndex) const;
	struct FVector3f GetInstanceCustomDataFloat3(int32 InstanceIndex) const;
	struct FVector4f GetInstanceCustomDataFloat4(int32 InstanceIndex) const;
	const struct FVector3f GetInstanceLocation(int32 InstanceIndex) const;
	const struct FQuat4f GetInstanceRotation(int32 InstanceIndex) const;
	struct FRotator3f GetInstanceRotator(int32 InstanceIndex) const;
	struct FTransform3f GetInstanceSocketTransform(int32 InstanceIndex, class FName SocketName, class USkeletalMesh* InMesh, bool bWorldSpace) const;
	void GetInstancesSocketTransform(TArray<struct FTransform3f>* OutTransforms, class FName SocketName, class USkeletalMesh* InMesh, bool bWorldSpace) const;
	struct FTransform3f GetInstanceTransform(int32 InstanceIndex) const;
	int32 GetSubmeshBaseMaterialIndex(int32 SubmeshIndex) const;
	int32 GetSubmeshBaseMaterialIndexByAsset(class USkeletalMesh* SubmeshAsset) const;
	int32 GetSubmeshBaseMaterialIndexByName(class FName SunmeshName) const;
	int32 GetSubmeshCount() const;
	TArray<class FName> GetSubmeshNames() const;
	bool InstanceHasAnyUserFlags(int32 InstanceIndex, int32 Flags_0) const;
	bool IsInstanceAnimationLooped(int32 InstanceIndex) const;
	bool IsInstanceAnimationPaused(int32 InstanceIndex) const;
	bool IsInstanceDynamicPose(int32 InstanceIndex) const;
	bool IsInstanceHidden(int32 InstanceIndex) const;
	bool IsInstancePlayingAnimation(int32 InstanceIndex, const class UAnimSequenceBase* Animation) const;
	bool IsInstancePlayingAnyAnimation(int32 InstanceIndex) const;
	bool IsInstanceValid(int32 InstanceIndex) const;
	int32 LineTraceInstanceAny(int32 InstanceIndex, const struct FVector& Start, const struct FVector& End) const;
	int32 LineTraceInstanceSingle(int32 InstanceIndex, const struct FVector& Start, const struct FVector& End, float Thickness, double* OutTime, struct FVector* OutPosition, struct FVector* OutNormal) const;
	int32 OverlapTestInstance(int32 InstanceIndex, const struct FVector& Point, float Thickness) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SkelotComponent">();
	}
	static class USkelotComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USkelotComponent>();
	}
};
static_assert(alignof(USkelotComponent) == 0x000010, "Wrong alignment on USkelotComponent");
static_assert(sizeof(USkelotComponent) == 0x000BA0, "Wrong size on USkelotComponent");
static_assert(offsetof(USkelotComponent, AnimCollection) == 0x000878, "Member 'USkelotComponent::AnimCollection' has a wrong offset!");
static_assert(offsetof(USkelotComponent, Submeshes) == 0x000880, "Member 'USkelotComponent::Submeshes' has a wrong offset!");
static_assert(offsetof(USkelotComponent, SkeletalMesh) == 0x000890, "Member 'USkelotComponent::SkeletalMesh' has a wrong offset!");
static_assert(offsetof(USkelotComponent, InstanceMaxDrawDistance) == 0x000898, "Member 'USkelotComponent::InstanceMaxDrawDistance' has a wrong offset!");
static_assert(offsetof(USkelotComponent, InstanceMinDrawDistance) == 0x00089C, "Member 'USkelotComponent::InstanceMinDrawDistance' has a wrong offset!");
static_assert(offsetof(USkelotComponent, ComponentBoundExtent) == 0x0008A0, "Member 'USkelotComponent::ComponentBoundExtent' has a wrong offset!");
static_assert(offsetof(USkelotComponent, LODDistances) == 0x0008AC, "Member 'USkelotComponent::LODDistances' has a wrong offset!");
static_assert(offsetof(USkelotComponent, LODDistanceScale) == 0x0008C8, "Member 'USkelotComponent::LODDistanceScale' has a wrong offset!");
static_assert(offsetof(USkelotComponent, NumCustomDataFloats) == 0x0008CC, "Member 'USkelotComponent::NumCustomDataFloats' has a wrong offset!");
static_assert(offsetof(USkelotComponent, StartShadowLODBias) == 0x0008D0, "Member 'USkelotComponent::StartShadowLODBias' has a wrong offset!");
static_assert(offsetof(USkelotComponent, ShadowLODBias) == 0x0008D1, "Member 'USkelotComponent::ShadowLODBias' has a wrong offset!");
static_assert(offsetof(USkelotComponent, MaxMeshPerInstance) == 0x0008D3, "Member 'USkelotComponent::MaxMeshPerInstance' has a wrong offset!");
static_assert(offsetof(USkelotComponent, InstanceDefaultAttachIndex) == 0x0008D4, "Member 'USkelotComponent::InstanceDefaultAttachIndex' has a wrong offset!");
static_assert(offsetof(USkelotComponent, AnimationPlayRate) == 0x0008D8, "Member 'USkelotComponent::AnimationPlayRate' has a wrong offset!");
static_assert(offsetof(USkelotComponent, PerInstanceScriptStruct) == 0x0008E0, "Member 'USkelotComponent::PerInstanceScriptStruct' has a wrong offset!");
static_assert(offsetof(USkelotComponent, OnAnimationFinishedDelegate) == 0x000AB8, "Member 'USkelotComponent::OnAnimationFinishedDelegate' has a wrong offset!");
static_assert(offsetof(USkelotComponent, OnAnimationNotifyDelegate) == 0x000AC8, "Member 'USkelotComponent::OnAnimationNotifyDelegate' has a wrong offset!");
static_assert(offsetof(USkelotComponent, DynamicPoseInstancesTiedToSMC) == 0x000AD8, "Member 'USkelotComponent::DynamicPoseInstancesTiedToSMC' has a wrong offset!");

// Class Skelot.SkelotCharacterSyncComponent
// 0x0040 (0x0BE0 - 0x0BA0)
class USkelotCharacterSyncComponent final : public USkelotComponent
{
public:
	struct FTransform3f                           MeshTransform;                                     // 0x0BA0(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BD0[0x10];                                     // 0x0BD0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class ACharacter_SkelotBound* GetCharacterActor(int32 InstanceIndex) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SkelotCharacterSyncComponent">();
	}
	static class USkelotCharacterSyncComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USkelotCharacterSyncComponent>();
	}
};
static_assert(alignof(USkelotCharacterSyncComponent) == 0x000010, "Wrong alignment on USkelotCharacterSyncComponent");
static_assert(sizeof(USkelotCharacterSyncComponent) == 0x000BE0, "Wrong size on USkelotCharacterSyncComponent");
static_assert(offsetof(USkelotCharacterSyncComponent, MeshTransform) == 0x000BA0, "Member 'USkelotCharacterSyncComponent::MeshTransform' has a wrong offset!");

// Class Skelot.SkelotCommandlet
// 0x0000 (0x0088 - 0x0088)
class USkelotCommandlet final : public UCommandlet
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SkelotCommandlet">();
	}
	static class USkelotCommandlet* GetDefaultObj()
	{
		return GetDefaultObjImpl<USkelotCommandlet>();
	}
};
static_assert(alignof(USkelotCommandlet) == 0x000008, "Wrong alignment on USkelotCommandlet");
static_assert(sizeof(USkelotCommandlet) == 0x000088, "Wrong size on USkelotCommandlet");

// Class Skelot.SkelotDeveloperSettings
// 0x0008 (0x0050 - 0x0048)
class USkelotDeveloperSettings final : public UDeveloperSettingsBackedByCVars
{
public:
	int32                                         MaxTransitionGenerationPerFrame;                   // 0x0048(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SkelotDeveloperSettings">();
	}
	static class USkelotDeveloperSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<USkelotDeveloperSettings>();
	}
};
static_assert(alignof(USkelotDeveloperSettings) == 0x000008, "Wrong alignment on USkelotDeveloperSettings");
static_assert(sizeof(USkelotDeveloperSettings) == 0x000050, "Wrong size on USkelotDeveloperSettings");
static_assert(offsetof(USkelotDeveloperSettings, MaxTransitionGenerationPerFrame) == 0x000048, "Member 'USkelotDeveloperSettings::MaxTransitionGenerationPerFrame' has a wrong offset!");

// Class Skelot.SkelotBPUtility
// 0x0000 (0x0030 - 0x0030)
class USkelotBPUtility final : public UBlueprintFunctionLibrary
{
public:
	static class USkeletalMeshComponent* ConstructSkeletalMeshComponentsFromInstance(const class USkelotComponent* Component, int32 InstanceIndex, class UObject* Outer_0, bool bSetCustomPrimitiveDataFloat);
	static int32 LineTraceInstancesSingle(class USkelotComponent* Component, const struct FVector& Start, const struct FVector& End, float Thickness, float DebugDrawTime, double* OutTime, struct FVector* OutPosition, struct FVector* OutNormal, int32* OutBoneIndex);
	static void MoveAllInstancesConditional(class USkelotComponent* Component, const struct FVector& Offset, int32 FlagsToTest, bool bAllFlags, bool bInvert);
	static void QueryLocationOverlappingBox(class USkelotComponent* Component, const struct FBox& Box, TArray<int32>* InstanceIndices);
	static void QueryLocationOverlappingBoxAdvanced(class USkelotComponent* Component, int32 FlagsToTest, bool bAllFlags, bool bInvert, const struct FBox& Box, TArray<int32>* InstanceIndices);
	static void QueryLocationOverlappingComponentAdvanced(class USkelotComponent* Component, class UPrimitiveComponent* ComponentToTest, int32 FlagsToTest, bool bAllFlags, bool bInvert, TArray<int32>* InstanceIndices);
	static void QueryLocationOverlappingSphere(class USkelotComponent* Component, const struct FVector& Center, float Radius, TArray<int32>* InstanceIndices);
	static void QueryLocationOverlappingSphereAdvanced(class USkelotComponent* Component, int32 FlagsToTest, bool bAllFlags, bool bInvert, const struct FVector& Center, float Radius, TArray<int32>* InstanceIndices);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SkelotBPUtility">();
	}
	static class USkelotBPUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<USkelotBPUtility>();
	}
};
static_assert(alignof(USkelotBPUtility) == 0x000008, "Wrong alignment on USkelotBPUtility");
static_assert(sizeof(USkelotBPUtility) == 0x000030, "Wrong size on USkelotBPUtility");

// Class Skelot.SkelotAnimCollection
// 0x05D8 (0x0610 - 0x0038)
class USkelotAnimCollection final : public UDataAsset
{
public:
	class USkeleton*                              Skeleton;                                          // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMesh*                          RefPoseOverrideMesh;                               // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseAnimDataConfig;                                // 0x0048(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSkelotSequenceDef>             Sequences;                                         // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FInstancedStruct                       AnimDataConfig;                                    // 0x0060(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSet<class FName>                             BonesToCache;                                      // 0x0088(0x0050)(Edit, NativeAccessSpecifierPublic)
	TArray<struct FSkelotMeshDef>                 Meshes;                                            // 0x00D8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bRandomlyAttachOneMesh;                            // 0x00E8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAttachAllMeshes;                                  // 0x00E9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bExtractRootMotion;                                // 0x00EA(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCachePhysicsAssetBones;                           // 0x00EB(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHighPrecision;                                    // 0x00EC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableRetargeting;                               // 0x00ED(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDontGenerateBounds;                               // 0x00EE(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EF[0x5];                                       // 0x00EF(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         RenderBoneCount;                                   // 0x00F4(0x0004)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AnimationBoneCount;                                // 0x00F8(0x0004)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TotalFrameCount;                                   // 0x00FC(0x0004)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FrameCountSequences;                               // 0x0100(0x0004)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TotalAnimationBufferSize;                          // 0x0104(0x0004)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TotalMeshBonesBufferSize;                          // 0x0108(0x0004)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxTransitionPose;                                 // 0x010C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxDynamicPose;                                    // 0x0110(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WalkAnimMaxSpeed;                                  // 0x0114(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int8>                                  AnimationPriority;                                 // 0x0118(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         JumpStartToFallingTransitionDuration;              // 0x0128(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseTransformOffset;                               // 0x012C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12D[0x3];                                      // 0x012D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             TransformOffset;                                   // 0x0130(0x0060)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLightingChannels                      LightingChannels;                                  // 0x0190(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	uint8                                         Pad_191[0x46F];                                    // 0x0191(0x046F)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NumTransitionFrameAllocated;                       // 0x0600(0x0004)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_604[0xC];                                      // 0x0604(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UAnimSequenceBase* FindAnimByName(const class FString& ContainingName);
	class USkeletalMesh* FindMeshByName(const class FString& ContainingName);

	class UAnimSequenceBase* GetRandomAnimSequence() const;
	class UAnimSequenceBase* GetRandomAnimSequenceFromStream(const struct FRandomStream& RandomSteam) const;
	class USkeletalMesh* GetRandomMesh() const;
	class USkeletalMesh* GetRandomMeshFromStream(const struct FRandomStream& RandomSteam) const;
	TArray<class FName> GetValidBones() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SkelotAnimCollection">();
	}
	static class USkelotAnimCollection* GetDefaultObj()
	{
		return GetDefaultObjImpl<USkelotAnimCollection>();
	}
};
static_assert(alignof(USkelotAnimCollection) == 0x000010, "Wrong alignment on USkelotAnimCollection");
static_assert(sizeof(USkelotAnimCollection) == 0x000610, "Wrong size on USkelotAnimCollection");
static_assert(offsetof(USkelotAnimCollection, Skeleton) == 0x000038, "Member 'USkelotAnimCollection::Skeleton' has a wrong offset!");
static_assert(offsetof(USkelotAnimCollection, RefPoseOverrideMesh) == 0x000040, "Member 'USkelotAnimCollection::RefPoseOverrideMesh' has a wrong offset!");
static_assert(offsetof(USkelotAnimCollection, bUseAnimDataConfig) == 0x000048, "Member 'USkelotAnimCollection::bUseAnimDataConfig' has a wrong offset!");
static_assert(offsetof(USkelotAnimCollection, Sequences) == 0x000050, "Member 'USkelotAnimCollection::Sequences' has a wrong offset!");
static_assert(offsetof(USkelotAnimCollection, AnimDataConfig) == 0x000060, "Member 'USkelotAnimCollection::AnimDataConfig' has a wrong offset!");
static_assert(offsetof(USkelotAnimCollection, BonesToCache) == 0x000088, "Member 'USkelotAnimCollection::BonesToCache' has a wrong offset!");
static_assert(offsetof(USkelotAnimCollection, Meshes) == 0x0000D8, "Member 'USkelotAnimCollection::Meshes' has a wrong offset!");
static_assert(offsetof(USkelotAnimCollection, bRandomlyAttachOneMesh) == 0x0000E8, "Member 'USkelotAnimCollection::bRandomlyAttachOneMesh' has a wrong offset!");
static_assert(offsetof(USkelotAnimCollection, bAttachAllMeshes) == 0x0000E9, "Member 'USkelotAnimCollection::bAttachAllMeshes' has a wrong offset!");
static_assert(offsetof(USkelotAnimCollection, bExtractRootMotion) == 0x0000EA, "Member 'USkelotAnimCollection::bExtractRootMotion' has a wrong offset!");
static_assert(offsetof(USkelotAnimCollection, bCachePhysicsAssetBones) == 0x0000EB, "Member 'USkelotAnimCollection::bCachePhysicsAssetBones' has a wrong offset!");
static_assert(offsetof(USkelotAnimCollection, bHighPrecision) == 0x0000EC, "Member 'USkelotAnimCollection::bHighPrecision' has a wrong offset!");
static_assert(offsetof(USkelotAnimCollection, bDisableRetargeting) == 0x0000ED, "Member 'USkelotAnimCollection::bDisableRetargeting' has a wrong offset!");
static_assert(offsetof(USkelotAnimCollection, bDontGenerateBounds) == 0x0000EE, "Member 'USkelotAnimCollection::bDontGenerateBounds' has a wrong offset!");
static_assert(offsetof(USkelotAnimCollection, RenderBoneCount) == 0x0000F4, "Member 'USkelotAnimCollection::RenderBoneCount' has a wrong offset!");
static_assert(offsetof(USkelotAnimCollection, AnimationBoneCount) == 0x0000F8, "Member 'USkelotAnimCollection::AnimationBoneCount' has a wrong offset!");
static_assert(offsetof(USkelotAnimCollection, TotalFrameCount) == 0x0000FC, "Member 'USkelotAnimCollection::TotalFrameCount' has a wrong offset!");
static_assert(offsetof(USkelotAnimCollection, FrameCountSequences) == 0x000100, "Member 'USkelotAnimCollection::FrameCountSequences' has a wrong offset!");
static_assert(offsetof(USkelotAnimCollection, TotalAnimationBufferSize) == 0x000104, "Member 'USkelotAnimCollection::TotalAnimationBufferSize' has a wrong offset!");
static_assert(offsetof(USkelotAnimCollection, TotalMeshBonesBufferSize) == 0x000108, "Member 'USkelotAnimCollection::TotalMeshBonesBufferSize' has a wrong offset!");
static_assert(offsetof(USkelotAnimCollection, MaxTransitionPose) == 0x00010C, "Member 'USkelotAnimCollection::MaxTransitionPose' has a wrong offset!");
static_assert(offsetof(USkelotAnimCollection, MaxDynamicPose) == 0x000110, "Member 'USkelotAnimCollection::MaxDynamicPose' has a wrong offset!");
static_assert(offsetof(USkelotAnimCollection, WalkAnimMaxSpeed) == 0x000114, "Member 'USkelotAnimCollection::WalkAnimMaxSpeed' has a wrong offset!");
static_assert(offsetof(USkelotAnimCollection, AnimationPriority) == 0x000118, "Member 'USkelotAnimCollection::AnimationPriority' has a wrong offset!");
static_assert(offsetof(USkelotAnimCollection, JumpStartToFallingTransitionDuration) == 0x000128, "Member 'USkelotAnimCollection::JumpStartToFallingTransitionDuration' has a wrong offset!");
static_assert(offsetof(USkelotAnimCollection, bUseTransformOffset) == 0x00012C, "Member 'USkelotAnimCollection::bUseTransformOffset' has a wrong offset!");
static_assert(offsetof(USkelotAnimCollection, TransformOffset) == 0x000130, "Member 'USkelotAnimCollection::TransformOffset' has a wrong offset!");
static_assert(offsetof(USkelotAnimCollection, LightingChannels) == 0x000190, "Member 'USkelotAnimCollection::LightingChannels' has a wrong offset!");
static_assert(offsetof(USkelotAnimCollection, NumTransitionFrameAllocated) == 0x000600, "Member 'USkelotAnimCollection::NumTransitionFrameAllocated' has a wrong offset!");

// Class Skelot.SkelotListenerInterface
// 0x0000 (0x0000 - 0x0000)
class ISkelotListenerInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SkelotListenerInterface">();
	}
	static class ISkelotListenerInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ISkelotListenerInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ISkelotListenerInterface) == 0x000001, "Wrong alignment on ISkelotListenerInterface");
static_assert(sizeof(ISkelotListenerInterface) == 0x000001, "Wrong size on ISkelotListenerInterface");

}

