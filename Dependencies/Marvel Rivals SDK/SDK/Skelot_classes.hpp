#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Skelot

#include "Basic.hpp"

#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "Skelot_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "DeveloperSettings_classes.hpp"
#include "StructUtils_structs.hpp"


namespace SDK
{

// Class Skelot.Character_SkelotBound
// 0x0010 (0x0DA0 - 0x0D90)
class ACharacter_SkelotBound final : public ACharacter
{
public:
	int32                                         InstanceIndex;                                     // 0x0D90(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class USkelotCharacterSyncComponent> SkelotComponent;                             // 0x0D94(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D9C[0x4];                                      // 0x0D9C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BindToSkelot(class USkelotCharacterSyncComponent* InSkelotComponent);
	void UnbindFromSkelot();

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("Character_SkelotBound")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"Character_SkelotBound")
	}
	static class ACharacter_SkelotBound* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACharacter_SkelotBound>();
	}
};
DUMPER7_ASSERTS_ACharacter_SkelotBound;

// Class Skelot.SkelotComponent
// 0x0320 (0x0BA0 - 0x0880)
class USkelotComponent : public UMeshComponent
{
public:
	class USkelotAnimCollection*                  AnimCollection;                                    // 0x0878(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSkelotSubmeshSlot>             Submeshes;                                         // 0x0880(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class USkeletalMesh*                          SkeletalMesh;                                      // 0x0890(0x0008)(ZeroConstructor, Deprecated, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InstanceMaxDrawDistance;                           // 0x0898(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InstanceMinDrawDistance;                           // 0x089C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector3f                              ComponentBoundExtent;                              // 0x08A0(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LODDistances[0x7];                                 // 0x08AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LODDistanceScale;                                  // 0x08C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumCustomDataFloats;                               // 0x08CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         StartShadowLODBias;                                // 0x08D0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ShadowLODBias;                                     // 0x08D1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bNeedCustomDataForShadowPass : 1;                  // 0x08D2(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseFixedInstanceBound : 1;                        // 0x08D2(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIgnoreAnimationsTick : 1;                         // 0x08D2(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         MaxMeshPerInstance;                                // 0x08D3(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         InstanceDefaultAttachIndex;                        // 0x08D4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8D5[0x3];                                      // 0x08D5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AnimationPlayRate;                                 // 0x08D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8DC[0x4];                                      // 0x08DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UScriptStruct*                          PerInstanceScriptStruct;                           // 0x08E0(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8E8[0x1D0];                                    // 0x08E8(0x01D0)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class USkelotComponent* Component, const TArray<struct FSkelotAnimFinishEvent>& Events)> OnAnimationFinishedDelegate; // 0x0AB8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class USkelotComponent* Component, const TArray<struct FSkelotAnimNotifyEvent>& Events)> OnAnimationNotifyDelegate; // 0x0AC8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMap<int32, struct FSkelotDynInsTieData>      DynamicPoseInstancesTiedToSMC;                     // 0x0AD8(0x0050)(BlueprintVisible, BlueprintReadOnly, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_B28[0x78];                                     // 0x0B28(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 AddInstance(const struct FTransform3f& WorldTransform);
	int32 AddInstance_CopyFrom(const class USkelotComponent* Src, int32 SrcInstanceIndex);
	void AddInstanceLocation(int32 InstanceIndex, const struct FVector3f& Offset);
	void AddSubmesh(const struct FSkelotSubmeshSlot& InData);
	void BatchAddUserFlags(const TArray<int32>& InstanceIndices, int32 Flags_0);
	void BatchRemoveUserFlags(const TArray<int32>& InstanceIndices, int32 Flags_0);
	void BatchUpdateTransforms(int32 StartInstanceIndex, const TArray<struct FTransform3f>& NewTransforms);
	void ClearInstances(bool bEmpty);
	bool DestroyInstance(int32 InstanceIndex);
	void DestroyInstances(const TArray<int32>& InstanceIndices);
	void DestroyInstancesByRange(int32 StartIndex, int32 Count);
	bool EnableInstanceDynamicPose(int32 InstanceIndex, bool bEnable);
	void InitSubmeshesFromAnimCollection();
	void InstanceAddUserFlags(int32 InstanceIndex, int32 Flags_0);
	bool InstanceAttachSubmeshByAsset(int32 InstanceIndex, class USkeletalMesh* InMesh, bool bAttach);
	bool InstanceAttachSubmeshByIndex(int32 InstanceIndex, uint8 SubMeshIndex, bool bAttach);
	bool InstanceAttachSubmeshByName(int32 InstanceIndex, class FName SubMeshName, bool bAttach);
	int32 InstanceAttachSubmeshes(int32 InstanceIndex, const TArray<class USkeletalMesh*>& InMeshes, bool bAttach);
	void InstanceCopyFrom(int32 InstanceIndex, const class USkelotComponent* SrcComponent, int32 SrcInstanceIndex);
	void InstanceDetachAllSubmeshes(int32 InstanceIndex);
	float InstancePlayAnimation(int32 InstanceIndex, class UAnimSequenceBase* Animation, bool bLoop, float StartAt, float PlayScale, float TransitionDuration, EAlphaBlendOption BlendOption, bool bIgnoreTransitionGeneration);
	float InstancePlayAnimationByIndex(int32 InstanceIndex, int32 AnimationIndex, bool bLoop, float StartAt, float PlayScale, float TransitionDuration, EAlphaBlendOption BlendOption, bool bIgnoreTransitionGeneration);
	void InstanceRemoveUserFlags(int32 InstanceIndex, int32 Flags_0);
	int32 K2_FlushInstances(TArray<int32>* RemapArray);
	void K2_GetInstanceCustomStruct(ESkelotValidity* ExecResult, int32 InstanceIndex, int32* OutStruct);
	void K2_MarkRenderStateDirty();
	void K2_SetInstanceCustomStruct(int32 InstanceIndex, const int32& InStruct);
	void MoveAllInstances(const struct FVector3f& Offset);
	void PauseInstanceAnimation(int32 InstanceIndex, bool bPause);
	void PlayAnimationOnAll(class UAnimSequenceBase* Animation, bool bLoop, float StartAt, float PlayScale, float TransitionDuration, EAlphaBlendOption BlendOption, bool bIgnoreTransitionGeneration);
	void ResetInstanceAnimationState(int32 InstanceIndex);
	void SetAnimCollection(class USkelotAnimCollection* asset);
	void SetInstanceAnimationLooped(int32 InstanceIndex, bool bLoop);
	void SetInstanceCustomData(int32 InstanceIndex, int32 FloatIndex, float InValue);
	void SetInstanceCustomDataFloat1(int32 InstanceIndex, float Value);
	void SetInstanceCustomDataFloat2(int32 InstanceIndex, const struct FVector2f& Value);
	void SetInstanceCustomDataFloat3(int32 InstanceIndex, const struct FVector3f& Value);
	void SetInstanceCustomDataFloat4(int32 InstanceIndex, const struct FVector4f& Value);
	void SetInstanceHidden(int32 InstanceIndex, bool bHidden);
	void SetInstanceLocation(int32 InstanceIndex, const struct FVector3f& NewLocation);
	void SetInstanceLocationAndRotation(int32 InstanceIndex, const struct FVector3f& NewLocation, const struct FQuat4f& NewRotation);
	void SetInstancePlayScale(int32 InstanceIndex, float NewPlayScale);
	void SetInstanceRotation(int32 InstanceIndex, const struct FQuat4f& NewRotation);
	void SetInstanceRotator(int32 InstanceIndex, const struct FRotator3f& NewRotator);
	void SetInstanceScale(int32 InstanceIndex, const struct FVector3f& NewScale);
	void SetInstanceStencil(int32 InstanceIndex, int32 Stencil);
	void SetInstanceTransform(int32 InstanceIndex, const struct FTransform3f& NewTransform);
	void SetLODDistanceScale(float NewLODDistanceScale);
	void SetSubmeshAsset(int32 SubmeshIndex, class USkeletalMesh* InMesh);
	void SetSubmeshMaterial(class FName SubmeshName, class USkeletalMesh* OrSubmeshAsset, class FName MaterialSlotName, int32 OrMaterialIndex, class UMaterialInterface* Material);
	void TieDynamicPoseToComponent(int32 InstanceIndex, class USkeletalMeshComponent* SrcComponent, int32 UserData);
	void ToggleInstanceAnimationLoop(int32 InstanceIndex);
	void ToggleInstanceAnimationPause(int32 InstanceIndex);
	void ToggleInstanceVisibility(int32 InstanceIndex);
	void UntieDynamicPoseFromComponent(int32 InstanceIndex);

	int32 FindSubmeshIndex(class FName SubmeshName, const class USkeletalMesh* OrSubmeshAsset) const;
	int32 GetAliveInstanceCount() const;
	int32 GetBoneIndex(class FName BoneName) const;
	class FName GetBoneName(int32 SkeletonBoneIndex) const;
	int32 GetDestroyedInstanceCount() const;
	void GetInstanceAttachedSkeletalMeshes(int32 InstanceIndex, TArray<class USkeletalMesh*>* OutMeshes) const;
	int32 GetInstanceCount() const;
	float GetInstanceCurrentAnimPlayScale(int32 InstanceIndex) const;
	class UAnimSequenceBase* GetInstanceCurrentAnimSequence(int32 InstanceIndex) const;
	int32 GetInstanceCurrentAnimSequenceIndex(int32 InstanceIndex) const;
	float GetInstanceCustomData(int32 InstanceIndex, int32 FloatIndex) const;
	float GetInstanceCustomDataFloat1(int32 InstanceIndex) const;
	struct FVector2f GetInstanceCustomDataFloat2(int32 InstanceIndex) const;
	struct FVector3f GetInstanceCustomDataFloat3(int32 InstanceIndex) const;
	struct FVector4f GetInstanceCustomDataFloat4(int32 InstanceIndex) const;
	const struct FVector3f GetInstanceLocation(int32 InstanceIndex) const;
	const struct FQuat4f GetInstanceRotation(int32 InstanceIndex) const;
	struct FRotator3f GetInstanceRotator(int32 InstanceIndex) const;
	struct FTransform3f GetInstanceSocketTransform(int32 InstanceIndex, class FName SocketName, class USkeletalMesh* InMesh, bool bWorldSpace) const;
	void GetInstancesSocketTransform(TArray<struct FTransform3f>* OutTransforms, class FName SocketName, class USkeletalMesh* InMesh, bool bWorldSpace) const;
	struct FTransform3f GetInstanceTransform(int32 InstanceIndex) const;
	int32 GetSubmeshBaseMaterialIndex(int32 SubmeshIndex) const;
	int32 GetSubmeshBaseMaterialIndexByAsset(class USkeletalMesh* SubmeshAsset) const;
	int32 GetSubmeshBaseMaterialIndexByName(class FName SunmeshName) const;
	int32 GetSubmeshCount() const;
	TArray<class FName> GetSubmeshNames() const;
	bool InstanceHasAnyUserFlags(int32 InstanceIndex, int32 Flags_0) const;
	bool IsInstanceAnimationLooped(int32 InstanceIndex) const;
	bool IsInstanceAnimationPaused(int32 InstanceIndex) const;
	bool IsInstanceDynamicPose(int32 InstanceIndex) const;
	bool IsInstanceHidden(int32 InstanceIndex) const;
	bool IsInstancePlayingAnimation(int32 InstanceIndex, const class UAnimSequenceBase* Animation) const;
	bool IsInstancePlayingAnyAnimation(int32 InstanceIndex) const;
	bool IsInstanceValid(int32 InstanceIndex) const;
	int32 LineTraceInstanceAny(int32 InstanceIndex, const struct FVector& Start, const struct FVector& End) const;
	int32 LineTraceInstanceSingle(int32 InstanceIndex, const struct FVector& Start, const struct FVector& End, float Thickness, double* OutTime, struct FVector* OutPosition, struct FVector* OutNormal) const;
	int32 OverlapTestInstance(int32 InstanceIndex, const struct FVector& Point, float Thickness) const;

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("SkelotComponent")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"SkelotComponent")
	}
	static class USkelotComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USkelotComponent>();
	}
};
DUMPER7_ASSERTS_USkelotComponent;

// Class Skelot.SkelotCharacterSyncComponent
// 0x0040 (0x0BE0 - 0x0BA0)
class USkelotCharacterSyncComponent final : public USkelotComponent
{
public:
	struct FTransform3f                           MeshTransform;                                     // 0x0BA0(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BD0[0x10];                                     // 0x0BD0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class ACharacter_SkelotBound* GetCharacterActor(int32 InstanceIndex) const;

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("SkelotCharacterSyncComponent")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"SkelotCharacterSyncComponent")
	}
	static class USkelotCharacterSyncComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USkelotCharacterSyncComponent>();
	}
};
DUMPER7_ASSERTS_USkelotCharacterSyncComponent;

// Class Skelot.SkelotCommandlet
// 0x0000 (0x0088 - 0x0088)
class USkelotCommandlet final : public UCommandlet
{
public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("SkelotCommandlet")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"SkelotCommandlet")
	}
	static class USkelotCommandlet* GetDefaultObj()
	{
		return GetDefaultObjImpl<USkelotCommandlet>();
	}
};
DUMPER7_ASSERTS_USkelotCommandlet;

// Class Skelot.SkelotDeveloperSettings
// 0x0008 (0x0050 - 0x0048)
class USkelotDeveloperSettings final : public UDeveloperSettingsBackedByCVars
{
public:
	int32                                         MaxTransitionGenerationPerFrame;                   // 0x0048(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("SkelotDeveloperSettings")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"SkelotDeveloperSettings")
	}
	static class USkelotDeveloperSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<USkelotDeveloperSettings>();
	}
};
DUMPER7_ASSERTS_USkelotDeveloperSettings;

// Class Skelot.SkelotBPUtility
// 0x0000 (0x0030 - 0x0030)
class USkelotBPUtility final : public UBlueprintFunctionLibrary
{
public:
	static class USkeletalMeshComponent* ConstructSkeletalMeshComponentsFromInstance(const class USkelotComponent* Component, int32 InstanceIndex, class UObject* Outer_0, bool bSetCustomPrimitiveDataFloat);
	static int32 LineTraceInstancesSingle(class USkelotComponent* Component, const struct FVector& Start, const struct FVector& End, float Thickness, float DebugDrawTime, double* OutTime, struct FVector* OutPosition, struct FVector* OutNormal, int32* OutBoneIndex);
	static void MoveAllInstancesConditional(class USkelotComponent* Component, const struct FVector& Offset, int32 FlagsToTest, bool bAllFlags, bool bInvert);
	static void QueryLocationOverlappingBox(class USkelotComponent* Component, const struct FBox& Box, TArray<int32>* InstanceIndices);
	static void QueryLocationOverlappingBoxAdvanced(class USkelotComponent* Component, int32 FlagsToTest, bool bAllFlags, bool bInvert, const struct FBox& Box, TArray<int32>* InstanceIndices);
	static void QueryLocationOverlappingComponentAdvanced(class USkelotComponent* Component, class UPrimitiveComponent* ComponentToTest, int32 FlagsToTest, bool bAllFlags, bool bInvert, TArray<int32>* InstanceIndices);
	static void QueryLocationOverlappingSphere(class USkelotComponent* Component, const struct FVector& Center, float Radius, TArray<int32>* InstanceIndices);
	static void QueryLocationOverlappingSphereAdvanced(class USkelotComponent* Component, int32 FlagsToTest, bool bAllFlags, bool bInvert, const struct FVector& Center, float Radius, TArray<int32>* InstanceIndices);

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("SkelotBPUtility")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"SkelotBPUtility")
	}
	static class USkelotBPUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<USkelotBPUtility>();
	}
};
DUMPER7_ASSERTS_USkelotBPUtility;

// Class Skelot.SkelotAnimCollection
// 0x05D8 (0x0610 - 0x0038)
class USkelotAnimCollection final : public UDataAsset
{
public:
	class USkeleton*                              Skeleton;                                          // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMesh*                          RefPoseOverrideMesh;                               // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseAnimDataConfig;                                // 0x0048(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSkelotSequenceDef>             Sequences;                                         // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FInstancedStruct                       AnimDataConfig;                                    // 0x0060(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSet<class FName>                             BonesToCache;                                      // 0x0088(0x0050)(Edit, NativeAccessSpecifierPublic)
	TArray<struct FSkelotMeshDef>                 Meshes;                                            // 0x00D8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bRandomlyAttachOneMesh;                            // 0x00E8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAttachAllMeshes;                                  // 0x00E9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bExtractRootMotion;                                // 0x00EA(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCachePhysicsAssetBones;                           // 0x00EB(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHighPrecision;                                    // 0x00EC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableRetargeting;                               // 0x00ED(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDontGenerateBounds;                               // 0x00EE(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EF[0x5];                                       // 0x00EF(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         RenderBoneCount;                                   // 0x00F4(0x0004)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AnimationBoneCount;                                // 0x00F8(0x0004)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TotalFrameCount;                                   // 0x00FC(0x0004)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FrameCountSequences;                               // 0x0100(0x0004)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TotalAnimationBufferSize;                          // 0x0104(0x0004)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TotalMeshBonesBufferSize;                          // 0x0108(0x0004)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxTransitionPose;                                 // 0x010C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxDynamicPose;                                    // 0x0110(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WalkAnimMaxSpeed;                                  // 0x0114(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int8>                                  AnimationPriority;                                 // 0x0118(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         JumpStartToFallingTransitionDuration;              // 0x0128(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseTransformOffset;                               // 0x012C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12D[0x3];                                      // 0x012D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             TransformOffset;                                   // 0x0130(0x0060)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLightingChannels                      LightingChannels;                                  // 0x0190(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	uint8                                         Pad_191[0x46F];                                    // 0x0191(0x046F)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NumTransitionFrameAllocated;                       // 0x0600(0x0004)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_604[0xC];                                      // 0x0604(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UAnimSequenceBase* FindAnimByName(const class FString& ContainingName);
	class USkeletalMesh* FindMeshByName(const class FString& ContainingName);

	class UAnimSequenceBase* GetRandomAnimSequence() const;
	class UAnimSequenceBase* GetRandomAnimSequenceFromStream(const struct FRandomStream& RandomSteam) const;
	class USkeletalMesh* GetRandomMesh() const;
	class USkeletalMesh* GetRandomMeshFromStream(const struct FRandomStream& RandomSteam) const;
	TArray<class FName> GetValidBones() const;

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("SkelotAnimCollection")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"SkelotAnimCollection")
	}
	static class USkelotAnimCollection* GetDefaultObj()
	{
		return GetDefaultObjImpl<USkelotAnimCollection>();
	}
};
DUMPER7_ASSERTS_USkelotAnimCollection;

// Class Skelot.SkelotListenerInterface
// 0x0000 (0x0000 - 0x0000)
class ISkelotListenerInterface final
{
public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("SkelotListenerInterface")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"SkelotListenerInterface")
	}
	static class ISkelotListenerInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ISkelotListenerInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
DUMPER7_ASSERTS_ISkelotListenerInterface;

}

