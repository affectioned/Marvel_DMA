#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: ability_exit_stage_logic

#include "Basic.hpp"

#include "MarvelAI_structs.hpp"
#include "MarvelAI_classes.hpp"
#include "Marvel_structs.hpp"
#include "GameplayTags_structs.hpp"


namespace SDK
{

// PythonClass ability_exit_stage_logic.PyAIAbilityExitStageLogicBase
// 0x0000 (0x0038 - 0x0038)
class UPyAIAbilityExitStageLogicBase : public UAIAbilityExitStageLogic
{
public:
	void InitLogic();
	bool CheckLogic(const struct FAIAbilityUsage& AbilityUsage, class AMarvelAIController* Controller);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PyAIAbilityExitStageLogicBase">();
	}
	static class UPyAIAbilityExitStageLogicBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPyAIAbilityExitStageLogicBase>();
	}
};
static_assert(alignof(UPyAIAbilityExitStageLogicBase) == 0x000008, "Wrong alignment on UPyAIAbilityExitStageLogicBase");
static_assert(sizeof(UPyAIAbilityExitStageLogicBase) == 0x000038, "Wrong size on UPyAIAbilityExitStageLogicBase");

// PythonClass ability_exit_stage_logic.PyAIAbilityExitStage_CanNotSeeTarget
// 0x0008 (0x0040 - 0x0038)
class UPyAIAbilityExitStage_CanNotSeeTarget final : public UPyAIAbilityExitStageLogicBase
{
public:
	bool                                          bShouldHaveSeenTarget;                             // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PyAIAbilityExitStage_CanNotSeeTarget">();
	}
	static class UPyAIAbilityExitStage_CanNotSeeTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPyAIAbilityExitStage_CanNotSeeTarget>();
	}
};
static_assert(alignof(UPyAIAbilityExitStage_CanNotSeeTarget) == 0x000008, "Wrong alignment on UPyAIAbilityExitStage_CanNotSeeTarget");
static_assert(sizeof(UPyAIAbilityExitStage_CanNotSeeTarget) == 0x000040, "Wrong size on UPyAIAbilityExitStage_CanNotSeeTarget");
static_assert(offsetof(UPyAIAbilityExitStage_CanNotSeeTarget, bShouldHaveSeenTarget) == 0x000038, "Member 'UPyAIAbilityExitStage_CanNotSeeTarget::bShouldHaveSeenTarget' has a wrong offset!");

// PythonClass ability_exit_stage_logic.PyAIAbilityExitStage_AbilityBreak
// 0x0000 (0x0038 - 0x0038)
class UPyAIAbilityExitStage_AbilityBreak : public UPyAIAbilityExitStageLogicBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PyAIAbilityExitStage_AbilityBreak">();
	}
	static class UPyAIAbilityExitStage_AbilityBreak* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPyAIAbilityExitStage_AbilityBreak>();
	}
};
static_assert(alignof(UPyAIAbilityExitStage_AbilityBreak) == 0x000008, "Wrong alignment on UPyAIAbilityExitStage_AbilityBreak");
static_assert(sizeof(UPyAIAbilityExitStage_AbilityBreak) == 0x000038, "Wrong size on UPyAIAbilityExitStage_AbilityBreak");

// PythonClass ability_exit_stage_logic.PyAIAbilityExitStage_CanNotExecute
// 0x0000 (0x0038 - 0x0038)
class UPyAIAbilityExitStage_CanNotExecute final : public UPyAIAbilityExitStageLogicBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PyAIAbilityExitStage_CanNotExecute">();
	}
	static class UPyAIAbilityExitStage_CanNotExecute* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPyAIAbilityExitStage_CanNotExecute>();
	}
};
static_assert(alignof(UPyAIAbilityExitStage_CanNotExecute) == 0x000008, "Wrong alignment on UPyAIAbilityExitStage_CanNotExecute");
static_assert(sizeof(UPyAIAbilityExitStage_CanNotExecute) == 0x000038, "Wrong size on UPyAIAbilityExitStage_CanNotExecute");

// PythonClass ability_exit_stage_logic.PyAIAbilityExitStage_AbilityPreMissile
// 0x0000 (0x0038 - 0x0038)
class UPyAIAbilityExitStage_AbilityPreMissile final : public UPyAIAbilityExitStageLogicBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PyAIAbilityExitStage_AbilityPreMissile">();
	}
	static class UPyAIAbilityExitStage_AbilityPreMissile* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPyAIAbilityExitStage_AbilityPreMissile>();
	}
};
static_assert(alignof(UPyAIAbilityExitStage_AbilityPreMissile) == 0x000008, "Wrong alignment on UPyAIAbilityExitStage_AbilityPreMissile");
static_assert(sizeof(UPyAIAbilityExitStage_AbilityPreMissile) == 0x000038, "Wrong size on UPyAIAbilityExitStage_AbilityPreMissile");

// PythonClass ability_exit_stage_logic.PyAIAbilityExitStage_NoEnemy
// 0x0008 (0x0040 - 0x0038)
class UPyAIAbilityExitStage_NoEnemy final : public UPyAIAbilityExitStageLogicBase
{
public:
	struct FRange_FloatValue                      CheckRadius;                                       // 0x0038(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PyAIAbilityExitStage_NoEnemy">();
	}
	static class UPyAIAbilityExitStage_NoEnemy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPyAIAbilityExitStage_NoEnemy>();
	}
};
static_assert(alignof(UPyAIAbilityExitStage_NoEnemy) == 0x000008, "Wrong alignment on UPyAIAbilityExitStage_NoEnemy");
static_assert(sizeof(UPyAIAbilityExitStage_NoEnemy) == 0x000040, "Wrong size on UPyAIAbilityExitStage_NoEnemy");
static_assert(offsetof(UPyAIAbilityExitStage_NoEnemy, CheckRadius) == 0x000038, "Member 'UPyAIAbilityExitStage_NoEnemy::CheckRadius' has a wrong offset!");

// PythonClass ability_exit_stage_logic.PyAIAbilityExitStage_AbilityMissile
// 0x0000 (0x0038 - 0x0038)
class UPyAIAbilityExitStage_AbilityMissile final : public UPyAIAbilityExitStageLogicBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PyAIAbilityExitStage_AbilityMissile">();
	}
	static class UPyAIAbilityExitStage_AbilityMissile* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPyAIAbilityExitStage_AbilityMissile>();
	}
};
static_assert(alignof(UPyAIAbilityExitStage_AbilityMissile) == 0x000008, "Wrong alignment on UPyAIAbilityExitStage_AbilityMissile");
static_assert(sizeof(UPyAIAbilityExitStage_AbilityMissile) == 0x000038, "Wrong size on UPyAIAbilityExitStage_AbilityMissile");

// PythonClass ability_exit_stage_logic.PyAIAbilityExitStage_AbilityEnd
// 0x0000 (0x0038 - 0x0038)
class UPyAIAbilityExitStage_AbilityEnd : public UPyAIAbilityExitStageLogicBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PyAIAbilityExitStage_AbilityEnd">();
	}
	static class UPyAIAbilityExitStage_AbilityEnd* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPyAIAbilityExitStage_AbilityEnd>();
	}
};
static_assert(alignof(UPyAIAbilityExitStage_AbilityEnd) == 0x000008, "Wrong alignment on UPyAIAbilityExitStage_AbilityEnd");
static_assert(sizeof(UPyAIAbilityExitStage_AbilityEnd) == 0x000038, "Wrong size on UPyAIAbilityExitStage_AbilityEnd");

// PythonClass ability_exit_stage_logic.PyAIAbilityExitStage_CanNotSeeTargetTimeLimit
// 0x0008 (0x0040 - 0x0038)
class UPyAIAbilityExitStage_CanNotSeeTargetTimeLimit final : public UPyAIAbilityExitStageLogicBase
{
public:
	float                                         TimeLimit;                                         // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldHaveSeenTarget;                             // 0x003C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PyAIAbilityExitStage_CanNotSeeTargetTimeLimit">();
	}
	static class UPyAIAbilityExitStage_CanNotSeeTargetTimeLimit* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPyAIAbilityExitStage_CanNotSeeTargetTimeLimit>();
	}
};
static_assert(alignof(UPyAIAbilityExitStage_CanNotSeeTargetTimeLimit) == 0x000008, "Wrong alignment on UPyAIAbilityExitStage_CanNotSeeTargetTimeLimit");
static_assert(sizeof(UPyAIAbilityExitStage_CanNotSeeTargetTimeLimit) == 0x000040, "Wrong size on UPyAIAbilityExitStage_CanNotSeeTargetTimeLimit");
static_assert(offsetof(UPyAIAbilityExitStage_CanNotSeeTargetTimeLimit, TimeLimit) == 0x000038, "Member 'UPyAIAbilityExitStage_CanNotSeeTargetTimeLimit::TimeLimit' has a wrong offset!");
static_assert(offsetof(UPyAIAbilityExitStage_CanNotSeeTargetTimeLimit, bShouldHaveSeenTarget) == 0x00003C, "Member 'UPyAIAbilityExitStage_CanNotSeeTargetTimeLimit::bShouldHaveSeenTarget' has a wrong offset!");

// PythonClass ability_exit_stage_logic.PyAIAbilityExitStage_CanNotSeeEnemy
// 0x0008 (0x0040 - 0x0038)
class UPyAIAbilityExitStage_CanNotSeeEnemy : public UPyAIAbilityExitStageLogicBase
{
public:
	bool                                          bShouldHaveSeenEnemy;                              // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PyAIAbilityExitStage_CanNotSeeEnemy">();
	}
	static class UPyAIAbilityExitStage_CanNotSeeEnemy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPyAIAbilityExitStage_CanNotSeeEnemy>();
	}
};
static_assert(alignof(UPyAIAbilityExitStage_CanNotSeeEnemy) == 0x000008, "Wrong alignment on UPyAIAbilityExitStage_CanNotSeeEnemy");
static_assert(sizeof(UPyAIAbilityExitStage_CanNotSeeEnemy) == 0x000040, "Wrong size on UPyAIAbilityExitStage_CanNotSeeEnemy");
static_assert(offsetof(UPyAIAbilityExitStage_CanNotSeeEnemy, bShouldHaveSeenEnemy) == 0x000038, "Member 'UPyAIAbilityExitStage_CanNotSeeEnemy::bShouldHaveSeenEnemy' has a wrong offset!");

// PythonClass ability_exit_stage_logic.PyAIAbilityExitStage_CanSeeEnemy
// 0x0000 (0x0038 - 0x0038)
class UPyAIAbilityExitStage_CanSeeEnemy final : public UPyAIAbilityExitStageLogicBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PyAIAbilityExitStage_CanSeeEnemy">();
	}
	static class UPyAIAbilityExitStage_CanSeeEnemy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPyAIAbilityExitStage_CanSeeEnemy>();
	}
};
static_assert(alignof(UPyAIAbilityExitStage_CanSeeEnemy) == 0x000008, "Wrong alignment on UPyAIAbilityExitStage_CanSeeEnemy");
static_assert(sizeof(UPyAIAbilityExitStage_CanSeeEnemy) == 0x000038, "Wrong size on UPyAIAbilityExitStage_CanSeeEnemy");

// PythonClass ability_exit_stage_logic.PyAIAbilityExitStage_FocusTargetOutOfSight
// 0x0000 (0x0038 - 0x0038)
class UPyAIAbilityExitStage_FocusTargetOutOfSight : public UPyAIAbilityExitStageLogicBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PyAIAbilityExitStage_FocusTargetOutOfSight">();
	}
	static class UPyAIAbilityExitStage_FocusTargetOutOfSight* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPyAIAbilityExitStage_FocusTargetOutOfSight>();
	}
};
static_assert(alignof(UPyAIAbilityExitStage_FocusTargetOutOfSight) == 0x000008, "Wrong alignment on UPyAIAbilityExitStage_FocusTargetOutOfSight");
static_assert(sizeof(UPyAIAbilityExitStage_FocusTargetOutOfSight) == 0x000038, "Wrong size on UPyAIAbilityExitStage_FocusTargetOutOfSight");

// PythonClass ability_exit_stage_logic.PyAIAbilityExitStage_FocusTargetOutOfMemory
// 0x0000 (0x0038 - 0x0038)
class UPyAIAbilityExitStage_FocusTargetOutOfMemory : public UPyAIAbilityExitStageLogicBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PyAIAbilityExitStage_FocusTargetOutOfMemory">();
	}
	static class UPyAIAbilityExitStage_FocusTargetOutOfMemory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPyAIAbilityExitStage_FocusTargetOutOfMemory>();
	}
};
static_assert(alignof(UPyAIAbilityExitStage_FocusTargetOutOfMemory) == 0x000008, "Wrong alignment on UPyAIAbilityExitStage_FocusTargetOutOfMemory");
static_assert(sizeof(UPyAIAbilityExitStage_FocusTargetOutOfMemory) == 0x000038, "Wrong size on UPyAIAbilityExitStage_FocusTargetOutOfMemory");

// PythonClass ability_exit_stage_logic.PyAIAbilityExitStage_CanNotSeeEnemyTimeLimit
// 0x0008 (0x0040 - 0x0038)
class UPyAIAbilityExitStage_CanNotSeeEnemyTimeLimit final : public UPyAIAbilityExitStageLogicBase
{
public:
	float                                         TimeLimit;                                         // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldHaveSeenEnemy;                              // 0x003C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PyAIAbilityExitStage_CanNotSeeEnemyTimeLimit">();
	}
	static class UPyAIAbilityExitStage_CanNotSeeEnemyTimeLimit* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPyAIAbilityExitStage_CanNotSeeEnemyTimeLimit>();
	}
};
static_assert(alignof(UPyAIAbilityExitStage_CanNotSeeEnemyTimeLimit) == 0x000008, "Wrong alignment on UPyAIAbilityExitStage_CanNotSeeEnemyTimeLimit");
static_assert(sizeof(UPyAIAbilityExitStage_CanNotSeeEnemyTimeLimit) == 0x000040, "Wrong size on UPyAIAbilityExitStage_CanNotSeeEnemyTimeLimit");
static_assert(offsetof(UPyAIAbilityExitStage_CanNotSeeEnemyTimeLimit, TimeLimit) == 0x000038, "Member 'UPyAIAbilityExitStage_CanNotSeeEnemyTimeLimit::TimeLimit' has a wrong offset!");
static_assert(offsetof(UPyAIAbilityExitStage_CanNotSeeEnemyTimeLimit, bShouldHaveSeenEnemy) == 0x00003C, "Member 'UPyAIAbilityExitStage_CanNotSeeEnemyTimeLimit::bShouldHaveSeenEnemy' has a wrong offset!");

// PythonClass ability_exit_stage_logic.PyAIAbilityExitStage_NearTarget
// 0x0008 (0x0040 - 0x0038)
class UPyAIAbilityExitStage_NearTarget : public UPyAIAbilityExitStageLogicBase
{
public:
	float                                         AccessRange;                                       // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PyAIAbilityExitStage_NearTarget">();
	}
	static class UPyAIAbilityExitStage_NearTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPyAIAbilityExitStage_NearTarget>();
	}
};
static_assert(alignof(UPyAIAbilityExitStage_NearTarget) == 0x000008, "Wrong alignment on UPyAIAbilityExitStage_NearTarget");
static_assert(sizeof(UPyAIAbilityExitStage_NearTarget) == 0x000040, "Wrong size on UPyAIAbilityExitStage_NearTarget");
static_assert(offsetof(UPyAIAbilityExitStage_NearTarget, AccessRange) == 0x000038, "Member 'UPyAIAbilityExitStage_NearTarget::AccessRange' has a wrong offset!");

// PythonClass ability_exit_stage_logic.PyAIAbilityExitStage_TooCloseToEnemy
// 0x0008 (0x0040 - 0x0038)
class UPyAIAbilityExitStage_TooCloseToEnemy : public UPyAIAbilityExitStageLogicBase
{
public:
	float                                         AccessRange;                                       // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PyAIAbilityExitStage_TooCloseToEnemy">();
	}
	static class UPyAIAbilityExitStage_TooCloseToEnemy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPyAIAbilityExitStage_TooCloseToEnemy>();
	}
};
static_assert(alignof(UPyAIAbilityExitStage_TooCloseToEnemy) == 0x000008, "Wrong alignment on UPyAIAbilityExitStage_TooCloseToEnemy");
static_assert(sizeof(UPyAIAbilityExitStage_TooCloseToEnemy) == 0x000040, "Wrong size on UPyAIAbilityExitStage_TooCloseToEnemy");
static_assert(offsetof(UPyAIAbilityExitStage_TooCloseToEnemy, AccessRange) == 0x000038, "Member 'UPyAIAbilityExitStage_TooCloseToEnemy::AccessRange' has a wrong offset!");

// PythonClass ability_exit_stage_logic.PyAIAbilityExitStage_VelocityLessThan
// 0x0008 (0x0040 - 0x0038)
class UPyAIAbilityExitStage_VelocityLessThan : public UPyAIAbilityExitStageLogicBase
{
public:
	float                                         Velocity;                                          // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PyAIAbilityExitStage_VelocityLessThan">();
	}
	static class UPyAIAbilityExitStage_VelocityLessThan* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPyAIAbilityExitStage_VelocityLessThan>();
	}
};
static_assert(alignof(UPyAIAbilityExitStage_VelocityLessThan) == 0x000008, "Wrong alignment on UPyAIAbilityExitStage_VelocityLessThan");
static_assert(sizeof(UPyAIAbilityExitStage_VelocityLessThan) == 0x000040, "Wrong size on UPyAIAbilityExitStage_VelocityLessThan");
static_assert(offsetof(UPyAIAbilityExitStage_VelocityLessThan, Velocity) == 0x000038, "Member 'UPyAIAbilityExitStage_VelocityLessThan::Velocity' has a wrong offset!");

// PythonClass ability_exit_stage_logic.PyAIAbilityExitStage_AmmoNumCheck
// 0x0008 (0x0040 - 0x0038)
class UPyAIAbilityExitStage_AmmoNumCheck : public UPyAIAbilityExitStageLogicBase
{
public:
	float                                         AmmoNumThreshold;                                  // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAmmoClipType                                 AmmoType;                                          // 0x003C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InverseResult;                                     // 0x003D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PyAIAbilityExitStage_AmmoNumCheck">();
	}
	static class UPyAIAbilityExitStage_AmmoNumCheck* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPyAIAbilityExitStage_AmmoNumCheck>();
	}
};
static_assert(alignof(UPyAIAbilityExitStage_AmmoNumCheck) == 0x000008, "Wrong alignment on UPyAIAbilityExitStage_AmmoNumCheck");
static_assert(sizeof(UPyAIAbilityExitStage_AmmoNumCheck) == 0x000040, "Wrong size on UPyAIAbilityExitStage_AmmoNumCheck");
static_assert(offsetof(UPyAIAbilityExitStage_AmmoNumCheck, AmmoNumThreshold) == 0x000038, "Member 'UPyAIAbilityExitStage_AmmoNumCheck::AmmoNumThreshold' has a wrong offset!");
static_assert(offsetof(UPyAIAbilityExitStage_AmmoNumCheck, AmmoType) == 0x00003C, "Member 'UPyAIAbilityExitStage_AmmoNumCheck::AmmoType' has a wrong offset!");
static_assert(offsetof(UPyAIAbilityExitStage_AmmoNumCheck, InverseResult) == 0x00003D, "Member 'UPyAIAbilityExitStage_AmmoNumCheck::InverseResult' has a wrong offset!");

// PythonClass ability_exit_stage_logic.PyAIAbilityExitStage_SelfHasTag
// 0x0070 (0x00A8 - 0x0038)
class UPyAIAbilityExitStage_SelfHasTag : public UPyAIAbilityExitStageLogicBase
{
public:
	struct FGameplayTagContainer                  TagsToCheck;                                       // 0x0038(0x0068)(Edit, NativeAccessSpecifierPublic)
	bool                                          InverseResult;                                     // 0x00A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PyAIAbilityExitStage_SelfHasTag">();
	}
	static class UPyAIAbilityExitStage_SelfHasTag* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPyAIAbilityExitStage_SelfHasTag>();
	}
};
static_assert(alignof(UPyAIAbilityExitStage_SelfHasTag) == 0x000008, "Wrong alignment on UPyAIAbilityExitStage_SelfHasTag");
static_assert(sizeof(UPyAIAbilityExitStage_SelfHasTag) == 0x0000A8, "Wrong size on UPyAIAbilityExitStage_SelfHasTag");
static_assert(offsetof(UPyAIAbilityExitStage_SelfHasTag, TagsToCheck) == 0x000038, "Member 'UPyAIAbilityExitStage_SelfHasTag::TagsToCheck' has a wrong offset!");
static_assert(offsetof(UPyAIAbilityExitStage_SelfHasTag, InverseResult) == 0x0000A0, "Member 'UPyAIAbilityExitStage_SelfHasTag::InverseResult' has a wrong offset!");

// PythonClass ability_exit_stage_logic.PyAIAbilityExitStage_103761HasExpectedEnergy
// 0x0008 (0x0040 - 0x0038)
class UPyAIAbilityExitStage_103761HasExpectedEnergy : public UPyAIAbilityExitStageLogicBase
{
public:
	int32                                         AbilityID;                                         // 0x0038(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EnemyThreshold;                                    // 0x003C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PyAIAbilityExitStage_103761HasExpectedEnergy">();
	}
	static class UPyAIAbilityExitStage_103761HasExpectedEnergy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPyAIAbilityExitStage_103761HasExpectedEnergy>();
	}
};
static_assert(alignof(UPyAIAbilityExitStage_103761HasExpectedEnergy) == 0x000008, "Wrong alignment on UPyAIAbilityExitStage_103761HasExpectedEnergy");
static_assert(sizeof(UPyAIAbilityExitStage_103761HasExpectedEnergy) == 0x000040, "Wrong size on UPyAIAbilityExitStage_103761HasExpectedEnergy");
static_assert(offsetof(UPyAIAbilityExitStage_103761HasExpectedEnergy, AbilityID) == 0x000038, "Member 'UPyAIAbilityExitStage_103761HasExpectedEnergy::AbilityID' has a wrong offset!");
static_assert(offsetof(UPyAIAbilityExitStage_103761HasExpectedEnergy, EnemyThreshold) == 0x00003C, "Member 'UPyAIAbilityExitStage_103761HasExpectedEnergy::EnemyThreshold' has a wrong offset!");

// PythonClass ability_exit_stage_logic.PyAIAbilityExitStage_102131ChargingState
// 0x0008 (0x0040 - 0x0038)
class UPyAIAbilityExitStage_102131ChargingState : public UPyAIAbilityExitStageLogicBase
{
public:
	int32                                         AbilityID_102111;                                  // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AbilityID_102131;                                  // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PyAIAbilityExitStage_102131ChargingState">();
	}
	static class UPyAIAbilityExitStage_102131ChargingState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPyAIAbilityExitStage_102131ChargingState>();
	}
};
static_assert(alignof(UPyAIAbilityExitStage_102131ChargingState) == 0x000008, "Wrong alignment on UPyAIAbilityExitStage_102131ChargingState");
static_assert(sizeof(UPyAIAbilityExitStage_102131ChargingState) == 0x000040, "Wrong size on UPyAIAbilityExitStage_102131ChargingState");
static_assert(offsetof(UPyAIAbilityExitStage_102131ChargingState, AbilityID_102111) == 0x000038, "Member 'UPyAIAbilityExitStage_102131ChargingState::AbilityID_102111' has a wrong offset!");
static_assert(offsetof(UPyAIAbilityExitStage_102131ChargingState, AbilityID_102131) == 0x00003C, "Member 'UPyAIAbilityExitStage_102131ChargingState::AbilityID_102131' has a wrong offset!");

// PythonClass ability_exit_stage_logic.PyAIAbilityExitStage_NearBlackBoardKeyPosition
// 0x0018 (0x0050 - 0x0038)
class UPyAIAbilityExitStage_NearBlackBoardKeyPosition : public UPyAIAbilityExitStageLogicBase
{
public:
	float                                         AccessRange;                                       // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 BlackBoardKeyName;                                 // 0x0040(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PyAIAbilityExitStage_NearBlackBoardKeyPosition">();
	}
	static class UPyAIAbilityExitStage_NearBlackBoardKeyPosition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPyAIAbilityExitStage_NearBlackBoardKeyPosition>();
	}
};
static_assert(alignof(UPyAIAbilityExitStage_NearBlackBoardKeyPosition) == 0x000008, "Wrong alignment on UPyAIAbilityExitStage_NearBlackBoardKeyPosition");
static_assert(sizeof(UPyAIAbilityExitStage_NearBlackBoardKeyPosition) == 0x000050, "Wrong size on UPyAIAbilityExitStage_NearBlackBoardKeyPosition");
static_assert(offsetof(UPyAIAbilityExitStage_NearBlackBoardKeyPosition, AccessRange) == 0x000038, "Member 'UPyAIAbilityExitStage_NearBlackBoardKeyPosition::AccessRange' has a wrong offset!");
static_assert(offsetof(UPyAIAbilityExitStage_NearBlackBoardKeyPosition, BlackBoardKeyName) == 0x000040, "Member 'UPyAIAbilityExitStage_NearBlackBoardKeyPosition::BlackBoardKeyName' has a wrong offset!");

// PythonClass ability_exit_stage_logic.PyAIAbilityExitStage_CheckTargetBelow
// 0x0018 (0x0050 - 0x0038)
class UPyAIAbilityExitStage_CheckTargetBelow : public UPyAIAbilityExitStageLogicBase
{
public:
	float                                         CheckAngle;                                        // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AbilityRadius;                                     // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeightError;                                       // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DownDistance;                                      // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CheckTargetType;                                   // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PyAIAbilityExitStage_CheckTargetBelow">();
	}
	static class UPyAIAbilityExitStage_CheckTargetBelow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPyAIAbilityExitStage_CheckTargetBelow>();
	}
};
static_assert(alignof(UPyAIAbilityExitStage_CheckTargetBelow) == 0x000008, "Wrong alignment on UPyAIAbilityExitStage_CheckTargetBelow");
static_assert(sizeof(UPyAIAbilityExitStage_CheckTargetBelow) == 0x000050, "Wrong size on UPyAIAbilityExitStage_CheckTargetBelow");
static_assert(offsetof(UPyAIAbilityExitStage_CheckTargetBelow, CheckAngle) == 0x000038, "Member 'UPyAIAbilityExitStage_CheckTargetBelow::CheckAngle' has a wrong offset!");
static_assert(offsetof(UPyAIAbilityExitStage_CheckTargetBelow, AbilityRadius) == 0x00003C, "Member 'UPyAIAbilityExitStage_CheckTargetBelow::AbilityRadius' has a wrong offset!");
static_assert(offsetof(UPyAIAbilityExitStage_CheckTargetBelow, HeightError) == 0x000040, "Member 'UPyAIAbilityExitStage_CheckTargetBelow::HeightError' has a wrong offset!");
static_assert(offsetof(UPyAIAbilityExitStage_CheckTargetBelow, DownDistance) == 0x000044, "Member 'UPyAIAbilityExitStage_CheckTargetBelow::DownDistance' has a wrong offset!");
static_assert(offsetof(UPyAIAbilityExitStage_CheckTargetBelow, CheckTargetType) == 0x000048, "Member 'UPyAIAbilityExitStage_CheckTargetBelow::CheckTargetType' has a wrong offset!");

// PythonClass ability_exit_stage_logic.PyAIAbilityExitStage_CheckTeammateAroundFullHealth
// 0x0010 (0x0048 - 0x0038)
class UPyAIAbilityExitStage_CheckTeammateAroundFullHealth : public UPyAIAbilityExitStageLogicBase
{
public:
	bool                                          CheckSelf;                                         // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRange_FloatValue                      CheckRadius;                                       // 0x003C(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PyAIAbilityExitStage_CheckTeammateAroundFullHealth">();
	}
	static class UPyAIAbilityExitStage_CheckTeammateAroundFullHealth* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPyAIAbilityExitStage_CheckTeammateAroundFullHealth>();
	}
};
static_assert(alignof(UPyAIAbilityExitStage_CheckTeammateAroundFullHealth) == 0x000008, "Wrong alignment on UPyAIAbilityExitStage_CheckTeammateAroundFullHealth");
static_assert(sizeof(UPyAIAbilityExitStage_CheckTeammateAroundFullHealth) == 0x000048, "Wrong size on UPyAIAbilityExitStage_CheckTeammateAroundFullHealth");
static_assert(offsetof(UPyAIAbilityExitStage_CheckTeammateAroundFullHealth, CheckSelf) == 0x000038, "Member 'UPyAIAbilityExitStage_CheckTeammateAroundFullHealth::CheckSelf' has a wrong offset!");
static_assert(offsetof(UPyAIAbilityExitStage_CheckTeammateAroundFullHealth, CheckRadius) == 0x00003C, "Member 'UPyAIAbilityExitStage_CheckTeammateAroundFullHealth::CheckRadius' has a wrong offset!");

}

